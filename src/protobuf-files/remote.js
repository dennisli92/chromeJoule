/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    /**
     * SystemActor enum.
     * @exports SystemActor
     * @enum {string}
     * @property {number} COOKING_APP=1 COOKING_APP value
     * @property {number} CIRCULATOR=2 CIRCULATOR value
     * @property {number} SERVICE=3 SERVICE value
     * @property {number} PREDICTIVE_COOKING=4 PREDICTIVE_COOKING value
     */
    $root.SystemActor = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "COOKING_APP"] = 1;
        values[valuesById[2] = "CIRCULATOR"] = 2;
        values[valuesById[3] = "SERVICE"] = 3;
        values[valuesById[4] = "PREDICTIVE_COOKING"] = 4;
        return values;
    })();
    
    $root.RemoteMessage = (function() {
    
        /**
         * Properties of a RemoteMessage.
         * @exports IRemoteMessage
         * @interface IRemoteMessage
         * @property {number} [handle] RemoteMessage handle
         * @property {boolean} [end] RemoteMessage end
         * @property {SystemActor} senderType RemoteMessage senderType
         * @property {number} senderId RemoteMessage senderId
         * @property {SystemActor} receiverType RemoteMessage receiverType
         * @property {number} receiverId RemoteMessage receiverId
         * @property {Uint8Array} encodedStreamMessage RemoteMessage encodedStreamMessage
         */
    
        /**
         * Constructs a new RemoteMessage.
         * @exports RemoteMessage
         * @classdesc Represents a RemoteMessage.
         * @constructor
         * @param {IRemoteMessage=} [properties] Properties to set
         */
        function RemoteMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * RemoteMessage handle.
         * @member {number}handle
         * @memberof RemoteMessage
         * @instance
         */
        RemoteMessage.prototype.handle = 0;
    
        /**
         * RemoteMessage end.
         * @member {boolean}end
         * @memberof RemoteMessage
         * @instance
         */
        RemoteMessage.prototype.end = false;
    
        /**
         * RemoteMessage senderType.
         * @member {SystemActor}senderType
         * @memberof RemoteMessage
         * @instance
         */
        RemoteMessage.prototype.senderType = 1;
    
        /**
         * RemoteMessage senderId.
         * @member {number}senderId
         * @memberof RemoteMessage
         * @instance
         */
        RemoteMessage.prototype.senderId = 0;
    
        /**
         * RemoteMessage receiverType.
         * @member {SystemActor}receiverType
         * @memberof RemoteMessage
         * @instance
         */
        RemoteMessage.prototype.receiverType = 1;
    
        /**
         * RemoteMessage receiverId.
         * @member {number}receiverId
         * @memberof RemoteMessage
         * @instance
         */
        RemoteMessage.prototype.receiverId = 0;
    
        /**
         * RemoteMessage encodedStreamMessage.
         * @member {Uint8Array}encodedStreamMessage
         * @memberof RemoteMessage
         * @instance
         */
        RemoteMessage.prototype.encodedStreamMessage = $util.newBuffer([]);
    
        /**
         * Creates a new RemoteMessage instance using the specified properties.
         * @function create
         * @memberof RemoteMessage
         * @static
         * @param {IRemoteMessage=} [properties] Properties to set
         * @returns {RemoteMessage} RemoteMessage instance
         */
        RemoteMessage.create = function create(properties) {
            return new RemoteMessage(properties);
        };
    
        /**
         * Encodes the specified RemoteMessage message. Does not implicitly {@link RemoteMessage.verify|verify} messages.
         * @function encode
         * @memberof RemoteMessage
         * @static
         * @param {IRemoteMessage} message RemoteMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoteMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.senderType);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.senderId);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.receiverType);
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.receiverId);
            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.encodedStreamMessage);
            if (message.handle != null && message.hasOwnProperty("handle"))
                writer.uint32(/* id 10, wireType 5 =*/85).fixed32(message.handle);
            if (message.end != null && message.hasOwnProperty("end"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.end);
            return writer;
        };
    
        /**
         * Encodes the specified RemoteMessage message, length delimited. Does not implicitly {@link RemoteMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RemoteMessage
         * @static
         * @param {IRemoteMessage} message RemoteMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoteMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RemoteMessage message from the specified reader or buffer.
         * @function decode
         * @memberof RemoteMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RemoteMessage} RemoteMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoteMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoteMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 10:
                    message.handle = reader.fixed32();
                    break;
                case 11:
                    message.end = reader.bool();
                    break;
                case 1:
                    message.senderType = reader.int32();
                    break;
                case 2:
                    message.senderId = reader.uint32();
                    break;
                case 3:
                    message.receiverType = reader.int32();
                    break;
                case 4:
                    message.receiverId = reader.uint32();
                    break;
                case 5:
                    message.encodedStreamMessage = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("senderType"))
                throw $util.ProtocolError("missing required 'senderType'", { instance: message });
            if (!message.hasOwnProperty("senderId"))
                throw $util.ProtocolError("missing required 'senderId'", { instance: message });
            if (!message.hasOwnProperty("receiverType"))
                throw $util.ProtocolError("missing required 'receiverType'", { instance: message });
            if (!message.hasOwnProperty("receiverId"))
                throw $util.ProtocolError("missing required 'receiverId'", { instance: message });
            if (!message.hasOwnProperty("encodedStreamMessage"))
                throw $util.ProtocolError("missing required 'encodedStreamMessage'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a RemoteMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RemoteMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RemoteMessage} RemoteMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoteMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RemoteMessage message.
         * @function verify
         * @memberof RemoteMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RemoteMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.handle != null && message.hasOwnProperty("handle"))
                if (!$util.isInteger(message.handle))
                    return "handle: integer expected";
            if (message.end != null && message.hasOwnProperty("end"))
                if (typeof message.end !== "boolean")
                    return "end: boolean expected";
            switch (message.senderType) {
            default:
                return "senderType: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
            if (!$util.isInteger(message.senderId))
                return "senderId: integer expected";
            switch (message.receiverType) {
            default:
                return "receiverType: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
            if (!$util.isInteger(message.receiverId))
                return "receiverId: integer expected";
            if (!(message.encodedStreamMessage && typeof message.encodedStreamMessage.length === "number" || $util.isString(message.encodedStreamMessage)))
                return "encodedStreamMessage: buffer expected";
            return null;
        };
    
        /**
         * Creates a RemoteMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RemoteMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RemoteMessage} RemoteMessage
         */
        RemoteMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.RemoteMessage)
                return object;
            var message = new $root.RemoteMessage();
            if (object.handle != null)
                message.handle = object.handle >>> 0;
            if (object.end != null)
                message.end = Boolean(object.end);
            switch (object.senderType) {
            case "COOKING_APP":
            case 1:
                message.senderType = 1;
                break;
            case "CIRCULATOR":
            case 2:
                message.senderType = 2;
                break;
            case "SERVICE":
            case 3:
                message.senderType = 3;
                break;
            case "PREDICTIVE_COOKING":
            case 4:
                message.senderType = 4;
                break;
            }
            if (object.senderId != null)
                message.senderId = object.senderId >>> 0;
            switch (object.receiverType) {
            case "COOKING_APP":
            case 1:
                message.receiverType = 1;
                break;
            case "CIRCULATOR":
            case 2:
                message.receiverType = 2;
                break;
            case "SERVICE":
            case 3:
                message.receiverType = 3;
                break;
            case "PREDICTIVE_COOKING":
            case 4:
                message.receiverType = 4;
                break;
            }
            if (object.receiverId != null)
                message.receiverId = object.receiverId >>> 0;
            if (object.encodedStreamMessage != null)
                if (typeof object.encodedStreamMessage === "string")
                    $util.base64.decode(object.encodedStreamMessage, message.encodedStreamMessage = $util.newBuffer($util.base64.length(object.encodedStreamMessage)), 0);
                else if (object.encodedStreamMessage.length)
                    message.encodedStreamMessage = object.encodedStreamMessage;
            return message;
        };
    
        /**
         * Creates a plain object from a RemoteMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RemoteMessage
         * @static
         * @param {RemoteMessage} message RemoteMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RemoteMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.senderType = options.enums === String ? "COOKING_APP" : 1;
                object.senderId = 0;
                object.receiverType = options.enums === String ? "COOKING_APP" : 1;
                object.receiverId = 0;
                object.encodedStreamMessage = options.bytes === String ? "" : [];
                object.handle = 0;
                object.end = false;
            }
            if (message.senderType != null && message.hasOwnProperty("senderType"))
                object.senderType = options.enums === String ? $root.SystemActor[message.senderType] : message.senderType;
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                object.senderId = message.senderId;
            if (message.receiverType != null && message.hasOwnProperty("receiverType"))
                object.receiverType = options.enums === String ? $root.SystemActor[message.receiverType] : message.receiverType;
            if (message.receiverId != null && message.hasOwnProperty("receiverId"))
                object.receiverId = message.receiverId;
            if (message.encodedStreamMessage != null && message.hasOwnProperty("encodedStreamMessage"))
                object.encodedStreamMessage = options.bytes === String ? $util.base64.encode(message.encodedStreamMessage, 0, message.encodedStreamMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.encodedStreamMessage) : message.encodedStreamMessage;
            if (message.handle != null && message.hasOwnProperty("handle"))
                object.handle = message.handle;
            if (message.end != null && message.hasOwnProperty("end"))
                object.end = message.end;
            return object;
        };
    
        /**
         * Converts this RemoteMessage to JSON.
         * @function toJSON
         * @memberof RemoteMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RemoteMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return RemoteMessage;
    })();
    
    $root.StreamMessage = (function() {
    
        /**
         * Properties of a StreamMessage.
         * @exports IStreamMessage
         * @interface IStreamMessage
         * @property {number} handle StreamMessage handle
         * @property {boolean} [end] StreamMessage end
         * @property {Uint8Array} senderAddress StreamMessage senderAddress
         * @property {Uint8Array} recipientAddress StreamMessage recipientAddress
         * @property {INoop} [noop] StreamMessage noop
         * @property {IUnhandledMessageReply} [unhandledMessageReply] StreamMessage unhandledMessageReply
         * @property {IConnectionReadyReply} [connectionReadyReply] StreamMessage connectionReadyReply
         * @property {IRecipientUnavailableReply} [recipientUnavailableReply] StreamMessage recipientUnavailableReply
         * @property {IPing} [ping] StreamMessage ping
         * @property {IPong} [pong] StreamMessage pong
         * @property {IListStreamsRequest} [listStreamsRequest] StreamMessage listStreamsRequest
         * @property {IListStreamsReply} [listStreamsReply] StreamMessage listStreamsReply
         * @property {IListOperationsRequest} [listOperationsRequest] StreamMessage listOperationsRequest
         * @property {IListOperationsReply} [listOperationsReply] StreamMessage listOperationsReply
         * @property {IStartProgramRequest} [startProgramRequest] StreamMessage startProgramRequest
         * @property {IStartProgramReply} [startProgramReply] StreamMessage startProgramReply
         * @property {IStopCirculatorRequest} [stopCirculatorRequest] StreamMessage stopCirculatorRequest
         * @property {IStopCirculatorReply} [stopCirculatorReply] StreamMessage stopCirculatorReply
         * @property {IDropFoodRequest} [dropFoodRequest] StreamMessage dropFoodRequest
         * @property {IDropFoodReply} [dropFoodReply] StreamMessage dropFoodReply
         * @property {IBeginLiveFeed} [beginLiveFeed] StreamMessage beginLiveFeed
         * @property {IBeginLiveFeedReply} [beginLiveFeedReply] StreamMessage beginLiveFeedReply
         * @property {IKeepAlive} [keepAlive] StreamMessage keepAlive
         * @property {IRetransmitFeedRequest} [retransmitFeedRequest] StreamMessage retransmitFeedRequest
         * @property {IRetransmitFeedReply} [retransmitFeedReply] StreamMessage retransmitFeedReply
         * @property {ICirculatorDataPoint} [circulatorDataPoint] StreamMessage circulatorDataPoint
         * @property {IDebugMessage} [debugMessage] StreamMessage debugMessage
         * @property {IListRecentEventsRequest} [listRecentEventsRequest] StreamMessage listRecentEventsRequest
         * @property {IListRecentEventsReply} [listRecentEventsReply] StreamMessage listRecentEventsReply
         * @property {IDescribeFeedRequest} [describeFeedRequest] StreamMessage describeFeedRequest
         * @property {IDescribeFeedReply} [describeFeedReply] StreamMessage describeFeedReply
         * @property {IListFeedsRequest} [listFeedsRequest] StreamMessage listFeedsRequest
         * @property {IListFeedsReply} [listFeedsReply] StreamMessage listFeedsReply
         * @property {IClearErrorRequest} [clearErrorRequest] StreamMessage clearErrorRequest
         * @property {IClearErrorReply} [clearErrorReply] StreamMessage clearErrorReply
         * @property {IListWifiRequest} [listWifiRequest] StreamMessage listWifiRequest
         * @property {IListWifiReply} [listWifiReply] StreamMessage listWifiReply
         * @property {IConnectWifiRequest} [connectWifiRequest] StreamMessage connectWifiRequest
         * @property {IConnectWifiReply} [connectWifiReply] StreamMessage connectWifiReply
         * @property {IListWifiProfileRequest} [listWifiProfileRequest] StreamMessage listWifiProfileRequest
         * @property {IListWifiProfileReply} [listWifiProfileReply] StreamMessage listWifiProfileReply
         * @property {IForgetWifiProfileRequest} [forgetWifiProfileRequest] StreamMessage forgetWifiProfileRequest
         * @property {IForgetWifiProfileReply} [forgetWifiProfileReply] StreamMessage forgetWifiProfileReply
         * @property {IDisconnectWifiRequest} [disconnectWifiRequest] StreamMessage disconnectWifiRequest
         * @property {IDisconnectWifiReply} [disconnectWifiReply] StreamMessage disconnectWifiReply
         * @property {IEnterBootModeRequest} [enterBootModeRequest] StreamMessage enterBootModeRequest
         * @property {IEnterBootModeReply} [enterBootModeReply] StreamMessage enterBootModeReply
         * @property {IStartFileTransferRequest} [startFileTransferRequest] StreamMessage startFileTransferRequest
         * @property {IStartFileTransferReply} [startFileTransferReply] StreamMessage startFileTransferReply
         * @property {ITransferFileBlockRequest} [transferFileBlockRequest] StreamMessage transferFileBlockRequest
         * @property {ITransferFileBlockReply} [transferFileBlockReply] StreamMessage transferFileBlockReply
         * @property {ITransferFileComplete} [transferFileComplete] StreamMessage transferFileComplete
         * @property {IStartFileReceiveRequest} [startFileReceiveRequest] StreamMessage startFileReceiveRequest
         * @property {IStartFileReceiveReply} [startFileReceiveReply] StreamMessage startFileReceiveReply
         * @property {IStartKeyExchangeRequest} [startKeyExchangeRequest] StreamMessage startKeyExchangeRequest
         * @property {IStartKeyExchangeReply} [startKeyExchangeReply] StreamMessage startKeyExchangeReply
         * @property {ICancelKeyExchangeRequest} [cancelKeyExchangeRequest] StreamMessage cancelKeyExchangeRequest
         * @property {ICancelKeyExchangeReply} [cancelKeyExchangeReply] StreamMessage cancelKeyExchangeReply
         * @property {ISubmitKeyRequest} [submitKeyRequest] StreamMessage submitKeyRequest
         * @property {ISubmitKeyReply} [submitKeyReply] StreamMessage submitKeyReply
         * @property {ISubmitBearerAuthTokenRequest} [submitBearerAuthTokenRequest] StreamMessage submitBearerAuthTokenRequest
         * @property {ISubmitBearerAuthTokenReply} [submitBearerAuthTokenReply] StreamMessage submitBearerAuthTokenReply
         * @property {IPredictionUpdate} [predictionUpdate] StreamMessage predictionUpdate
         * @property {IRenameCirculatorRequest} [renameCirculatorRequest] StreamMessage renameCirculatorRequest
         * @property {IRenameCirculatorReply} [renameCirculatorReply] StreamMessage renameCirculatorReply
         * @property {IIdentifyCirculatorRequest} [identifyCirculatorRequest] StreamMessage identifyCirculatorRequest
         * @property {IIdentifyCirculatorReply} [identifyCirculatorReply] StreamMessage identifyCirculatorReply
         * @property {ISetMessagingAddressRequest} [setMessagingAddressRequest] StreamMessage setMessagingAddressRequest
         * @property {ISetMessagingAddressReply} [setMessagingAddressReply] StreamMessage setMessagingAddressReply
         * @property {IDisplayLedRequest} [displayLedRequest] StreamMessage displayLedRequest
         * @property {IDisplayLedReply} [displayLedReply] StreamMessage displayLedReply
         * @property {IWifiDFUStatusRequest} [wifiDFUStatusRequest] StreamMessage wifiDFUStatusRequest
         * @property {IWifiDFUStatusReply} [wifiDFUStatusReply] StreamMessage wifiDFUStatusReply
         * @property {IWifiDFUSetFirmware} [wifiDFUSetFirmware] StreamMessage wifiDFUSetFirmware
         * @property {IWifiDFUDownloadTFTPRequest} [wifiDFUDownloadTFTPRequest] StreamMessage wifiDFUDownloadTFTPRequest
         * @property {IWifiDFUDownloadTFTPResponse} [wifiDFUDownloadTFTPResponse] StreamMessage wifiDFUDownloadTFTPResponse
         * @property {IGetLimitsRequest} [getLimitsRequest] StreamMessage getLimitsRequest
         * @property {IGetLimitsReply} [getLimitsReply] StreamMessage getLimitsReply
         * @property {IFactoryResetRequest} [factoryResetRequest] StreamMessage factoryResetRequest
         * @property {IFactoryResetReply} [factoryResetReply] StreamMessage factoryResetReply
         * @property {IDeviceRestartRequest} [deviceRestartRequest] StreamMessage deviceRestartRequest
         * @property {IDeviceRestartReply} [deviceRestartReply] StreamMessage deviceRestartReply
         * @property {ITestResetRequest} [testResetRequest] StreamMessage testResetRequest
         * @property {ITestResetReply} [testResetReply] StreamMessage testResetReply
         * @property {IForgetDevicePairingRequest} [forgetDevicePairingRequest] StreamMessage forgetDevicePairingRequest
         * @property {IForgetDevicePairingReply} [forgetDevicePairingReply] StreamMessage forgetDevicePairingReply
         * @property {ISetSimulatorRequest} [setSimulatorRequest] StreamMessage setSimulatorRequest
         * @property {ISetSimulatorReply} [setSimulatorReply] StreamMessage setSimulatorReply
         * @property {IGetSimulatorRequest} [getSimulatorRequest] StreamMessage getSimulatorRequest
         * @property {IGetSimulatorReply} [getSimulatorReply] StreamMessage getSimulatorReply
         * @property {ISetHardwareCoeffsRequest} [setHardwareCoeffsRequest] StreamMessage setHardwareCoeffsRequest
         * @property {ISetHardwareCoeffsReply} [setHardwareCoeffsReply] StreamMessage setHardwareCoeffsReply
         * @property {IGetHardwareCoeffsRequest} [getHardwareCoeffsRequest] StreamMessage getHardwareCoeffsRequest
         * @property {IGetHardwareCoeffsReply} [getHardwareCoeffsReply] StreamMessage getHardwareCoeffsReply
         * @property {IGetUsageDataRequest} [getUsageDataRequest] StreamMessage getUsageDataRequest
         * @property {IGetUsageDataReply} [getUsageDataReply] StreamMessage getUsageDataReply
         * @property {IResetUsageDataRequest} [resetUsageDataRequest] StreamMessage resetUsageDataRequest
         * @property {IResetUsageDataReply} [resetUsageDataReply] StreamMessage resetUsageDataReply
         */
    
        /**
         * Constructs a new StreamMessage.
         * @exports StreamMessage
         * @classdesc Represents a StreamMessage.
         * @constructor
         * @param {IStreamMessage=} [properties] Properties to set
         */
        function StreamMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * StreamMessage handle.
         * @member {number}handle
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.handle = 0;
    
        /**
         * StreamMessage end.
         * @member {boolean}end
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.end = false;
    
        /**
         * StreamMessage senderAddress.
         * @member {Uint8Array}senderAddress
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.senderAddress = $util.newBuffer([]);
    
        /**
         * StreamMessage recipientAddress.
         * @member {Uint8Array}recipientAddress
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.recipientAddress = $util.newBuffer([]);
    
        /**
         * StreamMessage noop.
         * @member {(INoop|null|undefined)}noop
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.noop = null;
    
        /**
         * StreamMessage unhandledMessageReply.
         * @member {(IUnhandledMessageReply|null|undefined)}unhandledMessageReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.unhandledMessageReply = null;
    
        /**
         * StreamMessage connectionReadyReply.
         * @member {(IConnectionReadyReply|null|undefined)}connectionReadyReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.connectionReadyReply = null;
    
        /**
         * StreamMessage recipientUnavailableReply.
         * @member {(IRecipientUnavailableReply|null|undefined)}recipientUnavailableReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.recipientUnavailableReply = null;
    
        /**
         * StreamMessage ping.
         * @member {(IPing|null|undefined)}ping
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.ping = null;
    
        /**
         * StreamMessage pong.
         * @member {(IPong|null|undefined)}pong
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.pong = null;
    
        /**
         * StreamMessage listStreamsRequest.
         * @member {(IListStreamsRequest|null|undefined)}listStreamsRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.listStreamsRequest = null;
    
        /**
         * StreamMessage listStreamsReply.
         * @member {(IListStreamsReply|null|undefined)}listStreamsReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.listStreamsReply = null;
    
        /**
         * StreamMessage listOperationsRequest.
         * @member {(IListOperationsRequest|null|undefined)}listOperationsRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.listOperationsRequest = null;
    
        /**
         * StreamMessage listOperationsReply.
         * @member {(IListOperationsReply|null|undefined)}listOperationsReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.listOperationsReply = null;
    
        /**
         * StreamMessage startProgramRequest.
         * @member {(IStartProgramRequest|null|undefined)}startProgramRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.startProgramRequest = null;
    
        /**
         * StreamMessage startProgramReply.
         * @member {(IStartProgramReply|null|undefined)}startProgramReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.startProgramReply = null;
    
        /**
         * StreamMessage stopCirculatorRequest.
         * @member {(IStopCirculatorRequest|null|undefined)}stopCirculatorRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.stopCirculatorRequest = null;
    
        /**
         * StreamMessage stopCirculatorReply.
         * @member {(IStopCirculatorReply|null|undefined)}stopCirculatorReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.stopCirculatorReply = null;
    
        /**
         * StreamMessage dropFoodRequest.
         * @member {(IDropFoodRequest|null|undefined)}dropFoodRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.dropFoodRequest = null;
    
        /**
         * StreamMessage dropFoodReply.
         * @member {(IDropFoodReply|null|undefined)}dropFoodReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.dropFoodReply = null;
    
        /**
         * StreamMessage beginLiveFeed.
         * @member {(IBeginLiveFeed|null|undefined)}beginLiveFeed
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.beginLiveFeed = null;
    
        /**
         * StreamMessage beginLiveFeedReply.
         * @member {(IBeginLiveFeedReply|null|undefined)}beginLiveFeedReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.beginLiveFeedReply = null;
    
        /**
         * StreamMessage keepAlive.
         * @member {(IKeepAlive|null|undefined)}keepAlive
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.keepAlive = null;
    
        /**
         * StreamMessage retransmitFeedRequest.
         * @member {(IRetransmitFeedRequest|null|undefined)}retransmitFeedRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.retransmitFeedRequest = null;
    
        /**
         * StreamMessage retransmitFeedReply.
         * @member {(IRetransmitFeedReply|null|undefined)}retransmitFeedReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.retransmitFeedReply = null;
    
        /**
         * StreamMessage circulatorDataPoint.
         * @member {(ICirculatorDataPoint|null|undefined)}circulatorDataPoint
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.circulatorDataPoint = null;
    
        /**
         * StreamMessage debugMessage.
         * @member {(IDebugMessage|null|undefined)}debugMessage
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.debugMessage = null;
    
        /**
         * StreamMessage listRecentEventsRequest.
         * @member {(IListRecentEventsRequest|null|undefined)}listRecentEventsRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.listRecentEventsRequest = null;
    
        /**
         * StreamMessage listRecentEventsReply.
         * @member {(IListRecentEventsReply|null|undefined)}listRecentEventsReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.listRecentEventsReply = null;
    
        /**
         * StreamMessage describeFeedRequest.
         * @member {(IDescribeFeedRequest|null|undefined)}describeFeedRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.describeFeedRequest = null;
    
        /**
         * StreamMessage describeFeedReply.
         * @member {(IDescribeFeedReply|null|undefined)}describeFeedReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.describeFeedReply = null;
    
        /**
         * StreamMessage listFeedsRequest.
         * @member {(IListFeedsRequest|null|undefined)}listFeedsRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.listFeedsRequest = null;
    
        /**
         * StreamMessage listFeedsReply.
         * @member {(IListFeedsReply|null|undefined)}listFeedsReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.listFeedsReply = null;
    
        /**
         * StreamMessage clearErrorRequest.
         * @member {(IClearErrorRequest|null|undefined)}clearErrorRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.clearErrorRequest = null;
    
        /**
         * StreamMessage clearErrorReply.
         * @member {(IClearErrorReply|null|undefined)}clearErrorReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.clearErrorReply = null;
    
        /**
         * StreamMessage listWifiRequest.
         * @member {(IListWifiRequest|null|undefined)}listWifiRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.listWifiRequest = null;
    
        /**
         * StreamMessage listWifiReply.
         * @member {(IListWifiReply|null|undefined)}listWifiReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.listWifiReply = null;
    
        /**
         * StreamMessage connectWifiRequest.
         * @member {(IConnectWifiRequest|null|undefined)}connectWifiRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.connectWifiRequest = null;
    
        /**
         * StreamMessage connectWifiReply.
         * @member {(IConnectWifiReply|null|undefined)}connectWifiReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.connectWifiReply = null;
    
        /**
         * StreamMessage listWifiProfileRequest.
         * @member {(IListWifiProfileRequest|null|undefined)}listWifiProfileRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.listWifiProfileRequest = null;
    
        /**
         * StreamMessage listWifiProfileReply.
         * @member {(IListWifiProfileReply|null|undefined)}listWifiProfileReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.listWifiProfileReply = null;
    
        /**
         * StreamMessage forgetWifiProfileRequest.
         * @member {(IForgetWifiProfileRequest|null|undefined)}forgetWifiProfileRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.forgetWifiProfileRequest = null;
    
        /**
         * StreamMessage forgetWifiProfileReply.
         * @member {(IForgetWifiProfileReply|null|undefined)}forgetWifiProfileReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.forgetWifiProfileReply = null;
    
        /**
         * StreamMessage disconnectWifiRequest.
         * @member {(IDisconnectWifiRequest|null|undefined)}disconnectWifiRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.disconnectWifiRequest = null;
    
        /**
         * StreamMessage disconnectWifiReply.
         * @member {(IDisconnectWifiReply|null|undefined)}disconnectWifiReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.disconnectWifiReply = null;
    
        /**
         * StreamMessage enterBootModeRequest.
         * @member {(IEnterBootModeRequest|null|undefined)}enterBootModeRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.enterBootModeRequest = null;
    
        /**
         * StreamMessage enterBootModeReply.
         * @member {(IEnterBootModeReply|null|undefined)}enterBootModeReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.enterBootModeReply = null;
    
        /**
         * StreamMessage startFileTransferRequest.
         * @member {(IStartFileTransferRequest|null|undefined)}startFileTransferRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.startFileTransferRequest = null;
    
        /**
         * StreamMessage startFileTransferReply.
         * @member {(IStartFileTransferReply|null|undefined)}startFileTransferReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.startFileTransferReply = null;
    
        /**
         * StreamMessage transferFileBlockRequest.
         * @member {(ITransferFileBlockRequest|null|undefined)}transferFileBlockRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.transferFileBlockRequest = null;
    
        /**
         * StreamMessage transferFileBlockReply.
         * @member {(ITransferFileBlockReply|null|undefined)}transferFileBlockReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.transferFileBlockReply = null;
    
        /**
         * StreamMessage transferFileComplete.
         * @member {(ITransferFileComplete|null|undefined)}transferFileComplete
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.transferFileComplete = null;
    
        /**
         * StreamMessage startFileReceiveRequest.
         * @member {(IStartFileReceiveRequest|null|undefined)}startFileReceiveRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.startFileReceiveRequest = null;
    
        /**
         * StreamMessage startFileReceiveReply.
         * @member {(IStartFileReceiveReply|null|undefined)}startFileReceiveReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.startFileReceiveReply = null;
    
        /**
         * StreamMessage startKeyExchangeRequest.
         * @member {(IStartKeyExchangeRequest|null|undefined)}startKeyExchangeRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.startKeyExchangeRequest = null;
    
        /**
         * StreamMessage startKeyExchangeReply.
         * @member {(IStartKeyExchangeReply|null|undefined)}startKeyExchangeReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.startKeyExchangeReply = null;
    
        /**
         * StreamMessage cancelKeyExchangeRequest.
         * @member {(ICancelKeyExchangeRequest|null|undefined)}cancelKeyExchangeRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.cancelKeyExchangeRequest = null;
    
        /**
         * StreamMessage cancelKeyExchangeReply.
         * @member {(ICancelKeyExchangeReply|null|undefined)}cancelKeyExchangeReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.cancelKeyExchangeReply = null;
    
        /**
         * StreamMessage submitKeyRequest.
         * @member {(ISubmitKeyRequest|null|undefined)}submitKeyRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.submitKeyRequest = null;
    
        /**
         * StreamMessage submitKeyReply.
         * @member {(ISubmitKeyReply|null|undefined)}submitKeyReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.submitKeyReply = null;
    
        /**
         * StreamMessage submitBearerAuthTokenRequest.
         * @member {(ISubmitBearerAuthTokenRequest|null|undefined)}submitBearerAuthTokenRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.submitBearerAuthTokenRequest = null;
    
        /**
         * StreamMessage submitBearerAuthTokenReply.
         * @member {(ISubmitBearerAuthTokenReply|null|undefined)}submitBearerAuthTokenReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.submitBearerAuthTokenReply = null;
    
        /**
         * StreamMessage predictionUpdate.
         * @member {(IPredictionUpdate|null|undefined)}predictionUpdate
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.predictionUpdate = null;
    
        /**
         * StreamMessage renameCirculatorRequest.
         * @member {(IRenameCirculatorRequest|null|undefined)}renameCirculatorRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.renameCirculatorRequest = null;
    
        /**
         * StreamMessage renameCirculatorReply.
         * @member {(IRenameCirculatorReply|null|undefined)}renameCirculatorReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.renameCirculatorReply = null;
    
        /**
         * StreamMessage identifyCirculatorRequest.
         * @member {(IIdentifyCirculatorRequest|null|undefined)}identifyCirculatorRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.identifyCirculatorRequest = null;
    
        /**
         * StreamMessage identifyCirculatorReply.
         * @member {(IIdentifyCirculatorReply|null|undefined)}identifyCirculatorReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.identifyCirculatorReply = null;
    
        /**
         * StreamMessage setMessagingAddressRequest.
         * @member {(ISetMessagingAddressRequest|null|undefined)}setMessagingAddressRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.setMessagingAddressRequest = null;
    
        /**
         * StreamMessage setMessagingAddressReply.
         * @member {(ISetMessagingAddressReply|null|undefined)}setMessagingAddressReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.setMessagingAddressReply = null;
    
        /**
         * StreamMessage displayLedRequest.
         * @member {(IDisplayLedRequest|null|undefined)}displayLedRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.displayLedRequest = null;
    
        /**
         * StreamMessage displayLedReply.
         * @member {(IDisplayLedReply|null|undefined)}displayLedReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.displayLedReply = null;
    
        /**
         * StreamMessage wifiDFUStatusRequest.
         * @member {(IWifiDFUStatusRequest|null|undefined)}wifiDFUStatusRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.wifiDFUStatusRequest = null;
    
        /**
         * StreamMessage wifiDFUStatusReply.
         * @member {(IWifiDFUStatusReply|null|undefined)}wifiDFUStatusReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.wifiDFUStatusReply = null;
    
        /**
         * StreamMessage wifiDFUSetFirmware.
         * @member {(IWifiDFUSetFirmware|null|undefined)}wifiDFUSetFirmware
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.wifiDFUSetFirmware = null;
    
        /**
         * StreamMessage wifiDFUDownloadTFTPRequest.
         * @member {(IWifiDFUDownloadTFTPRequest|null|undefined)}wifiDFUDownloadTFTPRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.wifiDFUDownloadTFTPRequest = null;
    
        /**
         * StreamMessage wifiDFUDownloadTFTPResponse.
         * @member {(IWifiDFUDownloadTFTPResponse|null|undefined)}wifiDFUDownloadTFTPResponse
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.wifiDFUDownloadTFTPResponse = null;
    
        /**
         * StreamMessage getLimitsRequest.
         * @member {(IGetLimitsRequest|null|undefined)}getLimitsRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.getLimitsRequest = null;
    
        /**
         * StreamMessage getLimitsReply.
         * @member {(IGetLimitsReply|null|undefined)}getLimitsReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.getLimitsReply = null;
    
        /**
         * StreamMessage factoryResetRequest.
         * @member {(IFactoryResetRequest|null|undefined)}factoryResetRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.factoryResetRequest = null;
    
        /**
         * StreamMessage factoryResetReply.
         * @member {(IFactoryResetReply|null|undefined)}factoryResetReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.factoryResetReply = null;
    
        /**
         * StreamMessage deviceRestartRequest.
         * @member {(IDeviceRestartRequest|null|undefined)}deviceRestartRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.deviceRestartRequest = null;
    
        /**
         * StreamMessage deviceRestartReply.
         * @member {(IDeviceRestartReply|null|undefined)}deviceRestartReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.deviceRestartReply = null;
    
        /**
         * StreamMessage testResetRequest.
         * @member {(ITestResetRequest|null|undefined)}testResetRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.testResetRequest = null;
    
        /**
         * StreamMessage testResetReply.
         * @member {(ITestResetReply|null|undefined)}testResetReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.testResetReply = null;
    
        /**
         * StreamMessage forgetDevicePairingRequest.
         * @member {(IForgetDevicePairingRequest|null|undefined)}forgetDevicePairingRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.forgetDevicePairingRequest = null;
    
        /**
         * StreamMessage forgetDevicePairingReply.
         * @member {(IForgetDevicePairingReply|null|undefined)}forgetDevicePairingReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.forgetDevicePairingReply = null;
    
        /**
         * StreamMessage setSimulatorRequest.
         * @member {(ISetSimulatorRequest|null|undefined)}setSimulatorRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.setSimulatorRequest = null;
    
        /**
         * StreamMessage setSimulatorReply.
         * @member {(ISetSimulatorReply|null|undefined)}setSimulatorReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.setSimulatorReply = null;
    
        /**
         * StreamMessage getSimulatorRequest.
         * @member {(IGetSimulatorRequest|null|undefined)}getSimulatorRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.getSimulatorRequest = null;
    
        /**
         * StreamMessage getSimulatorReply.
         * @member {(IGetSimulatorReply|null|undefined)}getSimulatorReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.getSimulatorReply = null;
    
        /**
         * StreamMessage setHardwareCoeffsRequest.
         * @member {(ISetHardwareCoeffsRequest|null|undefined)}setHardwareCoeffsRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.setHardwareCoeffsRequest = null;
    
        /**
         * StreamMessage setHardwareCoeffsReply.
         * @member {(ISetHardwareCoeffsReply|null|undefined)}setHardwareCoeffsReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.setHardwareCoeffsReply = null;
    
        /**
         * StreamMessage getHardwareCoeffsRequest.
         * @member {(IGetHardwareCoeffsRequest|null|undefined)}getHardwareCoeffsRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.getHardwareCoeffsRequest = null;
    
        /**
         * StreamMessage getHardwareCoeffsReply.
         * @member {(IGetHardwareCoeffsReply|null|undefined)}getHardwareCoeffsReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.getHardwareCoeffsReply = null;
    
        /**
         * StreamMessage getUsageDataRequest.
         * @member {(IGetUsageDataRequest|null|undefined)}getUsageDataRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.getUsageDataRequest = null;
    
        /**
         * StreamMessage getUsageDataReply.
         * @member {(IGetUsageDataReply|null|undefined)}getUsageDataReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.getUsageDataReply = null;
    
        /**
         * StreamMessage resetUsageDataRequest.
         * @member {(IResetUsageDataRequest|null|undefined)}resetUsageDataRequest
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.resetUsageDataRequest = null;
    
        /**
         * StreamMessage resetUsageDataReply.
         * @member {(IResetUsageDataReply|null|undefined)}resetUsageDataReply
         * @memberof StreamMessage
         * @instance
         */
        StreamMessage.prototype.resetUsageDataReply = null;
    
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
    
        /**
         * StreamMessage contents.
         * @member {string|undefined} contents
         * @memberof StreamMessage
         * @instance
         */
        Object.defineProperty(StreamMessage.prototype, "contents", {
            get: $util.oneOfGetter($oneOfFields = ["noop", "unhandledMessageReply", "connectionReadyReply", "recipientUnavailableReply", "ping", "pong", "listStreamsRequest", "listStreamsReply", "listOperationsRequest", "listOperationsReply", "startProgramRequest", "startProgramReply", "stopCirculatorRequest", "stopCirculatorReply", "dropFoodRequest", "dropFoodReply", "beginLiveFeed", "beginLiveFeedReply", "keepAlive", "retransmitFeedRequest", "retransmitFeedReply", "circulatorDataPoint", "debugMessage", "listRecentEventsRequest", "listRecentEventsReply", "describeFeedRequest", "describeFeedReply", "listFeedsRequest", "listFeedsReply", "clearErrorRequest", "clearErrorReply", "listWifiRequest", "listWifiReply", "connectWifiRequest", "connectWifiReply", "listWifiProfileRequest", "listWifiProfileReply", "forgetWifiProfileRequest", "forgetWifiProfileReply", "disconnectWifiRequest", "disconnectWifiReply", "enterBootModeRequest", "enterBootModeReply", "startFileTransferRequest", "startFileTransferReply", "transferFileBlockRequest", "transferFileBlockReply", "transferFileComplete", "startFileReceiveRequest", "startFileReceiveReply", "startKeyExchangeRequest", "startKeyExchangeReply", "cancelKeyExchangeRequest", "cancelKeyExchangeReply", "submitKeyRequest", "submitKeyReply", "submitBearerAuthTokenRequest", "submitBearerAuthTokenReply", "predictionUpdate", "renameCirculatorRequest", "renameCirculatorReply", "identifyCirculatorRequest", "identifyCirculatorReply", "setMessagingAddressRequest", "setMessagingAddressReply", "displayLedRequest", "displayLedReply", "wifiDFUStatusRequest", "wifiDFUStatusReply", "wifiDFUSetFirmware", "wifiDFUDownloadTFTPRequest", "wifiDFUDownloadTFTPResponse", "getLimitsRequest", "getLimitsReply", "factoryResetRequest", "factoryResetReply", "deviceRestartRequest", "deviceRestartReply", "testResetRequest", "testResetReply", "forgetDevicePairingRequest", "forgetDevicePairingReply", "setSimulatorRequest", "setSimulatorReply", "getSimulatorRequest", "getSimulatorReply", "setHardwareCoeffsRequest", "setHardwareCoeffsReply", "getHardwareCoeffsRequest", "getHardwareCoeffsReply", "getUsageDataRequest", "getUsageDataReply", "resetUsageDataRequest", "resetUsageDataReply"]),
            set: $util.oneOfSetter($oneOfFields)
        });
    
        /**
         * Creates a new StreamMessage instance using the specified properties.
         * @function create
         * @memberof StreamMessage
         * @static
         * @param {IStreamMessage=} [properties] Properties to set
         * @returns {StreamMessage} StreamMessage instance
         */
        StreamMessage.create = function create(properties) {
            return new StreamMessage(properties);
        };
    
        /**
         * Encodes the specified StreamMessage message. Does not implicitly {@link StreamMessage.verify|verify} messages.
         * @function encode
         * @memberof StreamMessage
         * @static
         * @param {IStreamMessage} message StreamMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.handle);
            if (message.end != null && message.hasOwnProperty("end"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.end);
            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.senderAddress);
            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.recipientAddress);
            if (message.noop != null && message.hasOwnProperty("noop"))
                $root.Noop.encode(message.noop, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.unhandledMessageReply != null && message.hasOwnProperty("unhandledMessageReply"))
                $root.UnhandledMessageReply.encode(message.unhandledMessageReply, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.connectionReadyReply != null && message.hasOwnProperty("connectionReadyReply"))
                $root.ConnectionReadyReply.encode(message.connectionReadyReply, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.recipientUnavailableReply != null && message.hasOwnProperty("recipientUnavailableReply"))
                $root.RecipientUnavailableReply.encode(message.recipientUnavailableReply, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.ping != null && message.hasOwnProperty("ping"))
                $root.Ping.encode(message.ping, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.pong != null && message.hasOwnProperty("pong"))
                $root.Pong.encode(message.pong, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.listStreamsRequest != null && message.hasOwnProperty("listStreamsRequest"))
                $root.ListStreamsRequest.encode(message.listStreamsRequest, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.listStreamsReply != null && message.hasOwnProperty("listStreamsReply"))
                $root.ListStreamsReply.encode(message.listStreamsReply, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.listOperationsRequest != null && message.hasOwnProperty("listOperationsRequest"))
                $root.ListOperationsRequest.encode(message.listOperationsRequest, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            if (message.listOperationsReply != null && message.hasOwnProperty("listOperationsReply"))
                $root.ListOperationsReply.encode(message.listOperationsReply, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.listWifiRequest != null && message.hasOwnProperty("listWifiRequest"))
                $root.ListWifiRequest.encode(message.listWifiRequest, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
            if (message.listWifiReply != null && message.hasOwnProperty("listWifiReply"))
                $root.ListWifiReply.encode(message.listWifiReply, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
            if (message.connectWifiRequest != null && message.hasOwnProperty("connectWifiRequest"))
                $root.ConnectWifiRequest.encode(message.connectWifiRequest, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
            if (message.connectWifiReply != null && message.hasOwnProperty("connectWifiReply"))
                $root.ConnectWifiReply.encode(message.connectWifiReply, writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
            if (message.listWifiProfileRequest != null && message.hasOwnProperty("listWifiProfileRequest"))
                $root.ListWifiProfileRequest.encode(message.listWifiProfileRequest, writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
            if (message.listWifiProfileReply != null && message.hasOwnProperty("listWifiProfileReply"))
                $root.ListWifiProfileReply.encode(message.listWifiProfileReply, writer.uint32(/* id 47, wireType 2 =*/378).fork()).ldelim();
            if (message.forgetWifiProfileRequest != null && message.hasOwnProperty("forgetWifiProfileRequest"))
                $root.ForgetWifiProfileRequest.encode(message.forgetWifiProfileRequest, writer.uint32(/* id 48, wireType 2 =*/386).fork()).ldelim();
            if (message.forgetWifiProfileReply != null && message.hasOwnProperty("forgetWifiProfileReply"))
                $root.ForgetWifiProfileReply.encode(message.forgetWifiProfileReply, writer.uint32(/* id 49, wireType 2 =*/394).fork()).ldelim();
            if (message.startProgramRequest != null && message.hasOwnProperty("startProgramRequest"))
                $root.StartProgramRequest.encode(message.startProgramRequest, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
            if (message.startProgramReply != null && message.hasOwnProperty("startProgramReply"))
                $root.StartProgramReply.encode(message.startProgramReply, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
            if (message.stopCirculatorRequest != null && message.hasOwnProperty("stopCirculatorRequest"))
                $root.StopCirculatorRequest.encode(message.stopCirculatorRequest, writer.uint32(/* id 60, wireType 2 =*/482).fork()).ldelim();
            if (message.stopCirculatorReply != null && message.hasOwnProperty("stopCirculatorReply"))
                $root.StopCirculatorReply.encode(message.stopCirculatorReply, writer.uint32(/* id 61, wireType 2 =*/490).fork()).ldelim();
            if (message.beginLiveFeed != null && message.hasOwnProperty("beginLiveFeed"))
                $root.BeginLiveFeed.encode(message.beginLiveFeed, writer.uint32(/* id 70, wireType 2 =*/562).fork()).ldelim();
            if (message.beginLiveFeedReply != null && message.hasOwnProperty("beginLiveFeedReply"))
                $root.BeginLiveFeedReply.encode(message.beginLiveFeedReply, writer.uint32(/* id 71, wireType 2 =*/570).fork()).ldelim();
            if (message.keepAlive != null && message.hasOwnProperty("keepAlive"))
                $root.KeepAlive.encode(message.keepAlive, writer.uint32(/* id 72, wireType 2 =*/578).fork()).ldelim();
            if (message.retransmitFeedRequest != null && message.hasOwnProperty("retransmitFeedRequest"))
                $root.RetransmitFeedRequest.encode(message.retransmitFeedRequest, writer.uint32(/* id 80, wireType 2 =*/642).fork()).ldelim();
            if (message.retransmitFeedReply != null && message.hasOwnProperty("retransmitFeedReply"))
                $root.RetransmitFeedReply.encode(message.retransmitFeedReply, writer.uint32(/* id 81, wireType 2 =*/650).fork()).ldelim();
            if (message.circulatorDataPoint != null && message.hasOwnProperty("circulatorDataPoint"))
                $root.CirculatorDataPoint.encode(message.circulatorDataPoint, writer.uint32(/* id 90, wireType 2 =*/722).fork()).ldelim();
            if (message.debugMessage != null && message.hasOwnProperty("debugMessage"))
                $root.DebugMessage.encode(message.debugMessage, writer.uint32(/* id 91, wireType 2 =*/730).fork()).ldelim();
            if (message.listRecentEventsRequest != null && message.hasOwnProperty("listRecentEventsRequest"))
                $root.ListRecentEventsRequest.encode(message.listRecentEventsRequest, writer.uint32(/* id 92, wireType 2 =*/738).fork()).ldelim();
            if (message.listRecentEventsReply != null && message.hasOwnProperty("listRecentEventsReply"))
                $root.ListRecentEventsReply.encode(message.listRecentEventsReply, writer.uint32(/* id 93, wireType 2 =*/746).fork()).ldelim();
            if (message.describeFeedRequest != null && message.hasOwnProperty("describeFeedRequest"))
                $root.DescribeFeedRequest.encode(message.describeFeedRequest, writer.uint32(/* id 95, wireType 2 =*/762).fork()).ldelim();
            if (message.describeFeedReply != null && message.hasOwnProperty("describeFeedReply"))
                $root.DescribeFeedReply.encode(message.describeFeedReply, writer.uint32(/* id 96, wireType 2 =*/770).fork()).ldelim();
            if (message.listFeedsRequest != null && message.hasOwnProperty("listFeedsRequest"))
                $root.ListFeedsRequest.encode(message.listFeedsRequest, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
            if (message.listFeedsReply != null && message.hasOwnProperty("listFeedsReply"))
                $root.ListFeedsReply.encode(message.listFeedsReply, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
            if (message.dropFoodRequest != null && message.hasOwnProperty("dropFoodRequest"))
                $root.DropFoodRequest.encode(message.dropFoodRequest, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
            if (message.dropFoodReply != null && message.hasOwnProperty("dropFoodReply"))
                $root.DropFoodReply.encode(message.dropFoodReply, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
            if (message.clearErrorRequest != null && message.hasOwnProperty("clearErrorRequest"))
                $root.ClearErrorRequest.encode(message.clearErrorRequest, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
            if (message.clearErrorReply != null && message.hasOwnProperty("clearErrorReply"))
                $root.ClearErrorReply.encode(message.clearErrorReply, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
            if (message.enterBootModeRequest != null && message.hasOwnProperty("enterBootModeRequest"))
                $root.EnterBootModeRequest.encode(message.enterBootModeRequest, writer.uint32(/* id 110, wireType 2 =*/882).fork()).ldelim();
            if (message.enterBootModeReply != null && message.hasOwnProperty("enterBootModeReply"))
                $root.EnterBootModeReply.encode(message.enterBootModeReply, writer.uint32(/* id 111, wireType 2 =*/890).fork()).ldelim();
            if (message.startFileTransferRequest != null && message.hasOwnProperty("startFileTransferRequest"))
                $root.StartFileTransferRequest.encode(message.startFileTransferRequest, writer.uint32(/* id 112, wireType 2 =*/898).fork()).ldelim();
            if (message.startFileTransferReply != null && message.hasOwnProperty("startFileTransferReply"))
                $root.StartFileTransferReply.encode(message.startFileTransferReply, writer.uint32(/* id 113, wireType 2 =*/906).fork()).ldelim();
            if (message.transferFileBlockRequest != null && message.hasOwnProperty("transferFileBlockRequest"))
                $root.TransferFileBlockRequest.encode(message.transferFileBlockRequest, writer.uint32(/* id 114, wireType 2 =*/914).fork()).ldelim();
            if (message.transferFileBlockReply != null && message.hasOwnProperty("transferFileBlockReply"))
                $root.TransferFileBlockReply.encode(message.transferFileBlockReply, writer.uint32(/* id 115, wireType 2 =*/922).fork()).ldelim();
            if (message.transferFileComplete != null && message.hasOwnProperty("transferFileComplete"))
                $root.TransferFileComplete.encode(message.transferFileComplete, writer.uint32(/* id 116, wireType 2 =*/930).fork()).ldelim();
            if (message.startFileReceiveRequest != null && message.hasOwnProperty("startFileReceiveRequest"))
                $root.StartFileReceiveRequest.encode(message.startFileReceiveRequest, writer.uint32(/* id 117, wireType 2 =*/938).fork()).ldelim();
            if (message.startFileReceiveReply != null && message.hasOwnProperty("startFileReceiveReply"))
                $root.StartFileReceiveReply.encode(message.startFileReceiveReply, writer.uint32(/* id 118, wireType 2 =*/946).fork()).ldelim();
            if (message.startKeyExchangeRequest != null && message.hasOwnProperty("startKeyExchangeRequest"))
                $root.StartKeyExchangeRequest.encode(message.startKeyExchangeRequest, writer.uint32(/* id 120, wireType 2 =*/962).fork()).ldelim();
            if (message.startKeyExchangeReply != null && message.hasOwnProperty("startKeyExchangeReply"))
                $root.StartKeyExchangeReply.encode(message.startKeyExchangeReply, writer.uint32(/* id 121, wireType 2 =*/970).fork()).ldelim();
            if (message.cancelKeyExchangeRequest != null && message.hasOwnProperty("cancelKeyExchangeRequest"))
                $root.CancelKeyExchangeRequest.encode(message.cancelKeyExchangeRequest, writer.uint32(/* id 125, wireType 2 =*/1002).fork()).ldelim();
            if (message.cancelKeyExchangeReply != null && message.hasOwnProperty("cancelKeyExchangeReply"))
                $root.CancelKeyExchangeReply.encode(message.cancelKeyExchangeReply, writer.uint32(/* id 126, wireType 2 =*/1010).fork()).ldelim();
            if (message.submitKeyRequest != null && message.hasOwnProperty("submitKeyRequest"))
                $root.SubmitKeyRequest.encode(message.submitKeyRequest, writer.uint32(/* id 130, wireType 2 =*/1042).fork()).ldelim();
            if (message.submitKeyReply != null && message.hasOwnProperty("submitKeyReply"))
                $root.SubmitKeyReply.encode(message.submitKeyReply, writer.uint32(/* id 131, wireType 2 =*/1050).fork()).ldelim();
            if (message.submitBearerAuthTokenRequest != null && message.hasOwnProperty("submitBearerAuthTokenRequest"))
                $root.SubmitBearerAuthTokenRequest.encode(message.submitBearerAuthTokenRequest, writer.uint32(/* id 132, wireType 2 =*/1058).fork()).ldelim();
            if (message.submitBearerAuthTokenReply != null && message.hasOwnProperty("submitBearerAuthTokenReply"))
                $root.SubmitBearerAuthTokenReply.encode(message.submitBearerAuthTokenReply, writer.uint32(/* id 133, wireType 2 =*/1066).fork()).ldelim();
            if (message.predictionUpdate != null && message.hasOwnProperty("predictionUpdate"))
                $root.PredictionUpdate.encode(message.predictionUpdate, writer.uint32(/* id 140, wireType 2 =*/1122).fork()).ldelim();
            if (message.renameCirculatorRequest != null && message.hasOwnProperty("renameCirculatorRequest"))
                $root.RenameCirculatorRequest.encode(message.renameCirculatorRequest, writer.uint32(/* id 150, wireType 2 =*/1202).fork()).ldelim();
            if (message.renameCirculatorReply != null && message.hasOwnProperty("renameCirculatorReply"))
                $root.RenameCirculatorReply.encode(message.renameCirculatorReply, writer.uint32(/* id 151, wireType 2 =*/1210).fork()).ldelim();
            if (message.identifyCirculatorRequest != null && message.hasOwnProperty("identifyCirculatorRequest"))
                $root.IdentifyCirculatorRequest.encode(message.identifyCirculatorRequest, writer.uint32(/* id 152, wireType 2 =*/1218).fork()).ldelim();
            if (message.identifyCirculatorReply != null && message.hasOwnProperty("identifyCirculatorReply"))
                $root.IdentifyCirculatorReply.encode(message.identifyCirculatorReply, writer.uint32(/* id 153, wireType 2 =*/1226).fork()).ldelim();
            if (message.setMessagingAddressRequest != null && message.hasOwnProperty("setMessagingAddressRequest"))
                $root.SetMessagingAddressRequest.encode(message.setMessagingAddressRequest, writer.uint32(/* id 154, wireType 2 =*/1234).fork()).ldelim();
            if (message.setMessagingAddressReply != null && message.hasOwnProperty("setMessagingAddressReply"))
                $root.SetMessagingAddressReply.encode(message.setMessagingAddressReply, writer.uint32(/* id 155, wireType 2 =*/1242).fork()).ldelim();
            if (message.displayLedRequest != null && message.hasOwnProperty("displayLedRequest"))
                $root.DisplayLedRequest.encode(message.displayLedRequest, writer.uint32(/* id 156, wireType 2 =*/1250).fork()).ldelim();
            if (message.displayLedReply != null && message.hasOwnProperty("displayLedReply"))
                $root.DisplayLedReply.encode(message.displayLedReply, writer.uint32(/* id 157, wireType 2 =*/1258).fork()).ldelim();
            if (message.disconnectWifiRequest != null && message.hasOwnProperty("disconnectWifiRequest"))
                $root.DisconnectWifiRequest.encode(message.disconnectWifiRequest, writer.uint32(/* id 160, wireType 2 =*/1282).fork()).ldelim();
            if (message.disconnectWifiReply != null && message.hasOwnProperty("disconnectWifiReply"))
                $root.DisconnectWifiReply.encode(message.disconnectWifiReply, writer.uint32(/* id 161, wireType 2 =*/1290).fork()).ldelim();
            if (message.wifiDFUStatusRequest != null && message.hasOwnProperty("wifiDFUStatusRequest"))
                $root.WifiDFUStatusRequest.encode(message.wifiDFUStatusRequest, writer.uint32(/* id 170, wireType 2 =*/1362).fork()).ldelim();
            if (message.wifiDFUStatusReply != null && message.hasOwnProperty("wifiDFUStatusReply"))
                $root.WifiDFUStatusReply.encode(message.wifiDFUStatusReply, writer.uint32(/* id 171, wireType 2 =*/1370).fork()).ldelim();
            if (message.wifiDFUSetFirmware != null && message.hasOwnProperty("wifiDFUSetFirmware"))
                $root.WifiDFUSetFirmware.encode(message.wifiDFUSetFirmware, writer.uint32(/* id 172, wireType 2 =*/1378).fork()).ldelim();
            if (message.wifiDFUDownloadTFTPRequest != null && message.hasOwnProperty("wifiDFUDownloadTFTPRequest"))
                $root.WifiDFUDownloadTFTPRequest.encode(message.wifiDFUDownloadTFTPRequest, writer.uint32(/* id 173, wireType 2 =*/1386).fork()).ldelim();
            if (message.wifiDFUDownloadTFTPResponse != null && message.hasOwnProperty("wifiDFUDownloadTFTPResponse"))
                $root.WifiDFUDownloadTFTPResponse.encode(message.wifiDFUDownloadTFTPResponse, writer.uint32(/* id 174, wireType 2 =*/1394).fork()).ldelim();
            if (message.getLimitsRequest != null && message.hasOwnProperty("getLimitsRequest"))
                $root.GetLimitsRequest.encode(message.getLimitsRequest, writer.uint32(/* id 180, wireType 2 =*/1442).fork()).ldelim();
            if (message.getLimitsReply != null && message.hasOwnProperty("getLimitsReply"))
                $root.GetLimitsReply.encode(message.getLimitsReply, writer.uint32(/* id 181, wireType 2 =*/1450).fork()).ldelim();
            if (message.factoryResetRequest != null && message.hasOwnProperty("factoryResetRequest"))
                $root.FactoryResetRequest.encode(message.factoryResetRequest, writer.uint32(/* id 1000, wireType 2 =*/8002).fork()).ldelim();
            if (message.factoryResetReply != null && message.hasOwnProperty("factoryResetReply"))
                $root.FactoryResetReply.encode(message.factoryResetReply, writer.uint32(/* id 1001, wireType 2 =*/8010).fork()).ldelim();
            if (message.deviceRestartRequest != null && message.hasOwnProperty("deviceRestartRequest"))
                $root.DeviceRestartRequest.encode(message.deviceRestartRequest, writer.uint32(/* id 1002, wireType 2 =*/8018).fork()).ldelim();
            if (message.deviceRestartReply != null && message.hasOwnProperty("deviceRestartReply"))
                $root.DeviceRestartReply.encode(message.deviceRestartReply, writer.uint32(/* id 1003, wireType 2 =*/8026).fork()).ldelim();
            if (message.testResetRequest != null && message.hasOwnProperty("testResetRequest"))
                $root.TestResetRequest.encode(message.testResetRequest, writer.uint32(/* id 1004, wireType 2 =*/8034).fork()).ldelim();
            if (message.testResetReply != null && message.hasOwnProperty("testResetReply"))
                $root.TestResetReply.encode(message.testResetReply, writer.uint32(/* id 1005, wireType 2 =*/8042).fork()).ldelim();
            if (message.forgetDevicePairingRequest != null && message.hasOwnProperty("forgetDevicePairingRequest"))
                $root.ForgetDevicePairingRequest.encode(message.forgetDevicePairingRequest, writer.uint32(/* id 1006, wireType 2 =*/8050).fork()).ldelim();
            if (message.forgetDevicePairingReply != null && message.hasOwnProperty("forgetDevicePairingReply"))
                $root.ForgetDevicePairingReply.encode(message.forgetDevicePairingReply, writer.uint32(/* id 1007, wireType 2 =*/8058).fork()).ldelim();
            if (message.setSimulatorRequest != null && message.hasOwnProperty("setSimulatorRequest"))
                $root.SetSimulatorRequest.encode(message.setSimulatorRequest, writer.uint32(/* id 1008, wireType 2 =*/8066).fork()).ldelim();
            if (message.setSimulatorReply != null && message.hasOwnProperty("setSimulatorReply"))
                $root.SetSimulatorReply.encode(message.setSimulatorReply, writer.uint32(/* id 1009, wireType 2 =*/8074).fork()).ldelim();
            if (message.getSimulatorRequest != null && message.hasOwnProperty("getSimulatorRequest"))
                $root.GetSimulatorRequest.encode(message.getSimulatorRequest, writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();
            if (message.getSimulatorReply != null && message.hasOwnProperty("getSimulatorReply"))
                $root.GetSimulatorReply.encode(message.getSimulatorReply, writer.uint32(/* id 1011, wireType 2 =*/8090).fork()).ldelim();
            if (message.setHardwareCoeffsRequest != null && message.hasOwnProperty("setHardwareCoeffsRequest"))
                $root.SetHardwareCoeffsRequest.encode(message.setHardwareCoeffsRequest, writer.uint32(/* id 1020, wireType 2 =*/8162).fork()).ldelim();
            if (message.setHardwareCoeffsReply != null && message.hasOwnProperty("setHardwareCoeffsReply"))
                $root.SetHardwareCoeffsReply.encode(message.setHardwareCoeffsReply, writer.uint32(/* id 1021, wireType 2 =*/8170).fork()).ldelim();
            if (message.getHardwareCoeffsRequest != null && message.hasOwnProperty("getHardwareCoeffsRequest"))
                $root.GetHardwareCoeffsRequest.encode(message.getHardwareCoeffsRequest, writer.uint32(/* id 1022, wireType 2 =*/8178).fork()).ldelim();
            if (message.getHardwareCoeffsReply != null && message.hasOwnProperty("getHardwareCoeffsReply"))
                $root.GetHardwareCoeffsReply.encode(message.getHardwareCoeffsReply, writer.uint32(/* id 1023, wireType 2 =*/8186).fork()).ldelim();
            if (message.getUsageDataRequest != null && message.hasOwnProperty("getUsageDataRequest"))
                $root.GetUsageDataRequest.encode(message.getUsageDataRequest, writer.uint32(/* id 1030, wireType 2 =*/8242).fork()).ldelim();
            if (message.getUsageDataReply != null && message.hasOwnProperty("getUsageDataReply"))
                $root.GetUsageDataReply.encode(message.getUsageDataReply, writer.uint32(/* id 1031, wireType 2 =*/8250).fork()).ldelim();
            if (message.resetUsageDataRequest != null && message.hasOwnProperty("resetUsageDataRequest"))
                $root.ResetUsageDataRequest.encode(message.resetUsageDataRequest, writer.uint32(/* id 1032, wireType 2 =*/8258).fork()).ldelim();
            if (message.resetUsageDataReply != null && message.hasOwnProperty("resetUsageDataReply"))
                $root.ResetUsageDataReply.encode(message.resetUsageDataReply, writer.uint32(/* id 1033, wireType 2 =*/8266).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified StreamMessage message, length delimited. Does not implicitly {@link StreamMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof StreamMessage
         * @static
         * @param {IStreamMessage} message StreamMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a StreamMessage message from the specified reader or buffer.
         * @function decode
         * @memberof StreamMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {StreamMessage} StreamMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StreamMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.handle = reader.fixed32();
                    break;
                case 4:
                    message.end = reader.bool();
                    break;
                case 5:
                    message.senderAddress = reader.bytes();
                    break;
                case 6:
                    message.recipientAddress = reader.bytes();
                    break;
                case 14:
                    message.noop = $root.Noop.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.unhandledMessageReply = $root.UnhandledMessageReply.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.connectionReadyReply = $root.ConnectionReadyReply.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.recipientUnavailableReply = $root.RecipientUnavailableReply.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.ping = $root.Ping.decode(reader, reader.uint32());
                    break;
                case 19:
                    message.pong = $root.Pong.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.listStreamsRequest = $root.ListStreamsRequest.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.listStreamsReply = $root.ListStreamsReply.decode(reader, reader.uint32());
                    break;
                case 30:
                    message.listOperationsRequest = $root.ListOperationsRequest.decode(reader, reader.uint32());
                    break;
                case 31:
                    message.listOperationsReply = $root.ListOperationsReply.decode(reader, reader.uint32());
                    break;
                case 50:
                    message.startProgramRequest = $root.StartProgramRequest.decode(reader, reader.uint32());
                    break;
                case 51:
                    message.startProgramReply = $root.StartProgramReply.decode(reader, reader.uint32());
                    break;
                case 60:
                    message.stopCirculatorRequest = $root.StopCirculatorRequest.decode(reader, reader.uint32());
                    break;
                case 61:
                    message.stopCirculatorReply = $root.StopCirculatorReply.decode(reader, reader.uint32());
                    break;
                case 102:
                    message.dropFoodRequest = $root.DropFoodRequest.decode(reader, reader.uint32());
                    break;
                case 103:
                    message.dropFoodReply = $root.DropFoodReply.decode(reader, reader.uint32());
                    break;
                case 70:
                    message.beginLiveFeed = $root.BeginLiveFeed.decode(reader, reader.uint32());
                    break;
                case 71:
                    message.beginLiveFeedReply = $root.BeginLiveFeedReply.decode(reader, reader.uint32());
                    break;
                case 72:
                    message.keepAlive = $root.KeepAlive.decode(reader, reader.uint32());
                    break;
                case 80:
                    message.retransmitFeedRequest = $root.RetransmitFeedRequest.decode(reader, reader.uint32());
                    break;
                case 81:
                    message.retransmitFeedReply = $root.RetransmitFeedReply.decode(reader, reader.uint32());
                    break;
                case 90:
                    message.circulatorDataPoint = $root.CirculatorDataPoint.decode(reader, reader.uint32());
                    break;
                case 91:
                    message.debugMessage = $root.DebugMessage.decode(reader, reader.uint32());
                    break;
                case 92:
                    message.listRecentEventsRequest = $root.ListRecentEventsRequest.decode(reader, reader.uint32());
                    break;
                case 93:
                    message.listRecentEventsReply = $root.ListRecentEventsReply.decode(reader, reader.uint32());
                    break;
                case 95:
                    message.describeFeedRequest = $root.DescribeFeedRequest.decode(reader, reader.uint32());
                    break;
                case 96:
                    message.describeFeedReply = $root.DescribeFeedReply.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.listFeedsRequest = $root.ListFeedsRequest.decode(reader, reader.uint32());
                    break;
                case 101:
                    message.listFeedsReply = $root.ListFeedsReply.decode(reader, reader.uint32());
                    break;
                case 104:
                    message.clearErrorRequest = $root.ClearErrorRequest.decode(reader, reader.uint32());
                    break;
                case 105:
                    message.clearErrorReply = $root.ClearErrorReply.decode(reader, reader.uint32());
                    break;
                case 41:
                    message.listWifiRequest = $root.ListWifiRequest.decode(reader, reader.uint32());
                    break;
                case 42:
                    message.listWifiReply = $root.ListWifiReply.decode(reader, reader.uint32());
                    break;
                case 43:
                    message.connectWifiRequest = $root.ConnectWifiRequest.decode(reader, reader.uint32());
                    break;
                case 44:
                    message.connectWifiReply = $root.ConnectWifiReply.decode(reader, reader.uint32());
                    break;
                case 45:
                    message.listWifiProfileRequest = $root.ListWifiProfileRequest.decode(reader, reader.uint32());
                    break;
                case 47:
                    message.listWifiProfileReply = $root.ListWifiProfileReply.decode(reader, reader.uint32());
                    break;
                case 48:
                    message.forgetWifiProfileRequest = $root.ForgetWifiProfileRequest.decode(reader, reader.uint32());
                    break;
                case 49:
                    message.forgetWifiProfileReply = $root.ForgetWifiProfileReply.decode(reader, reader.uint32());
                    break;
                case 160:
                    message.disconnectWifiRequest = $root.DisconnectWifiRequest.decode(reader, reader.uint32());
                    break;
                case 161:
                    message.disconnectWifiReply = $root.DisconnectWifiReply.decode(reader, reader.uint32());
                    break;
                case 110:
                    message.enterBootModeRequest = $root.EnterBootModeRequest.decode(reader, reader.uint32());
                    break;
                case 111:
                    message.enterBootModeReply = $root.EnterBootModeReply.decode(reader, reader.uint32());
                    break;
                case 112:
                    message.startFileTransferRequest = $root.StartFileTransferRequest.decode(reader, reader.uint32());
                    break;
                case 113:
                    message.startFileTransferReply = $root.StartFileTransferReply.decode(reader, reader.uint32());
                    break;
                case 114:
                    message.transferFileBlockRequest = $root.TransferFileBlockRequest.decode(reader, reader.uint32());
                    break;
                case 115:
                    message.transferFileBlockReply = $root.TransferFileBlockReply.decode(reader, reader.uint32());
                    break;
                case 116:
                    message.transferFileComplete = $root.TransferFileComplete.decode(reader, reader.uint32());
                    break;
                case 117:
                    message.startFileReceiveRequest = $root.StartFileReceiveRequest.decode(reader, reader.uint32());
                    break;
                case 118:
                    message.startFileReceiveReply = $root.StartFileReceiveReply.decode(reader, reader.uint32());
                    break;
                case 120:
                    message.startKeyExchangeRequest = $root.StartKeyExchangeRequest.decode(reader, reader.uint32());
                    break;
                case 121:
                    message.startKeyExchangeReply = $root.StartKeyExchangeReply.decode(reader, reader.uint32());
                    break;
                case 125:
                    message.cancelKeyExchangeRequest = $root.CancelKeyExchangeRequest.decode(reader, reader.uint32());
                    break;
                case 126:
                    message.cancelKeyExchangeReply = $root.CancelKeyExchangeReply.decode(reader, reader.uint32());
                    break;
                case 130:
                    message.submitKeyRequest = $root.SubmitKeyRequest.decode(reader, reader.uint32());
                    break;
                case 131:
                    message.submitKeyReply = $root.SubmitKeyReply.decode(reader, reader.uint32());
                    break;
                case 132:
                    message.submitBearerAuthTokenRequest = $root.SubmitBearerAuthTokenRequest.decode(reader, reader.uint32());
                    break;
                case 133:
                    message.submitBearerAuthTokenReply = $root.SubmitBearerAuthTokenReply.decode(reader, reader.uint32());
                    break;
                case 140:
                    message.predictionUpdate = $root.PredictionUpdate.decode(reader, reader.uint32());
                    break;
                case 150:
                    message.renameCirculatorRequest = $root.RenameCirculatorRequest.decode(reader, reader.uint32());
                    break;
                case 151:
                    message.renameCirculatorReply = $root.RenameCirculatorReply.decode(reader, reader.uint32());
                    break;
                case 152:
                    message.identifyCirculatorRequest = $root.IdentifyCirculatorRequest.decode(reader, reader.uint32());
                    break;
                case 153:
                    message.identifyCirculatorReply = $root.IdentifyCirculatorReply.decode(reader, reader.uint32());
                    break;
                case 154:
                    message.setMessagingAddressRequest = $root.SetMessagingAddressRequest.decode(reader, reader.uint32());
                    break;
                case 155:
                    message.setMessagingAddressReply = $root.SetMessagingAddressReply.decode(reader, reader.uint32());
                    break;
                case 156:
                    message.displayLedRequest = $root.DisplayLedRequest.decode(reader, reader.uint32());
                    break;
                case 157:
                    message.displayLedReply = $root.DisplayLedReply.decode(reader, reader.uint32());
                    break;
                case 170:
                    message.wifiDFUStatusRequest = $root.WifiDFUStatusRequest.decode(reader, reader.uint32());
                    break;
                case 171:
                    message.wifiDFUStatusReply = $root.WifiDFUStatusReply.decode(reader, reader.uint32());
                    break;
                case 172:
                    message.wifiDFUSetFirmware = $root.WifiDFUSetFirmware.decode(reader, reader.uint32());
                    break;
                case 173:
                    message.wifiDFUDownloadTFTPRequest = $root.WifiDFUDownloadTFTPRequest.decode(reader, reader.uint32());
                    break;
                case 174:
                    message.wifiDFUDownloadTFTPResponse = $root.WifiDFUDownloadTFTPResponse.decode(reader, reader.uint32());
                    break;
                case 180:
                    message.getLimitsRequest = $root.GetLimitsRequest.decode(reader, reader.uint32());
                    break;
                case 181:
                    message.getLimitsReply = $root.GetLimitsReply.decode(reader, reader.uint32());
                    break;
                case 1000:
                    message.factoryResetRequest = $root.FactoryResetRequest.decode(reader, reader.uint32());
                    break;
                case 1001:
                    message.factoryResetReply = $root.FactoryResetReply.decode(reader, reader.uint32());
                    break;
                case 1002:
                    message.deviceRestartRequest = $root.DeviceRestartRequest.decode(reader, reader.uint32());
                    break;
                case 1003:
                    message.deviceRestartReply = $root.DeviceRestartReply.decode(reader, reader.uint32());
                    break;
                case 1004:
                    message.testResetRequest = $root.TestResetRequest.decode(reader, reader.uint32());
                    break;
                case 1005:
                    message.testResetReply = $root.TestResetReply.decode(reader, reader.uint32());
                    break;
                case 1006:
                    message.forgetDevicePairingRequest = $root.ForgetDevicePairingRequest.decode(reader, reader.uint32());
                    break;
                case 1007:
                    message.forgetDevicePairingReply = $root.ForgetDevicePairingReply.decode(reader, reader.uint32());
                    break;
                case 1008:
                    message.setSimulatorRequest = $root.SetSimulatorRequest.decode(reader, reader.uint32());
                    break;
                case 1009:
                    message.setSimulatorReply = $root.SetSimulatorReply.decode(reader, reader.uint32());
                    break;
                case 1010:
                    message.getSimulatorRequest = $root.GetSimulatorRequest.decode(reader, reader.uint32());
                    break;
                case 1011:
                    message.getSimulatorReply = $root.GetSimulatorReply.decode(reader, reader.uint32());
                    break;
                case 1020:
                    message.setHardwareCoeffsRequest = $root.SetHardwareCoeffsRequest.decode(reader, reader.uint32());
                    break;
                case 1021:
                    message.setHardwareCoeffsReply = $root.SetHardwareCoeffsReply.decode(reader, reader.uint32());
                    break;
                case 1022:
                    message.getHardwareCoeffsRequest = $root.GetHardwareCoeffsRequest.decode(reader, reader.uint32());
                    break;
                case 1023:
                    message.getHardwareCoeffsReply = $root.GetHardwareCoeffsReply.decode(reader, reader.uint32());
                    break;
                case 1030:
                    message.getUsageDataRequest = $root.GetUsageDataRequest.decode(reader, reader.uint32());
                    break;
                case 1031:
                    message.getUsageDataReply = $root.GetUsageDataReply.decode(reader, reader.uint32());
                    break;
                case 1032:
                    message.resetUsageDataRequest = $root.ResetUsageDataRequest.decode(reader, reader.uint32());
                    break;
                case 1033:
                    message.resetUsageDataReply = $root.ResetUsageDataReply.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("handle"))
                throw $util.ProtocolError("missing required 'handle'", { instance: message });
            if (!message.hasOwnProperty("senderAddress"))
                throw $util.ProtocolError("missing required 'senderAddress'", { instance: message });
            if (!message.hasOwnProperty("recipientAddress"))
                throw $util.ProtocolError("missing required 'recipientAddress'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a StreamMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof StreamMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {StreamMessage} StreamMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a StreamMessage message.
         * @function verify
         * @memberof StreamMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (!$util.isInteger(message.handle))
                return "handle: integer expected";
            if (message.end != null && message.hasOwnProperty("end"))
                if (typeof message.end !== "boolean")
                    return "end: boolean expected";
            if (!(message.senderAddress && typeof message.senderAddress.length === "number" || $util.isString(message.senderAddress)))
                return "senderAddress: buffer expected";
            if (!(message.recipientAddress && typeof message.recipientAddress.length === "number" || $util.isString(message.recipientAddress)))
                return "recipientAddress: buffer expected";
            if (message.noop != null && message.hasOwnProperty("noop")) {
                properties.contents = 1;
                var error = $root.Noop.verify(message.noop);
                if (error)
                    return "noop." + error;
            }
            if (message.unhandledMessageReply != null && message.hasOwnProperty("unhandledMessageReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.UnhandledMessageReply.verify(message.unhandledMessageReply);
                if (error)
                    return "unhandledMessageReply." + error;
            }
            if (message.connectionReadyReply != null && message.hasOwnProperty("connectionReadyReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ConnectionReadyReply.verify(message.connectionReadyReply);
                if (error)
                    return "connectionReadyReply." + error;
            }
            if (message.recipientUnavailableReply != null && message.hasOwnProperty("recipientUnavailableReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.RecipientUnavailableReply.verify(message.recipientUnavailableReply);
                if (error)
                    return "recipientUnavailableReply." + error;
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.Ping.verify(message.ping);
                if (error)
                    return "ping." + error;
            }
            if (message.pong != null && message.hasOwnProperty("pong")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.Pong.verify(message.pong);
                if (error)
                    return "pong." + error;
            }
            if (message.listStreamsRequest != null && message.hasOwnProperty("listStreamsRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ListStreamsRequest.verify(message.listStreamsRequest);
                if (error)
                    return "listStreamsRequest." + error;
            }
            if (message.listStreamsReply != null && message.hasOwnProperty("listStreamsReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ListStreamsReply.verify(message.listStreamsReply);
                if (error)
                    return "listStreamsReply." + error;
            }
            if (message.listOperationsRequest != null && message.hasOwnProperty("listOperationsRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ListOperationsRequest.verify(message.listOperationsRequest);
                if (error)
                    return "listOperationsRequest." + error;
            }
            if (message.listOperationsReply != null && message.hasOwnProperty("listOperationsReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ListOperationsReply.verify(message.listOperationsReply);
                if (error)
                    return "listOperationsReply." + error;
            }
            if (message.startProgramRequest != null && message.hasOwnProperty("startProgramRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.StartProgramRequest.verify(message.startProgramRequest);
                if (error)
                    return "startProgramRequest." + error;
            }
            if (message.startProgramReply != null && message.hasOwnProperty("startProgramReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.StartProgramReply.verify(message.startProgramReply);
                if (error)
                    return "startProgramReply." + error;
            }
            if (message.stopCirculatorRequest != null && message.hasOwnProperty("stopCirculatorRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.StopCirculatorRequest.verify(message.stopCirculatorRequest);
                if (error)
                    return "stopCirculatorRequest." + error;
            }
            if (message.stopCirculatorReply != null && message.hasOwnProperty("stopCirculatorReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.StopCirculatorReply.verify(message.stopCirculatorReply);
                if (error)
                    return "stopCirculatorReply." + error;
            }
            if (message.dropFoodRequest != null && message.hasOwnProperty("dropFoodRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.DropFoodRequest.verify(message.dropFoodRequest);
                if (error)
                    return "dropFoodRequest." + error;
            }
            if (message.dropFoodReply != null && message.hasOwnProperty("dropFoodReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.DropFoodReply.verify(message.dropFoodReply);
                if (error)
                    return "dropFoodReply." + error;
            }
            if (message.beginLiveFeed != null && message.hasOwnProperty("beginLiveFeed")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.BeginLiveFeed.verify(message.beginLiveFeed);
                if (error)
                    return "beginLiveFeed." + error;
            }
            if (message.beginLiveFeedReply != null && message.hasOwnProperty("beginLiveFeedReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.BeginLiveFeedReply.verify(message.beginLiveFeedReply);
                if (error)
                    return "beginLiveFeedReply." + error;
            }
            if (message.keepAlive != null && message.hasOwnProperty("keepAlive")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.KeepAlive.verify(message.keepAlive);
                if (error)
                    return "keepAlive." + error;
            }
            if (message.retransmitFeedRequest != null && message.hasOwnProperty("retransmitFeedRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.RetransmitFeedRequest.verify(message.retransmitFeedRequest);
                if (error)
                    return "retransmitFeedRequest." + error;
            }
            if (message.retransmitFeedReply != null && message.hasOwnProperty("retransmitFeedReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.RetransmitFeedReply.verify(message.retransmitFeedReply);
                if (error)
                    return "retransmitFeedReply." + error;
            }
            if (message.circulatorDataPoint != null && message.hasOwnProperty("circulatorDataPoint")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.CirculatorDataPoint.verify(message.circulatorDataPoint);
                if (error)
                    return "circulatorDataPoint." + error;
            }
            if (message.debugMessage != null && message.hasOwnProperty("debugMessage")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.DebugMessage.verify(message.debugMessage);
                if (error)
                    return "debugMessage." + error;
            }
            if (message.listRecentEventsRequest != null && message.hasOwnProperty("listRecentEventsRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ListRecentEventsRequest.verify(message.listRecentEventsRequest);
                if (error)
                    return "listRecentEventsRequest." + error;
            }
            if (message.listRecentEventsReply != null && message.hasOwnProperty("listRecentEventsReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ListRecentEventsReply.verify(message.listRecentEventsReply);
                if (error)
                    return "listRecentEventsReply." + error;
            }
            if (message.describeFeedRequest != null && message.hasOwnProperty("describeFeedRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.DescribeFeedRequest.verify(message.describeFeedRequest);
                if (error)
                    return "describeFeedRequest." + error;
            }
            if (message.describeFeedReply != null && message.hasOwnProperty("describeFeedReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.DescribeFeedReply.verify(message.describeFeedReply);
                if (error)
                    return "describeFeedReply." + error;
            }
            if (message.listFeedsRequest != null && message.hasOwnProperty("listFeedsRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ListFeedsRequest.verify(message.listFeedsRequest);
                if (error)
                    return "listFeedsRequest." + error;
            }
            if (message.listFeedsReply != null && message.hasOwnProperty("listFeedsReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ListFeedsReply.verify(message.listFeedsReply);
                if (error)
                    return "listFeedsReply." + error;
            }
            if (message.clearErrorRequest != null && message.hasOwnProperty("clearErrorRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ClearErrorRequest.verify(message.clearErrorRequest);
                if (error)
                    return "clearErrorRequest." + error;
            }
            if (message.clearErrorReply != null && message.hasOwnProperty("clearErrorReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ClearErrorReply.verify(message.clearErrorReply);
                if (error)
                    return "clearErrorReply." + error;
            }
            if (message.listWifiRequest != null && message.hasOwnProperty("listWifiRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ListWifiRequest.verify(message.listWifiRequest);
                if (error)
                    return "listWifiRequest." + error;
            }
            if (message.listWifiReply != null && message.hasOwnProperty("listWifiReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ListWifiReply.verify(message.listWifiReply);
                if (error)
                    return "listWifiReply." + error;
            }
            if (message.connectWifiRequest != null && message.hasOwnProperty("connectWifiRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ConnectWifiRequest.verify(message.connectWifiRequest);
                if (error)
                    return "connectWifiRequest." + error;
            }
            if (message.connectWifiReply != null && message.hasOwnProperty("connectWifiReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ConnectWifiReply.verify(message.connectWifiReply);
                if (error)
                    return "connectWifiReply." + error;
            }
            if (message.listWifiProfileRequest != null && message.hasOwnProperty("listWifiProfileRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ListWifiProfileRequest.verify(message.listWifiProfileRequest);
                if (error)
                    return "listWifiProfileRequest." + error;
            }
            if (message.listWifiProfileReply != null && message.hasOwnProperty("listWifiProfileReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ListWifiProfileReply.verify(message.listWifiProfileReply);
                if (error)
                    return "listWifiProfileReply." + error;
            }
            if (message.forgetWifiProfileRequest != null && message.hasOwnProperty("forgetWifiProfileRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ForgetWifiProfileRequest.verify(message.forgetWifiProfileRequest);
                if (error)
                    return "forgetWifiProfileRequest." + error;
            }
            if (message.forgetWifiProfileReply != null && message.hasOwnProperty("forgetWifiProfileReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ForgetWifiProfileReply.verify(message.forgetWifiProfileReply);
                if (error)
                    return "forgetWifiProfileReply." + error;
            }
            if (message.disconnectWifiRequest != null && message.hasOwnProperty("disconnectWifiRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.DisconnectWifiRequest.verify(message.disconnectWifiRequest);
                if (error)
                    return "disconnectWifiRequest." + error;
            }
            if (message.disconnectWifiReply != null && message.hasOwnProperty("disconnectWifiReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.DisconnectWifiReply.verify(message.disconnectWifiReply);
                if (error)
                    return "disconnectWifiReply." + error;
            }
            if (message.enterBootModeRequest != null && message.hasOwnProperty("enterBootModeRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.EnterBootModeRequest.verify(message.enterBootModeRequest);
                if (error)
                    return "enterBootModeRequest." + error;
            }
            if (message.enterBootModeReply != null && message.hasOwnProperty("enterBootModeReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.EnterBootModeReply.verify(message.enterBootModeReply);
                if (error)
                    return "enterBootModeReply." + error;
            }
            if (message.startFileTransferRequest != null && message.hasOwnProperty("startFileTransferRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.StartFileTransferRequest.verify(message.startFileTransferRequest);
                if (error)
                    return "startFileTransferRequest." + error;
            }
            if (message.startFileTransferReply != null && message.hasOwnProperty("startFileTransferReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.StartFileTransferReply.verify(message.startFileTransferReply);
                if (error)
                    return "startFileTransferReply." + error;
            }
            if (message.transferFileBlockRequest != null && message.hasOwnProperty("transferFileBlockRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.TransferFileBlockRequest.verify(message.transferFileBlockRequest);
                if (error)
                    return "transferFileBlockRequest." + error;
            }
            if (message.transferFileBlockReply != null && message.hasOwnProperty("transferFileBlockReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.TransferFileBlockReply.verify(message.transferFileBlockReply);
                if (error)
                    return "transferFileBlockReply." + error;
            }
            if (message.transferFileComplete != null && message.hasOwnProperty("transferFileComplete")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.TransferFileComplete.verify(message.transferFileComplete);
                if (error)
                    return "transferFileComplete." + error;
            }
            if (message.startFileReceiveRequest != null && message.hasOwnProperty("startFileReceiveRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.StartFileReceiveRequest.verify(message.startFileReceiveRequest);
                if (error)
                    return "startFileReceiveRequest." + error;
            }
            if (message.startFileReceiveReply != null && message.hasOwnProperty("startFileReceiveReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.StartFileReceiveReply.verify(message.startFileReceiveReply);
                if (error)
                    return "startFileReceiveReply." + error;
            }
            if (message.startKeyExchangeRequest != null && message.hasOwnProperty("startKeyExchangeRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.StartKeyExchangeRequest.verify(message.startKeyExchangeRequest);
                if (error)
                    return "startKeyExchangeRequest." + error;
            }
            if (message.startKeyExchangeReply != null && message.hasOwnProperty("startKeyExchangeReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.StartKeyExchangeReply.verify(message.startKeyExchangeReply);
                if (error)
                    return "startKeyExchangeReply." + error;
            }
            if (message.cancelKeyExchangeRequest != null && message.hasOwnProperty("cancelKeyExchangeRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.CancelKeyExchangeRequest.verify(message.cancelKeyExchangeRequest);
                if (error)
                    return "cancelKeyExchangeRequest." + error;
            }
            if (message.cancelKeyExchangeReply != null && message.hasOwnProperty("cancelKeyExchangeReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.CancelKeyExchangeReply.verify(message.cancelKeyExchangeReply);
                if (error)
                    return "cancelKeyExchangeReply." + error;
            }
            if (message.submitKeyRequest != null && message.hasOwnProperty("submitKeyRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.SubmitKeyRequest.verify(message.submitKeyRequest);
                if (error)
                    return "submitKeyRequest." + error;
            }
            if (message.submitKeyReply != null && message.hasOwnProperty("submitKeyReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.SubmitKeyReply.verify(message.submitKeyReply);
                if (error)
                    return "submitKeyReply." + error;
            }
            if (message.submitBearerAuthTokenRequest != null && message.hasOwnProperty("submitBearerAuthTokenRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.SubmitBearerAuthTokenRequest.verify(message.submitBearerAuthTokenRequest);
                if (error)
                    return "submitBearerAuthTokenRequest." + error;
            }
            if (message.submitBearerAuthTokenReply != null && message.hasOwnProperty("submitBearerAuthTokenReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.SubmitBearerAuthTokenReply.verify(message.submitBearerAuthTokenReply);
                if (error)
                    return "submitBearerAuthTokenReply." + error;
            }
            if (message.predictionUpdate != null && message.hasOwnProperty("predictionUpdate")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.PredictionUpdate.verify(message.predictionUpdate);
                if (error)
                    return "predictionUpdate." + error;
            }
            if (message.renameCirculatorRequest != null && message.hasOwnProperty("renameCirculatorRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.RenameCirculatorRequest.verify(message.renameCirculatorRequest);
                if (error)
                    return "renameCirculatorRequest." + error;
            }
            if (message.renameCirculatorReply != null && message.hasOwnProperty("renameCirculatorReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.RenameCirculatorReply.verify(message.renameCirculatorReply);
                if (error)
                    return "renameCirculatorReply." + error;
            }
            if (message.identifyCirculatorRequest != null && message.hasOwnProperty("identifyCirculatorRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.IdentifyCirculatorRequest.verify(message.identifyCirculatorRequest);
                if (error)
                    return "identifyCirculatorRequest." + error;
            }
            if (message.identifyCirculatorReply != null && message.hasOwnProperty("identifyCirculatorReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.IdentifyCirculatorReply.verify(message.identifyCirculatorReply);
                if (error)
                    return "identifyCirculatorReply." + error;
            }
            if (message.setMessagingAddressRequest != null && message.hasOwnProperty("setMessagingAddressRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.SetMessagingAddressRequest.verify(message.setMessagingAddressRequest);
                if (error)
                    return "setMessagingAddressRequest." + error;
            }
            if (message.setMessagingAddressReply != null && message.hasOwnProperty("setMessagingAddressReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.SetMessagingAddressReply.verify(message.setMessagingAddressReply);
                if (error)
                    return "setMessagingAddressReply." + error;
            }
            if (message.displayLedRequest != null && message.hasOwnProperty("displayLedRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.DisplayLedRequest.verify(message.displayLedRequest);
                if (error)
                    return "displayLedRequest." + error;
            }
            if (message.displayLedReply != null && message.hasOwnProperty("displayLedReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.DisplayLedReply.verify(message.displayLedReply);
                if (error)
                    return "displayLedReply." + error;
            }
            if (message.wifiDFUStatusRequest != null && message.hasOwnProperty("wifiDFUStatusRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.WifiDFUStatusRequest.verify(message.wifiDFUStatusRequest);
                if (error)
                    return "wifiDFUStatusRequest." + error;
            }
            if (message.wifiDFUStatusReply != null && message.hasOwnProperty("wifiDFUStatusReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.WifiDFUStatusReply.verify(message.wifiDFUStatusReply);
                if (error)
                    return "wifiDFUStatusReply." + error;
            }
            if (message.wifiDFUSetFirmware != null && message.hasOwnProperty("wifiDFUSetFirmware")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.WifiDFUSetFirmware.verify(message.wifiDFUSetFirmware);
                if (error)
                    return "wifiDFUSetFirmware." + error;
            }
            if (message.wifiDFUDownloadTFTPRequest != null && message.hasOwnProperty("wifiDFUDownloadTFTPRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.WifiDFUDownloadTFTPRequest.verify(message.wifiDFUDownloadTFTPRequest);
                if (error)
                    return "wifiDFUDownloadTFTPRequest." + error;
            }
            if (message.wifiDFUDownloadTFTPResponse != null && message.hasOwnProperty("wifiDFUDownloadTFTPResponse")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.WifiDFUDownloadTFTPResponse.verify(message.wifiDFUDownloadTFTPResponse);
                if (error)
                    return "wifiDFUDownloadTFTPResponse." + error;
            }
            if (message.getLimitsRequest != null && message.hasOwnProperty("getLimitsRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.GetLimitsRequest.verify(message.getLimitsRequest);
                if (error)
                    return "getLimitsRequest." + error;
            }
            if (message.getLimitsReply != null && message.hasOwnProperty("getLimitsReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.GetLimitsReply.verify(message.getLimitsReply);
                if (error)
                    return "getLimitsReply." + error;
            }
            if (message.factoryResetRequest != null && message.hasOwnProperty("factoryResetRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.FactoryResetRequest.verify(message.factoryResetRequest);
                if (error)
                    return "factoryResetRequest." + error;
            }
            if (message.factoryResetReply != null && message.hasOwnProperty("factoryResetReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.FactoryResetReply.verify(message.factoryResetReply);
                if (error)
                    return "factoryResetReply." + error;
            }
            if (message.deviceRestartRequest != null && message.hasOwnProperty("deviceRestartRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.DeviceRestartRequest.verify(message.deviceRestartRequest);
                if (error)
                    return "deviceRestartRequest." + error;
            }
            if (message.deviceRestartReply != null && message.hasOwnProperty("deviceRestartReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.DeviceRestartReply.verify(message.deviceRestartReply);
                if (error)
                    return "deviceRestartReply." + error;
            }
            if (message.testResetRequest != null && message.hasOwnProperty("testResetRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.TestResetRequest.verify(message.testResetRequest);
                if (error)
                    return "testResetRequest." + error;
            }
            if (message.testResetReply != null && message.hasOwnProperty("testResetReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.TestResetReply.verify(message.testResetReply);
                if (error)
                    return "testResetReply." + error;
            }
            if (message.forgetDevicePairingRequest != null && message.hasOwnProperty("forgetDevicePairingRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ForgetDevicePairingRequest.verify(message.forgetDevicePairingRequest);
                if (error)
                    return "forgetDevicePairingRequest." + error;
            }
            if (message.forgetDevicePairingReply != null && message.hasOwnProperty("forgetDevicePairingReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ForgetDevicePairingReply.verify(message.forgetDevicePairingReply);
                if (error)
                    return "forgetDevicePairingReply." + error;
            }
            if (message.setSimulatorRequest != null && message.hasOwnProperty("setSimulatorRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.SetSimulatorRequest.verify(message.setSimulatorRequest);
                if (error)
                    return "setSimulatorRequest." + error;
            }
            if (message.setSimulatorReply != null && message.hasOwnProperty("setSimulatorReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.SetSimulatorReply.verify(message.setSimulatorReply);
                if (error)
                    return "setSimulatorReply." + error;
            }
            if (message.getSimulatorRequest != null && message.hasOwnProperty("getSimulatorRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.GetSimulatorRequest.verify(message.getSimulatorRequest);
                if (error)
                    return "getSimulatorRequest." + error;
            }
            if (message.getSimulatorReply != null && message.hasOwnProperty("getSimulatorReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.GetSimulatorReply.verify(message.getSimulatorReply);
                if (error)
                    return "getSimulatorReply." + error;
            }
            if (message.setHardwareCoeffsRequest != null && message.hasOwnProperty("setHardwareCoeffsRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.SetHardwareCoeffsRequest.verify(message.setHardwareCoeffsRequest);
                if (error)
                    return "setHardwareCoeffsRequest." + error;
            }
            if (message.setHardwareCoeffsReply != null && message.hasOwnProperty("setHardwareCoeffsReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.SetHardwareCoeffsReply.verify(message.setHardwareCoeffsReply);
                if (error)
                    return "setHardwareCoeffsReply." + error;
            }
            if (message.getHardwareCoeffsRequest != null && message.hasOwnProperty("getHardwareCoeffsRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.GetHardwareCoeffsRequest.verify(message.getHardwareCoeffsRequest);
                if (error)
                    return "getHardwareCoeffsRequest." + error;
            }
            if (message.getHardwareCoeffsReply != null && message.hasOwnProperty("getHardwareCoeffsReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.GetHardwareCoeffsReply.verify(message.getHardwareCoeffsReply);
                if (error)
                    return "getHardwareCoeffsReply." + error;
            }
            if (message.getUsageDataRequest != null && message.hasOwnProperty("getUsageDataRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.GetUsageDataRequest.verify(message.getUsageDataRequest);
                if (error)
                    return "getUsageDataRequest." + error;
            }
            if (message.getUsageDataReply != null && message.hasOwnProperty("getUsageDataReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.GetUsageDataReply.verify(message.getUsageDataReply);
                if (error)
                    return "getUsageDataReply." + error;
            }
            if (message.resetUsageDataRequest != null && message.hasOwnProperty("resetUsageDataRequest")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ResetUsageDataRequest.verify(message.resetUsageDataRequest);
                if (error)
                    return "resetUsageDataRequest." + error;
            }
            if (message.resetUsageDataReply != null && message.hasOwnProperty("resetUsageDataReply")) {
                if (properties.contents === 1)
                    return "contents: multiple values";
                properties.contents = 1;
                error = $root.ResetUsageDataReply.verify(message.resetUsageDataReply);
                if (error)
                    return "resetUsageDataReply." + error;
            }
            return null;
        };
    
        /**
         * Creates a StreamMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof StreamMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {StreamMessage} StreamMessage
         */
        StreamMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.StreamMessage)
                return object;
            var message = new $root.StreamMessage();
            if (object.handle != null)
                message.handle = object.handle >>> 0;
            if (object.end != null)
                message.end = Boolean(object.end);
            if (object.senderAddress != null)
                if (typeof object.senderAddress === "string")
                    $util.base64.decode(object.senderAddress, message.senderAddress = $util.newBuffer($util.base64.length(object.senderAddress)), 0);
                else if (object.senderAddress.length)
                    message.senderAddress = object.senderAddress;
            if (object.recipientAddress != null)
                if (typeof object.recipientAddress === "string")
                    $util.base64.decode(object.recipientAddress, message.recipientAddress = $util.newBuffer($util.base64.length(object.recipientAddress)), 0);
                else if (object.recipientAddress.length)
                    message.recipientAddress = object.recipientAddress;
            if (object.noop != null) {
                if (typeof object.noop !== "object")
                    throw TypeError(".StreamMessage.noop: object expected");
                message.noop = $root.Noop.fromObject(object.noop);
            }
            if (object.unhandledMessageReply != null) {
                if (typeof object.unhandledMessageReply !== "object")
                    throw TypeError(".StreamMessage.unhandledMessageReply: object expected");
                message.unhandledMessageReply = $root.UnhandledMessageReply.fromObject(object.unhandledMessageReply);
            }
            if (object.connectionReadyReply != null) {
                if (typeof object.connectionReadyReply !== "object")
                    throw TypeError(".StreamMessage.connectionReadyReply: object expected");
                message.connectionReadyReply = $root.ConnectionReadyReply.fromObject(object.connectionReadyReply);
            }
            if (object.recipientUnavailableReply != null) {
                if (typeof object.recipientUnavailableReply !== "object")
                    throw TypeError(".StreamMessage.recipientUnavailableReply: object expected");
                message.recipientUnavailableReply = $root.RecipientUnavailableReply.fromObject(object.recipientUnavailableReply);
            }
            if (object.ping != null) {
                if (typeof object.ping !== "object")
                    throw TypeError(".StreamMessage.ping: object expected");
                message.ping = $root.Ping.fromObject(object.ping);
            }
            if (object.pong != null) {
                if (typeof object.pong !== "object")
                    throw TypeError(".StreamMessage.pong: object expected");
                message.pong = $root.Pong.fromObject(object.pong);
            }
            if (object.listStreamsRequest != null) {
                if (typeof object.listStreamsRequest !== "object")
                    throw TypeError(".StreamMessage.listStreamsRequest: object expected");
                message.listStreamsRequest = $root.ListStreamsRequest.fromObject(object.listStreamsRequest);
            }
            if (object.listStreamsReply != null) {
                if (typeof object.listStreamsReply !== "object")
                    throw TypeError(".StreamMessage.listStreamsReply: object expected");
                message.listStreamsReply = $root.ListStreamsReply.fromObject(object.listStreamsReply);
            }
            if (object.listOperationsRequest != null) {
                if (typeof object.listOperationsRequest !== "object")
                    throw TypeError(".StreamMessage.listOperationsRequest: object expected");
                message.listOperationsRequest = $root.ListOperationsRequest.fromObject(object.listOperationsRequest);
            }
            if (object.listOperationsReply != null) {
                if (typeof object.listOperationsReply !== "object")
                    throw TypeError(".StreamMessage.listOperationsReply: object expected");
                message.listOperationsReply = $root.ListOperationsReply.fromObject(object.listOperationsReply);
            }
            if (object.startProgramRequest != null) {
                if (typeof object.startProgramRequest !== "object")
                    throw TypeError(".StreamMessage.startProgramRequest: object expected");
                message.startProgramRequest = $root.StartProgramRequest.fromObject(object.startProgramRequest);
            }
            if (object.startProgramReply != null) {
                if (typeof object.startProgramReply !== "object")
                    throw TypeError(".StreamMessage.startProgramReply: object expected");
                message.startProgramReply = $root.StartProgramReply.fromObject(object.startProgramReply);
            }
            if (object.stopCirculatorRequest != null) {
                if (typeof object.stopCirculatorRequest !== "object")
                    throw TypeError(".StreamMessage.stopCirculatorRequest: object expected");
                message.stopCirculatorRequest = $root.StopCirculatorRequest.fromObject(object.stopCirculatorRequest);
            }
            if (object.stopCirculatorReply != null) {
                if (typeof object.stopCirculatorReply !== "object")
                    throw TypeError(".StreamMessage.stopCirculatorReply: object expected");
                message.stopCirculatorReply = $root.StopCirculatorReply.fromObject(object.stopCirculatorReply);
            }
            if (object.dropFoodRequest != null) {
                if (typeof object.dropFoodRequest !== "object")
                    throw TypeError(".StreamMessage.dropFoodRequest: object expected");
                message.dropFoodRequest = $root.DropFoodRequest.fromObject(object.dropFoodRequest);
            }
            if (object.dropFoodReply != null) {
                if (typeof object.dropFoodReply !== "object")
                    throw TypeError(".StreamMessage.dropFoodReply: object expected");
                message.dropFoodReply = $root.DropFoodReply.fromObject(object.dropFoodReply);
            }
            if (object.beginLiveFeed != null) {
                if (typeof object.beginLiveFeed !== "object")
                    throw TypeError(".StreamMessage.beginLiveFeed: object expected");
                message.beginLiveFeed = $root.BeginLiveFeed.fromObject(object.beginLiveFeed);
            }
            if (object.beginLiveFeedReply != null) {
                if (typeof object.beginLiveFeedReply !== "object")
                    throw TypeError(".StreamMessage.beginLiveFeedReply: object expected");
                message.beginLiveFeedReply = $root.BeginLiveFeedReply.fromObject(object.beginLiveFeedReply);
            }
            if (object.keepAlive != null) {
                if (typeof object.keepAlive !== "object")
                    throw TypeError(".StreamMessage.keepAlive: object expected");
                message.keepAlive = $root.KeepAlive.fromObject(object.keepAlive);
            }
            if (object.retransmitFeedRequest != null) {
                if (typeof object.retransmitFeedRequest !== "object")
                    throw TypeError(".StreamMessage.retransmitFeedRequest: object expected");
                message.retransmitFeedRequest = $root.RetransmitFeedRequest.fromObject(object.retransmitFeedRequest);
            }
            if (object.retransmitFeedReply != null) {
                if (typeof object.retransmitFeedReply !== "object")
                    throw TypeError(".StreamMessage.retransmitFeedReply: object expected");
                message.retransmitFeedReply = $root.RetransmitFeedReply.fromObject(object.retransmitFeedReply);
            }
            if (object.circulatorDataPoint != null) {
                if (typeof object.circulatorDataPoint !== "object")
                    throw TypeError(".StreamMessage.circulatorDataPoint: object expected");
                message.circulatorDataPoint = $root.CirculatorDataPoint.fromObject(object.circulatorDataPoint);
            }
            if (object.debugMessage != null) {
                if (typeof object.debugMessage !== "object")
                    throw TypeError(".StreamMessage.debugMessage: object expected");
                message.debugMessage = $root.DebugMessage.fromObject(object.debugMessage);
            }
            if (object.listRecentEventsRequest != null) {
                if (typeof object.listRecentEventsRequest !== "object")
                    throw TypeError(".StreamMessage.listRecentEventsRequest: object expected");
                message.listRecentEventsRequest = $root.ListRecentEventsRequest.fromObject(object.listRecentEventsRequest);
            }
            if (object.listRecentEventsReply != null) {
                if (typeof object.listRecentEventsReply !== "object")
                    throw TypeError(".StreamMessage.listRecentEventsReply: object expected");
                message.listRecentEventsReply = $root.ListRecentEventsReply.fromObject(object.listRecentEventsReply);
            }
            if (object.describeFeedRequest != null) {
                if (typeof object.describeFeedRequest !== "object")
                    throw TypeError(".StreamMessage.describeFeedRequest: object expected");
                message.describeFeedRequest = $root.DescribeFeedRequest.fromObject(object.describeFeedRequest);
            }
            if (object.describeFeedReply != null) {
                if (typeof object.describeFeedReply !== "object")
                    throw TypeError(".StreamMessage.describeFeedReply: object expected");
                message.describeFeedReply = $root.DescribeFeedReply.fromObject(object.describeFeedReply);
            }
            if (object.listFeedsRequest != null) {
                if (typeof object.listFeedsRequest !== "object")
                    throw TypeError(".StreamMessage.listFeedsRequest: object expected");
                message.listFeedsRequest = $root.ListFeedsRequest.fromObject(object.listFeedsRequest);
            }
            if (object.listFeedsReply != null) {
                if (typeof object.listFeedsReply !== "object")
                    throw TypeError(".StreamMessage.listFeedsReply: object expected");
                message.listFeedsReply = $root.ListFeedsReply.fromObject(object.listFeedsReply);
            }
            if (object.clearErrorRequest != null) {
                if (typeof object.clearErrorRequest !== "object")
                    throw TypeError(".StreamMessage.clearErrorRequest: object expected");
                message.clearErrorRequest = $root.ClearErrorRequest.fromObject(object.clearErrorRequest);
            }
            if (object.clearErrorReply != null) {
                if (typeof object.clearErrorReply !== "object")
                    throw TypeError(".StreamMessage.clearErrorReply: object expected");
                message.clearErrorReply = $root.ClearErrorReply.fromObject(object.clearErrorReply);
            }
            if (object.listWifiRequest != null) {
                if (typeof object.listWifiRequest !== "object")
                    throw TypeError(".StreamMessage.listWifiRequest: object expected");
                message.listWifiRequest = $root.ListWifiRequest.fromObject(object.listWifiRequest);
            }
            if (object.listWifiReply != null) {
                if (typeof object.listWifiReply !== "object")
                    throw TypeError(".StreamMessage.listWifiReply: object expected");
                message.listWifiReply = $root.ListWifiReply.fromObject(object.listWifiReply);
            }
            if (object.connectWifiRequest != null) {
                if (typeof object.connectWifiRequest !== "object")
                    throw TypeError(".StreamMessage.connectWifiRequest: object expected");
                message.connectWifiRequest = $root.ConnectWifiRequest.fromObject(object.connectWifiRequest);
            }
            if (object.connectWifiReply != null) {
                if (typeof object.connectWifiReply !== "object")
                    throw TypeError(".StreamMessage.connectWifiReply: object expected");
                message.connectWifiReply = $root.ConnectWifiReply.fromObject(object.connectWifiReply);
            }
            if (object.listWifiProfileRequest != null) {
                if (typeof object.listWifiProfileRequest !== "object")
                    throw TypeError(".StreamMessage.listWifiProfileRequest: object expected");
                message.listWifiProfileRequest = $root.ListWifiProfileRequest.fromObject(object.listWifiProfileRequest);
            }
            if (object.listWifiProfileReply != null) {
                if (typeof object.listWifiProfileReply !== "object")
                    throw TypeError(".StreamMessage.listWifiProfileReply: object expected");
                message.listWifiProfileReply = $root.ListWifiProfileReply.fromObject(object.listWifiProfileReply);
            }
            if (object.forgetWifiProfileRequest != null) {
                if (typeof object.forgetWifiProfileRequest !== "object")
                    throw TypeError(".StreamMessage.forgetWifiProfileRequest: object expected");
                message.forgetWifiProfileRequest = $root.ForgetWifiProfileRequest.fromObject(object.forgetWifiProfileRequest);
            }
            if (object.forgetWifiProfileReply != null) {
                if (typeof object.forgetWifiProfileReply !== "object")
                    throw TypeError(".StreamMessage.forgetWifiProfileReply: object expected");
                message.forgetWifiProfileReply = $root.ForgetWifiProfileReply.fromObject(object.forgetWifiProfileReply);
            }
            if (object.disconnectWifiRequest != null) {
                if (typeof object.disconnectWifiRequest !== "object")
                    throw TypeError(".StreamMessage.disconnectWifiRequest: object expected");
                message.disconnectWifiRequest = $root.DisconnectWifiRequest.fromObject(object.disconnectWifiRequest);
            }
            if (object.disconnectWifiReply != null) {
                if (typeof object.disconnectWifiReply !== "object")
                    throw TypeError(".StreamMessage.disconnectWifiReply: object expected");
                message.disconnectWifiReply = $root.DisconnectWifiReply.fromObject(object.disconnectWifiReply);
            }
            if (object.enterBootModeRequest != null) {
                if (typeof object.enterBootModeRequest !== "object")
                    throw TypeError(".StreamMessage.enterBootModeRequest: object expected");
                message.enterBootModeRequest = $root.EnterBootModeRequest.fromObject(object.enterBootModeRequest);
            }
            if (object.enterBootModeReply != null) {
                if (typeof object.enterBootModeReply !== "object")
                    throw TypeError(".StreamMessage.enterBootModeReply: object expected");
                message.enterBootModeReply = $root.EnterBootModeReply.fromObject(object.enterBootModeReply);
            }
            if (object.startFileTransferRequest != null) {
                if (typeof object.startFileTransferRequest !== "object")
                    throw TypeError(".StreamMessage.startFileTransferRequest: object expected");
                message.startFileTransferRequest = $root.StartFileTransferRequest.fromObject(object.startFileTransferRequest);
            }
            if (object.startFileTransferReply != null) {
                if (typeof object.startFileTransferReply !== "object")
                    throw TypeError(".StreamMessage.startFileTransferReply: object expected");
                message.startFileTransferReply = $root.StartFileTransferReply.fromObject(object.startFileTransferReply);
            }
            if (object.transferFileBlockRequest != null) {
                if (typeof object.transferFileBlockRequest !== "object")
                    throw TypeError(".StreamMessage.transferFileBlockRequest: object expected");
                message.transferFileBlockRequest = $root.TransferFileBlockRequest.fromObject(object.transferFileBlockRequest);
            }
            if (object.transferFileBlockReply != null) {
                if (typeof object.transferFileBlockReply !== "object")
                    throw TypeError(".StreamMessage.transferFileBlockReply: object expected");
                message.transferFileBlockReply = $root.TransferFileBlockReply.fromObject(object.transferFileBlockReply);
            }
            if (object.transferFileComplete != null) {
                if (typeof object.transferFileComplete !== "object")
                    throw TypeError(".StreamMessage.transferFileComplete: object expected");
                message.transferFileComplete = $root.TransferFileComplete.fromObject(object.transferFileComplete);
            }
            if (object.startFileReceiveRequest != null) {
                if (typeof object.startFileReceiveRequest !== "object")
                    throw TypeError(".StreamMessage.startFileReceiveRequest: object expected");
                message.startFileReceiveRequest = $root.StartFileReceiveRequest.fromObject(object.startFileReceiveRequest);
            }
            if (object.startFileReceiveReply != null) {
                if (typeof object.startFileReceiveReply !== "object")
                    throw TypeError(".StreamMessage.startFileReceiveReply: object expected");
                message.startFileReceiveReply = $root.StartFileReceiveReply.fromObject(object.startFileReceiveReply);
            }
            if (object.startKeyExchangeRequest != null) {
                if (typeof object.startKeyExchangeRequest !== "object")
                    throw TypeError(".StreamMessage.startKeyExchangeRequest: object expected");
                message.startKeyExchangeRequest = $root.StartKeyExchangeRequest.fromObject(object.startKeyExchangeRequest);
            }
            if (object.startKeyExchangeReply != null) {
                if (typeof object.startKeyExchangeReply !== "object")
                    throw TypeError(".StreamMessage.startKeyExchangeReply: object expected");
                message.startKeyExchangeReply = $root.StartKeyExchangeReply.fromObject(object.startKeyExchangeReply);
            }
            if (object.cancelKeyExchangeRequest != null) {
                if (typeof object.cancelKeyExchangeRequest !== "object")
                    throw TypeError(".StreamMessage.cancelKeyExchangeRequest: object expected");
                message.cancelKeyExchangeRequest = $root.CancelKeyExchangeRequest.fromObject(object.cancelKeyExchangeRequest);
            }
            if (object.cancelKeyExchangeReply != null) {
                if (typeof object.cancelKeyExchangeReply !== "object")
                    throw TypeError(".StreamMessage.cancelKeyExchangeReply: object expected");
                message.cancelKeyExchangeReply = $root.CancelKeyExchangeReply.fromObject(object.cancelKeyExchangeReply);
            }
            if (object.submitKeyRequest != null) {
                if (typeof object.submitKeyRequest !== "object")
                    throw TypeError(".StreamMessage.submitKeyRequest: object expected");
                message.submitKeyRequest = $root.SubmitKeyRequest.fromObject(object.submitKeyRequest);
            }
            if (object.submitKeyReply != null) {
                if (typeof object.submitKeyReply !== "object")
                    throw TypeError(".StreamMessage.submitKeyReply: object expected");
                message.submitKeyReply = $root.SubmitKeyReply.fromObject(object.submitKeyReply);
            }
            if (object.submitBearerAuthTokenRequest != null) {
                if (typeof object.submitBearerAuthTokenRequest !== "object")
                    throw TypeError(".StreamMessage.submitBearerAuthTokenRequest: object expected");
                message.submitBearerAuthTokenRequest = $root.SubmitBearerAuthTokenRequest.fromObject(object.submitBearerAuthTokenRequest);
            }
            if (object.submitBearerAuthTokenReply != null) {
                if (typeof object.submitBearerAuthTokenReply !== "object")
                    throw TypeError(".StreamMessage.submitBearerAuthTokenReply: object expected");
                message.submitBearerAuthTokenReply = $root.SubmitBearerAuthTokenReply.fromObject(object.submitBearerAuthTokenReply);
            }
            if (object.predictionUpdate != null) {
                if (typeof object.predictionUpdate !== "object")
                    throw TypeError(".StreamMessage.predictionUpdate: object expected");
                message.predictionUpdate = $root.PredictionUpdate.fromObject(object.predictionUpdate);
            }
            if (object.renameCirculatorRequest != null) {
                if (typeof object.renameCirculatorRequest !== "object")
                    throw TypeError(".StreamMessage.renameCirculatorRequest: object expected");
                message.renameCirculatorRequest = $root.RenameCirculatorRequest.fromObject(object.renameCirculatorRequest);
            }
            if (object.renameCirculatorReply != null) {
                if (typeof object.renameCirculatorReply !== "object")
                    throw TypeError(".StreamMessage.renameCirculatorReply: object expected");
                message.renameCirculatorReply = $root.RenameCirculatorReply.fromObject(object.renameCirculatorReply);
            }
            if (object.identifyCirculatorRequest != null) {
                if (typeof object.identifyCirculatorRequest !== "object")
                    throw TypeError(".StreamMessage.identifyCirculatorRequest: object expected");
                message.identifyCirculatorRequest = $root.IdentifyCirculatorRequest.fromObject(object.identifyCirculatorRequest);
            }
            if (object.identifyCirculatorReply != null) {
                if (typeof object.identifyCirculatorReply !== "object")
                    throw TypeError(".StreamMessage.identifyCirculatorReply: object expected");
                message.identifyCirculatorReply = $root.IdentifyCirculatorReply.fromObject(object.identifyCirculatorReply);
            }
            if (object.setMessagingAddressRequest != null) {
                if (typeof object.setMessagingAddressRequest !== "object")
                    throw TypeError(".StreamMessage.setMessagingAddressRequest: object expected");
                message.setMessagingAddressRequest = $root.SetMessagingAddressRequest.fromObject(object.setMessagingAddressRequest);
            }
            if (object.setMessagingAddressReply != null) {
                if (typeof object.setMessagingAddressReply !== "object")
                    throw TypeError(".StreamMessage.setMessagingAddressReply: object expected");
                message.setMessagingAddressReply = $root.SetMessagingAddressReply.fromObject(object.setMessagingAddressReply);
            }
            if (object.displayLedRequest != null) {
                if (typeof object.displayLedRequest !== "object")
                    throw TypeError(".StreamMessage.displayLedRequest: object expected");
                message.displayLedRequest = $root.DisplayLedRequest.fromObject(object.displayLedRequest);
            }
            if (object.displayLedReply != null) {
                if (typeof object.displayLedReply !== "object")
                    throw TypeError(".StreamMessage.displayLedReply: object expected");
                message.displayLedReply = $root.DisplayLedReply.fromObject(object.displayLedReply);
            }
            if (object.wifiDFUStatusRequest != null) {
                if (typeof object.wifiDFUStatusRequest !== "object")
                    throw TypeError(".StreamMessage.wifiDFUStatusRequest: object expected");
                message.wifiDFUStatusRequest = $root.WifiDFUStatusRequest.fromObject(object.wifiDFUStatusRequest);
            }
            if (object.wifiDFUStatusReply != null) {
                if (typeof object.wifiDFUStatusReply !== "object")
                    throw TypeError(".StreamMessage.wifiDFUStatusReply: object expected");
                message.wifiDFUStatusReply = $root.WifiDFUStatusReply.fromObject(object.wifiDFUStatusReply);
            }
            if (object.wifiDFUSetFirmware != null) {
                if (typeof object.wifiDFUSetFirmware !== "object")
                    throw TypeError(".StreamMessage.wifiDFUSetFirmware: object expected");
                message.wifiDFUSetFirmware = $root.WifiDFUSetFirmware.fromObject(object.wifiDFUSetFirmware);
            }
            if (object.wifiDFUDownloadTFTPRequest != null) {
                if (typeof object.wifiDFUDownloadTFTPRequest !== "object")
                    throw TypeError(".StreamMessage.wifiDFUDownloadTFTPRequest: object expected");
                message.wifiDFUDownloadTFTPRequest = $root.WifiDFUDownloadTFTPRequest.fromObject(object.wifiDFUDownloadTFTPRequest);
            }
            if (object.wifiDFUDownloadTFTPResponse != null) {
                if (typeof object.wifiDFUDownloadTFTPResponse !== "object")
                    throw TypeError(".StreamMessage.wifiDFUDownloadTFTPResponse: object expected");
                message.wifiDFUDownloadTFTPResponse = $root.WifiDFUDownloadTFTPResponse.fromObject(object.wifiDFUDownloadTFTPResponse);
            }
            if (object.getLimitsRequest != null) {
                if (typeof object.getLimitsRequest !== "object")
                    throw TypeError(".StreamMessage.getLimitsRequest: object expected");
                message.getLimitsRequest = $root.GetLimitsRequest.fromObject(object.getLimitsRequest);
            }
            if (object.getLimitsReply != null) {
                if (typeof object.getLimitsReply !== "object")
                    throw TypeError(".StreamMessage.getLimitsReply: object expected");
                message.getLimitsReply = $root.GetLimitsReply.fromObject(object.getLimitsReply);
            }
            if (object.factoryResetRequest != null) {
                if (typeof object.factoryResetRequest !== "object")
                    throw TypeError(".StreamMessage.factoryResetRequest: object expected");
                message.factoryResetRequest = $root.FactoryResetRequest.fromObject(object.factoryResetRequest);
            }
            if (object.factoryResetReply != null) {
                if (typeof object.factoryResetReply !== "object")
                    throw TypeError(".StreamMessage.factoryResetReply: object expected");
                message.factoryResetReply = $root.FactoryResetReply.fromObject(object.factoryResetReply);
            }
            if (object.deviceRestartRequest != null) {
                if (typeof object.deviceRestartRequest !== "object")
                    throw TypeError(".StreamMessage.deviceRestartRequest: object expected");
                message.deviceRestartRequest = $root.DeviceRestartRequest.fromObject(object.deviceRestartRequest);
            }
            if (object.deviceRestartReply != null) {
                if (typeof object.deviceRestartReply !== "object")
                    throw TypeError(".StreamMessage.deviceRestartReply: object expected");
                message.deviceRestartReply = $root.DeviceRestartReply.fromObject(object.deviceRestartReply);
            }
            if (object.testResetRequest != null) {
                if (typeof object.testResetRequest !== "object")
                    throw TypeError(".StreamMessage.testResetRequest: object expected");
                message.testResetRequest = $root.TestResetRequest.fromObject(object.testResetRequest);
            }
            if (object.testResetReply != null) {
                if (typeof object.testResetReply !== "object")
                    throw TypeError(".StreamMessage.testResetReply: object expected");
                message.testResetReply = $root.TestResetReply.fromObject(object.testResetReply);
            }
            if (object.forgetDevicePairingRequest != null) {
                if (typeof object.forgetDevicePairingRequest !== "object")
                    throw TypeError(".StreamMessage.forgetDevicePairingRequest: object expected");
                message.forgetDevicePairingRequest = $root.ForgetDevicePairingRequest.fromObject(object.forgetDevicePairingRequest);
            }
            if (object.forgetDevicePairingReply != null) {
                if (typeof object.forgetDevicePairingReply !== "object")
                    throw TypeError(".StreamMessage.forgetDevicePairingReply: object expected");
                message.forgetDevicePairingReply = $root.ForgetDevicePairingReply.fromObject(object.forgetDevicePairingReply);
            }
            if (object.setSimulatorRequest != null) {
                if (typeof object.setSimulatorRequest !== "object")
                    throw TypeError(".StreamMessage.setSimulatorRequest: object expected");
                message.setSimulatorRequest = $root.SetSimulatorRequest.fromObject(object.setSimulatorRequest);
            }
            if (object.setSimulatorReply != null) {
                if (typeof object.setSimulatorReply !== "object")
                    throw TypeError(".StreamMessage.setSimulatorReply: object expected");
                message.setSimulatorReply = $root.SetSimulatorReply.fromObject(object.setSimulatorReply);
            }
            if (object.getSimulatorRequest != null) {
                if (typeof object.getSimulatorRequest !== "object")
                    throw TypeError(".StreamMessage.getSimulatorRequest: object expected");
                message.getSimulatorRequest = $root.GetSimulatorRequest.fromObject(object.getSimulatorRequest);
            }
            if (object.getSimulatorReply != null) {
                if (typeof object.getSimulatorReply !== "object")
                    throw TypeError(".StreamMessage.getSimulatorReply: object expected");
                message.getSimulatorReply = $root.GetSimulatorReply.fromObject(object.getSimulatorReply);
            }
            if (object.setHardwareCoeffsRequest != null) {
                if (typeof object.setHardwareCoeffsRequest !== "object")
                    throw TypeError(".StreamMessage.setHardwareCoeffsRequest: object expected");
                message.setHardwareCoeffsRequest = $root.SetHardwareCoeffsRequest.fromObject(object.setHardwareCoeffsRequest);
            }
            if (object.setHardwareCoeffsReply != null) {
                if (typeof object.setHardwareCoeffsReply !== "object")
                    throw TypeError(".StreamMessage.setHardwareCoeffsReply: object expected");
                message.setHardwareCoeffsReply = $root.SetHardwareCoeffsReply.fromObject(object.setHardwareCoeffsReply);
            }
            if (object.getHardwareCoeffsRequest != null) {
                if (typeof object.getHardwareCoeffsRequest !== "object")
                    throw TypeError(".StreamMessage.getHardwareCoeffsRequest: object expected");
                message.getHardwareCoeffsRequest = $root.GetHardwareCoeffsRequest.fromObject(object.getHardwareCoeffsRequest);
            }
            if (object.getHardwareCoeffsReply != null) {
                if (typeof object.getHardwareCoeffsReply !== "object")
                    throw TypeError(".StreamMessage.getHardwareCoeffsReply: object expected");
                message.getHardwareCoeffsReply = $root.GetHardwareCoeffsReply.fromObject(object.getHardwareCoeffsReply);
            }
            if (object.getUsageDataRequest != null) {
                if (typeof object.getUsageDataRequest !== "object")
                    throw TypeError(".StreamMessage.getUsageDataRequest: object expected");
                message.getUsageDataRequest = $root.GetUsageDataRequest.fromObject(object.getUsageDataRequest);
            }
            if (object.getUsageDataReply != null) {
                if (typeof object.getUsageDataReply !== "object")
                    throw TypeError(".StreamMessage.getUsageDataReply: object expected");
                message.getUsageDataReply = $root.GetUsageDataReply.fromObject(object.getUsageDataReply);
            }
            if (object.resetUsageDataRequest != null) {
                if (typeof object.resetUsageDataRequest !== "object")
                    throw TypeError(".StreamMessage.resetUsageDataRequest: object expected");
                message.resetUsageDataRequest = $root.ResetUsageDataRequest.fromObject(object.resetUsageDataRequest);
            }
            if (object.resetUsageDataReply != null) {
                if (typeof object.resetUsageDataReply !== "object")
                    throw TypeError(".StreamMessage.resetUsageDataReply: object expected");
                message.resetUsageDataReply = $root.ResetUsageDataReply.fromObject(object.resetUsageDataReply);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a StreamMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof StreamMessage
         * @static
         * @param {StreamMessage} message StreamMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.handle = 0;
                object.end = false;
                object.senderAddress = options.bytes === String ? "" : [];
                object.recipientAddress = options.bytes === String ? "" : [];
            }
            if (message.handle != null && message.hasOwnProperty("handle"))
                object.handle = message.handle;
            if (message.end != null && message.hasOwnProperty("end"))
                object.end = message.end;
            if (message.senderAddress != null && message.hasOwnProperty("senderAddress"))
                object.senderAddress = options.bytes === String ? $util.base64.encode(message.senderAddress, 0, message.senderAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.senderAddress) : message.senderAddress;
            if (message.recipientAddress != null && message.hasOwnProperty("recipientAddress"))
                object.recipientAddress = options.bytes === String ? $util.base64.encode(message.recipientAddress, 0, message.recipientAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.recipientAddress) : message.recipientAddress;
            if (message.noop != null && message.hasOwnProperty("noop")) {
                object.noop = $root.Noop.toObject(message.noop, options);
                if (options.oneofs)
                    object.contents = "noop";
            }
            if (message.unhandledMessageReply != null && message.hasOwnProperty("unhandledMessageReply")) {
                object.unhandledMessageReply = $root.UnhandledMessageReply.toObject(message.unhandledMessageReply, options);
                if (options.oneofs)
                    object.contents = "unhandledMessageReply";
            }
            if (message.connectionReadyReply != null && message.hasOwnProperty("connectionReadyReply")) {
                object.connectionReadyReply = $root.ConnectionReadyReply.toObject(message.connectionReadyReply, options);
                if (options.oneofs)
                    object.contents = "connectionReadyReply";
            }
            if (message.recipientUnavailableReply != null && message.hasOwnProperty("recipientUnavailableReply")) {
                object.recipientUnavailableReply = $root.RecipientUnavailableReply.toObject(message.recipientUnavailableReply, options);
                if (options.oneofs)
                    object.contents = "recipientUnavailableReply";
            }
            if (message.ping != null && message.hasOwnProperty("ping")) {
                object.ping = $root.Ping.toObject(message.ping, options);
                if (options.oneofs)
                    object.contents = "ping";
            }
            if (message.pong != null && message.hasOwnProperty("pong")) {
                object.pong = $root.Pong.toObject(message.pong, options);
                if (options.oneofs)
                    object.contents = "pong";
            }
            if (message.listStreamsRequest != null && message.hasOwnProperty("listStreamsRequest")) {
                object.listStreamsRequest = $root.ListStreamsRequest.toObject(message.listStreamsRequest, options);
                if (options.oneofs)
                    object.contents = "listStreamsRequest";
            }
            if (message.listStreamsReply != null && message.hasOwnProperty("listStreamsReply")) {
                object.listStreamsReply = $root.ListStreamsReply.toObject(message.listStreamsReply, options);
                if (options.oneofs)
                    object.contents = "listStreamsReply";
            }
            if (message.listOperationsRequest != null && message.hasOwnProperty("listOperationsRequest")) {
                object.listOperationsRequest = $root.ListOperationsRequest.toObject(message.listOperationsRequest, options);
                if (options.oneofs)
                    object.contents = "listOperationsRequest";
            }
            if (message.listOperationsReply != null && message.hasOwnProperty("listOperationsReply")) {
                object.listOperationsReply = $root.ListOperationsReply.toObject(message.listOperationsReply, options);
                if (options.oneofs)
                    object.contents = "listOperationsReply";
            }
            if (message.listWifiRequest != null && message.hasOwnProperty("listWifiRequest")) {
                object.listWifiRequest = $root.ListWifiRequest.toObject(message.listWifiRequest, options);
                if (options.oneofs)
                    object.contents = "listWifiRequest";
            }
            if (message.listWifiReply != null && message.hasOwnProperty("listWifiReply")) {
                object.listWifiReply = $root.ListWifiReply.toObject(message.listWifiReply, options);
                if (options.oneofs)
                    object.contents = "listWifiReply";
            }
            if (message.connectWifiRequest != null && message.hasOwnProperty("connectWifiRequest")) {
                object.connectWifiRequest = $root.ConnectWifiRequest.toObject(message.connectWifiRequest, options);
                if (options.oneofs)
                    object.contents = "connectWifiRequest";
            }
            if (message.connectWifiReply != null && message.hasOwnProperty("connectWifiReply")) {
                object.connectWifiReply = $root.ConnectWifiReply.toObject(message.connectWifiReply, options);
                if (options.oneofs)
                    object.contents = "connectWifiReply";
            }
            if (message.listWifiProfileRequest != null && message.hasOwnProperty("listWifiProfileRequest")) {
                object.listWifiProfileRequest = $root.ListWifiProfileRequest.toObject(message.listWifiProfileRequest, options);
                if (options.oneofs)
                    object.contents = "listWifiProfileRequest";
            }
            if (message.listWifiProfileReply != null && message.hasOwnProperty("listWifiProfileReply")) {
                object.listWifiProfileReply = $root.ListWifiProfileReply.toObject(message.listWifiProfileReply, options);
                if (options.oneofs)
                    object.contents = "listWifiProfileReply";
            }
            if (message.forgetWifiProfileRequest != null && message.hasOwnProperty("forgetWifiProfileRequest")) {
                object.forgetWifiProfileRequest = $root.ForgetWifiProfileRequest.toObject(message.forgetWifiProfileRequest, options);
                if (options.oneofs)
                    object.contents = "forgetWifiProfileRequest";
            }
            if (message.forgetWifiProfileReply != null && message.hasOwnProperty("forgetWifiProfileReply")) {
                object.forgetWifiProfileReply = $root.ForgetWifiProfileReply.toObject(message.forgetWifiProfileReply, options);
                if (options.oneofs)
                    object.contents = "forgetWifiProfileReply";
            }
            if (message.startProgramRequest != null && message.hasOwnProperty("startProgramRequest")) {
                object.startProgramRequest = $root.StartProgramRequest.toObject(message.startProgramRequest, options);
                if (options.oneofs)
                    object.contents = "startProgramRequest";
            }
            if (message.startProgramReply != null && message.hasOwnProperty("startProgramReply")) {
                object.startProgramReply = $root.StartProgramReply.toObject(message.startProgramReply, options);
                if (options.oneofs)
                    object.contents = "startProgramReply";
            }
            if (message.stopCirculatorRequest != null && message.hasOwnProperty("stopCirculatorRequest")) {
                object.stopCirculatorRequest = $root.StopCirculatorRequest.toObject(message.stopCirculatorRequest, options);
                if (options.oneofs)
                    object.contents = "stopCirculatorRequest";
            }
            if (message.stopCirculatorReply != null && message.hasOwnProperty("stopCirculatorReply")) {
                object.stopCirculatorReply = $root.StopCirculatorReply.toObject(message.stopCirculatorReply, options);
                if (options.oneofs)
                    object.contents = "stopCirculatorReply";
            }
            if (message.beginLiveFeed != null && message.hasOwnProperty("beginLiveFeed")) {
                object.beginLiveFeed = $root.BeginLiveFeed.toObject(message.beginLiveFeed, options);
                if (options.oneofs)
                    object.contents = "beginLiveFeed";
            }
            if (message.beginLiveFeedReply != null && message.hasOwnProperty("beginLiveFeedReply")) {
                object.beginLiveFeedReply = $root.BeginLiveFeedReply.toObject(message.beginLiveFeedReply, options);
                if (options.oneofs)
                    object.contents = "beginLiveFeedReply";
            }
            if (message.keepAlive != null && message.hasOwnProperty("keepAlive")) {
                object.keepAlive = $root.KeepAlive.toObject(message.keepAlive, options);
                if (options.oneofs)
                    object.contents = "keepAlive";
            }
            if (message.retransmitFeedRequest != null && message.hasOwnProperty("retransmitFeedRequest")) {
                object.retransmitFeedRequest = $root.RetransmitFeedRequest.toObject(message.retransmitFeedRequest, options);
                if (options.oneofs)
                    object.contents = "retransmitFeedRequest";
            }
            if (message.retransmitFeedReply != null && message.hasOwnProperty("retransmitFeedReply")) {
                object.retransmitFeedReply = $root.RetransmitFeedReply.toObject(message.retransmitFeedReply, options);
                if (options.oneofs)
                    object.contents = "retransmitFeedReply";
            }
            if (message.circulatorDataPoint != null && message.hasOwnProperty("circulatorDataPoint")) {
                object.circulatorDataPoint = $root.CirculatorDataPoint.toObject(message.circulatorDataPoint, options);
                if (options.oneofs)
                    object.contents = "circulatorDataPoint";
            }
            if (message.debugMessage != null && message.hasOwnProperty("debugMessage")) {
                object.debugMessage = $root.DebugMessage.toObject(message.debugMessage, options);
                if (options.oneofs)
                    object.contents = "debugMessage";
            }
            if (message.listRecentEventsRequest != null && message.hasOwnProperty("listRecentEventsRequest")) {
                object.listRecentEventsRequest = $root.ListRecentEventsRequest.toObject(message.listRecentEventsRequest, options);
                if (options.oneofs)
                    object.contents = "listRecentEventsRequest";
            }
            if (message.listRecentEventsReply != null && message.hasOwnProperty("listRecentEventsReply")) {
                object.listRecentEventsReply = $root.ListRecentEventsReply.toObject(message.listRecentEventsReply, options);
                if (options.oneofs)
                    object.contents = "listRecentEventsReply";
            }
            if (message.describeFeedRequest != null && message.hasOwnProperty("describeFeedRequest")) {
                object.describeFeedRequest = $root.DescribeFeedRequest.toObject(message.describeFeedRequest, options);
                if (options.oneofs)
                    object.contents = "describeFeedRequest";
            }
            if (message.describeFeedReply != null && message.hasOwnProperty("describeFeedReply")) {
                object.describeFeedReply = $root.DescribeFeedReply.toObject(message.describeFeedReply, options);
                if (options.oneofs)
                    object.contents = "describeFeedReply";
            }
            if (message.listFeedsRequest != null && message.hasOwnProperty("listFeedsRequest")) {
                object.listFeedsRequest = $root.ListFeedsRequest.toObject(message.listFeedsRequest, options);
                if (options.oneofs)
                    object.contents = "listFeedsRequest";
            }
            if (message.listFeedsReply != null && message.hasOwnProperty("listFeedsReply")) {
                object.listFeedsReply = $root.ListFeedsReply.toObject(message.listFeedsReply, options);
                if (options.oneofs)
                    object.contents = "listFeedsReply";
            }
            if (message.dropFoodRequest != null && message.hasOwnProperty("dropFoodRequest")) {
                object.dropFoodRequest = $root.DropFoodRequest.toObject(message.dropFoodRequest, options);
                if (options.oneofs)
                    object.contents = "dropFoodRequest";
            }
            if (message.dropFoodReply != null && message.hasOwnProperty("dropFoodReply")) {
                object.dropFoodReply = $root.DropFoodReply.toObject(message.dropFoodReply, options);
                if (options.oneofs)
                    object.contents = "dropFoodReply";
            }
            if (message.clearErrorRequest != null && message.hasOwnProperty("clearErrorRequest")) {
                object.clearErrorRequest = $root.ClearErrorRequest.toObject(message.clearErrorRequest, options);
                if (options.oneofs)
                    object.contents = "clearErrorRequest";
            }
            if (message.clearErrorReply != null && message.hasOwnProperty("clearErrorReply")) {
                object.clearErrorReply = $root.ClearErrorReply.toObject(message.clearErrorReply, options);
                if (options.oneofs)
                    object.contents = "clearErrorReply";
            }
            if (message.enterBootModeRequest != null && message.hasOwnProperty("enterBootModeRequest")) {
                object.enterBootModeRequest = $root.EnterBootModeRequest.toObject(message.enterBootModeRequest, options);
                if (options.oneofs)
                    object.contents = "enterBootModeRequest";
            }
            if (message.enterBootModeReply != null && message.hasOwnProperty("enterBootModeReply")) {
                object.enterBootModeReply = $root.EnterBootModeReply.toObject(message.enterBootModeReply, options);
                if (options.oneofs)
                    object.contents = "enterBootModeReply";
            }
            if (message.startFileTransferRequest != null && message.hasOwnProperty("startFileTransferRequest")) {
                object.startFileTransferRequest = $root.StartFileTransferRequest.toObject(message.startFileTransferRequest, options);
                if (options.oneofs)
                    object.contents = "startFileTransferRequest";
            }
            if (message.startFileTransferReply != null && message.hasOwnProperty("startFileTransferReply")) {
                object.startFileTransferReply = $root.StartFileTransferReply.toObject(message.startFileTransferReply, options);
                if (options.oneofs)
                    object.contents = "startFileTransferReply";
            }
            if (message.transferFileBlockRequest != null && message.hasOwnProperty("transferFileBlockRequest")) {
                object.transferFileBlockRequest = $root.TransferFileBlockRequest.toObject(message.transferFileBlockRequest, options);
                if (options.oneofs)
                    object.contents = "transferFileBlockRequest";
            }
            if (message.transferFileBlockReply != null && message.hasOwnProperty("transferFileBlockReply")) {
                object.transferFileBlockReply = $root.TransferFileBlockReply.toObject(message.transferFileBlockReply, options);
                if (options.oneofs)
                    object.contents = "transferFileBlockReply";
            }
            if (message.transferFileComplete != null && message.hasOwnProperty("transferFileComplete")) {
                object.transferFileComplete = $root.TransferFileComplete.toObject(message.transferFileComplete, options);
                if (options.oneofs)
                    object.contents = "transferFileComplete";
            }
            if (message.startFileReceiveRequest != null && message.hasOwnProperty("startFileReceiveRequest")) {
                object.startFileReceiveRequest = $root.StartFileReceiveRequest.toObject(message.startFileReceiveRequest, options);
                if (options.oneofs)
                    object.contents = "startFileReceiveRequest";
            }
            if (message.startFileReceiveReply != null && message.hasOwnProperty("startFileReceiveReply")) {
                object.startFileReceiveReply = $root.StartFileReceiveReply.toObject(message.startFileReceiveReply, options);
                if (options.oneofs)
                    object.contents = "startFileReceiveReply";
            }
            if (message.startKeyExchangeRequest != null && message.hasOwnProperty("startKeyExchangeRequest")) {
                object.startKeyExchangeRequest = $root.StartKeyExchangeRequest.toObject(message.startKeyExchangeRequest, options);
                if (options.oneofs)
                    object.contents = "startKeyExchangeRequest";
            }
            if (message.startKeyExchangeReply != null && message.hasOwnProperty("startKeyExchangeReply")) {
                object.startKeyExchangeReply = $root.StartKeyExchangeReply.toObject(message.startKeyExchangeReply, options);
                if (options.oneofs)
                    object.contents = "startKeyExchangeReply";
            }
            if (message.cancelKeyExchangeRequest != null && message.hasOwnProperty("cancelKeyExchangeRequest")) {
                object.cancelKeyExchangeRequest = $root.CancelKeyExchangeRequest.toObject(message.cancelKeyExchangeRequest, options);
                if (options.oneofs)
                    object.contents = "cancelKeyExchangeRequest";
            }
            if (message.cancelKeyExchangeReply != null && message.hasOwnProperty("cancelKeyExchangeReply")) {
                object.cancelKeyExchangeReply = $root.CancelKeyExchangeReply.toObject(message.cancelKeyExchangeReply, options);
                if (options.oneofs)
                    object.contents = "cancelKeyExchangeReply";
            }
            if (message.submitKeyRequest != null && message.hasOwnProperty("submitKeyRequest")) {
                object.submitKeyRequest = $root.SubmitKeyRequest.toObject(message.submitKeyRequest, options);
                if (options.oneofs)
                    object.contents = "submitKeyRequest";
            }
            if (message.submitKeyReply != null && message.hasOwnProperty("submitKeyReply")) {
                object.submitKeyReply = $root.SubmitKeyReply.toObject(message.submitKeyReply, options);
                if (options.oneofs)
                    object.contents = "submitKeyReply";
            }
            if (message.submitBearerAuthTokenRequest != null && message.hasOwnProperty("submitBearerAuthTokenRequest")) {
                object.submitBearerAuthTokenRequest = $root.SubmitBearerAuthTokenRequest.toObject(message.submitBearerAuthTokenRequest, options);
                if (options.oneofs)
                    object.contents = "submitBearerAuthTokenRequest";
            }
            if (message.submitBearerAuthTokenReply != null && message.hasOwnProperty("submitBearerAuthTokenReply")) {
                object.submitBearerAuthTokenReply = $root.SubmitBearerAuthTokenReply.toObject(message.submitBearerAuthTokenReply, options);
                if (options.oneofs)
                    object.contents = "submitBearerAuthTokenReply";
            }
            if (message.predictionUpdate != null && message.hasOwnProperty("predictionUpdate")) {
                object.predictionUpdate = $root.PredictionUpdate.toObject(message.predictionUpdate, options);
                if (options.oneofs)
                    object.contents = "predictionUpdate";
            }
            if (message.renameCirculatorRequest != null && message.hasOwnProperty("renameCirculatorRequest")) {
                object.renameCirculatorRequest = $root.RenameCirculatorRequest.toObject(message.renameCirculatorRequest, options);
                if (options.oneofs)
                    object.contents = "renameCirculatorRequest";
            }
            if (message.renameCirculatorReply != null && message.hasOwnProperty("renameCirculatorReply")) {
                object.renameCirculatorReply = $root.RenameCirculatorReply.toObject(message.renameCirculatorReply, options);
                if (options.oneofs)
                    object.contents = "renameCirculatorReply";
            }
            if (message.identifyCirculatorRequest != null && message.hasOwnProperty("identifyCirculatorRequest")) {
                object.identifyCirculatorRequest = $root.IdentifyCirculatorRequest.toObject(message.identifyCirculatorRequest, options);
                if (options.oneofs)
                    object.contents = "identifyCirculatorRequest";
            }
            if (message.identifyCirculatorReply != null && message.hasOwnProperty("identifyCirculatorReply")) {
                object.identifyCirculatorReply = $root.IdentifyCirculatorReply.toObject(message.identifyCirculatorReply, options);
                if (options.oneofs)
                    object.contents = "identifyCirculatorReply";
            }
            if (message.setMessagingAddressRequest != null && message.hasOwnProperty("setMessagingAddressRequest")) {
                object.setMessagingAddressRequest = $root.SetMessagingAddressRequest.toObject(message.setMessagingAddressRequest, options);
                if (options.oneofs)
                    object.contents = "setMessagingAddressRequest";
            }
            if (message.setMessagingAddressReply != null && message.hasOwnProperty("setMessagingAddressReply")) {
                object.setMessagingAddressReply = $root.SetMessagingAddressReply.toObject(message.setMessagingAddressReply, options);
                if (options.oneofs)
                    object.contents = "setMessagingAddressReply";
            }
            if (message.displayLedRequest != null && message.hasOwnProperty("displayLedRequest")) {
                object.displayLedRequest = $root.DisplayLedRequest.toObject(message.displayLedRequest, options);
                if (options.oneofs)
                    object.contents = "displayLedRequest";
            }
            if (message.displayLedReply != null && message.hasOwnProperty("displayLedReply")) {
                object.displayLedReply = $root.DisplayLedReply.toObject(message.displayLedReply, options);
                if (options.oneofs)
                    object.contents = "displayLedReply";
            }
            if (message.disconnectWifiRequest != null && message.hasOwnProperty("disconnectWifiRequest")) {
                object.disconnectWifiRequest = $root.DisconnectWifiRequest.toObject(message.disconnectWifiRequest, options);
                if (options.oneofs)
                    object.contents = "disconnectWifiRequest";
            }
            if (message.disconnectWifiReply != null && message.hasOwnProperty("disconnectWifiReply")) {
                object.disconnectWifiReply = $root.DisconnectWifiReply.toObject(message.disconnectWifiReply, options);
                if (options.oneofs)
                    object.contents = "disconnectWifiReply";
            }
            if (message.wifiDFUStatusRequest != null && message.hasOwnProperty("wifiDFUStatusRequest")) {
                object.wifiDFUStatusRequest = $root.WifiDFUStatusRequest.toObject(message.wifiDFUStatusRequest, options);
                if (options.oneofs)
                    object.contents = "wifiDFUStatusRequest";
            }
            if (message.wifiDFUStatusReply != null && message.hasOwnProperty("wifiDFUStatusReply")) {
                object.wifiDFUStatusReply = $root.WifiDFUStatusReply.toObject(message.wifiDFUStatusReply, options);
                if (options.oneofs)
                    object.contents = "wifiDFUStatusReply";
            }
            if (message.wifiDFUSetFirmware != null && message.hasOwnProperty("wifiDFUSetFirmware")) {
                object.wifiDFUSetFirmware = $root.WifiDFUSetFirmware.toObject(message.wifiDFUSetFirmware, options);
                if (options.oneofs)
                    object.contents = "wifiDFUSetFirmware";
            }
            if (message.wifiDFUDownloadTFTPRequest != null && message.hasOwnProperty("wifiDFUDownloadTFTPRequest")) {
                object.wifiDFUDownloadTFTPRequest = $root.WifiDFUDownloadTFTPRequest.toObject(message.wifiDFUDownloadTFTPRequest, options);
                if (options.oneofs)
                    object.contents = "wifiDFUDownloadTFTPRequest";
            }
            if (message.wifiDFUDownloadTFTPResponse != null && message.hasOwnProperty("wifiDFUDownloadTFTPResponse")) {
                object.wifiDFUDownloadTFTPResponse = $root.WifiDFUDownloadTFTPResponse.toObject(message.wifiDFUDownloadTFTPResponse, options);
                if (options.oneofs)
                    object.contents = "wifiDFUDownloadTFTPResponse";
            }
            if (message.getLimitsRequest != null && message.hasOwnProperty("getLimitsRequest")) {
                object.getLimitsRequest = $root.GetLimitsRequest.toObject(message.getLimitsRequest, options);
                if (options.oneofs)
                    object.contents = "getLimitsRequest";
            }
            if (message.getLimitsReply != null && message.hasOwnProperty("getLimitsReply")) {
                object.getLimitsReply = $root.GetLimitsReply.toObject(message.getLimitsReply, options);
                if (options.oneofs)
                    object.contents = "getLimitsReply";
            }
            if (message.factoryResetRequest != null && message.hasOwnProperty("factoryResetRequest")) {
                object.factoryResetRequest = $root.FactoryResetRequest.toObject(message.factoryResetRequest, options);
                if (options.oneofs)
                    object.contents = "factoryResetRequest";
            }
            if (message.factoryResetReply != null && message.hasOwnProperty("factoryResetReply")) {
                object.factoryResetReply = $root.FactoryResetReply.toObject(message.factoryResetReply, options);
                if (options.oneofs)
                    object.contents = "factoryResetReply";
            }
            if (message.deviceRestartRequest != null && message.hasOwnProperty("deviceRestartRequest")) {
                object.deviceRestartRequest = $root.DeviceRestartRequest.toObject(message.deviceRestartRequest, options);
                if (options.oneofs)
                    object.contents = "deviceRestartRequest";
            }
            if (message.deviceRestartReply != null && message.hasOwnProperty("deviceRestartReply")) {
                object.deviceRestartReply = $root.DeviceRestartReply.toObject(message.deviceRestartReply, options);
                if (options.oneofs)
                    object.contents = "deviceRestartReply";
            }
            if (message.testResetRequest != null && message.hasOwnProperty("testResetRequest")) {
                object.testResetRequest = $root.TestResetRequest.toObject(message.testResetRequest, options);
                if (options.oneofs)
                    object.contents = "testResetRequest";
            }
            if (message.testResetReply != null && message.hasOwnProperty("testResetReply")) {
                object.testResetReply = $root.TestResetReply.toObject(message.testResetReply, options);
                if (options.oneofs)
                    object.contents = "testResetReply";
            }
            if (message.forgetDevicePairingRequest != null && message.hasOwnProperty("forgetDevicePairingRequest")) {
                object.forgetDevicePairingRequest = $root.ForgetDevicePairingRequest.toObject(message.forgetDevicePairingRequest, options);
                if (options.oneofs)
                    object.contents = "forgetDevicePairingRequest";
            }
            if (message.forgetDevicePairingReply != null && message.hasOwnProperty("forgetDevicePairingReply")) {
                object.forgetDevicePairingReply = $root.ForgetDevicePairingReply.toObject(message.forgetDevicePairingReply, options);
                if (options.oneofs)
                    object.contents = "forgetDevicePairingReply";
            }
            if (message.setSimulatorRequest != null && message.hasOwnProperty("setSimulatorRequest")) {
                object.setSimulatorRequest = $root.SetSimulatorRequest.toObject(message.setSimulatorRequest, options);
                if (options.oneofs)
                    object.contents = "setSimulatorRequest";
            }
            if (message.setSimulatorReply != null && message.hasOwnProperty("setSimulatorReply")) {
                object.setSimulatorReply = $root.SetSimulatorReply.toObject(message.setSimulatorReply, options);
                if (options.oneofs)
                    object.contents = "setSimulatorReply";
            }
            if (message.getSimulatorRequest != null && message.hasOwnProperty("getSimulatorRequest")) {
                object.getSimulatorRequest = $root.GetSimulatorRequest.toObject(message.getSimulatorRequest, options);
                if (options.oneofs)
                    object.contents = "getSimulatorRequest";
            }
            if (message.getSimulatorReply != null && message.hasOwnProperty("getSimulatorReply")) {
                object.getSimulatorReply = $root.GetSimulatorReply.toObject(message.getSimulatorReply, options);
                if (options.oneofs)
                    object.contents = "getSimulatorReply";
            }
            if (message.setHardwareCoeffsRequest != null && message.hasOwnProperty("setHardwareCoeffsRequest")) {
                object.setHardwareCoeffsRequest = $root.SetHardwareCoeffsRequest.toObject(message.setHardwareCoeffsRequest, options);
                if (options.oneofs)
                    object.contents = "setHardwareCoeffsRequest";
            }
            if (message.setHardwareCoeffsReply != null && message.hasOwnProperty("setHardwareCoeffsReply")) {
                object.setHardwareCoeffsReply = $root.SetHardwareCoeffsReply.toObject(message.setHardwareCoeffsReply, options);
                if (options.oneofs)
                    object.contents = "setHardwareCoeffsReply";
            }
            if (message.getHardwareCoeffsRequest != null && message.hasOwnProperty("getHardwareCoeffsRequest")) {
                object.getHardwareCoeffsRequest = $root.GetHardwareCoeffsRequest.toObject(message.getHardwareCoeffsRequest, options);
                if (options.oneofs)
                    object.contents = "getHardwareCoeffsRequest";
            }
            if (message.getHardwareCoeffsReply != null && message.hasOwnProperty("getHardwareCoeffsReply")) {
                object.getHardwareCoeffsReply = $root.GetHardwareCoeffsReply.toObject(message.getHardwareCoeffsReply, options);
                if (options.oneofs)
                    object.contents = "getHardwareCoeffsReply";
            }
            if (message.getUsageDataRequest != null && message.hasOwnProperty("getUsageDataRequest")) {
                object.getUsageDataRequest = $root.GetUsageDataRequest.toObject(message.getUsageDataRequest, options);
                if (options.oneofs)
                    object.contents = "getUsageDataRequest";
            }
            if (message.getUsageDataReply != null && message.hasOwnProperty("getUsageDataReply")) {
                object.getUsageDataReply = $root.GetUsageDataReply.toObject(message.getUsageDataReply, options);
                if (options.oneofs)
                    object.contents = "getUsageDataReply";
            }
            if (message.resetUsageDataRequest != null && message.hasOwnProperty("resetUsageDataRequest")) {
                object.resetUsageDataRequest = $root.ResetUsageDataRequest.toObject(message.resetUsageDataRequest, options);
                if (options.oneofs)
                    object.contents = "resetUsageDataRequest";
            }
            if (message.resetUsageDataReply != null && message.hasOwnProperty("resetUsageDataReply")) {
                object.resetUsageDataReply = $root.ResetUsageDataReply.toObject(message.resetUsageDataReply, options);
                if (options.oneofs)
                    object.contents = "resetUsageDataReply";
            }
            return object;
        };
    
        /**
         * Converts this StreamMessage to JSON.
         * @function toJSON
         * @memberof StreamMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return StreamMessage;
    })();
    
    $root.UnhandledMessageReply = (function() {
    
        /**
         * Properties of an UnhandledMessageReply.
         * @exports IUnhandledMessageReply
         * @interface IUnhandledMessageReply
         */
    
        /**
         * Constructs a new UnhandledMessageReply.
         * @exports UnhandledMessageReply
         * @classdesc Represents an UnhandledMessageReply.
         * @constructor
         * @param {IUnhandledMessageReply=} [properties] Properties to set
         */
        function UnhandledMessageReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new UnhandledMessageReply instance using the specified properties.
         * @function create
         * @memberof UnhandledMessageReply
         * @static
         * @param {IUnhandledMessageReply=} [properties] Properties to set
         * @returns {UnhandledMessageReply} UnhandledMessageReply instance
         */
        UnhandledMessageReply.create = function create(properties) {
            return new UnhandledMessageReply(properties);
        };
    
        /**
         * Encodes the specified UnhandledMessageReply message. Does not implicitly {@link UnhandledMessageReply.verify|verify} messages.
         * @function encode
         * @memberof UnhandledMessageReply
         * @static
         * @param {IUnhandledMessageReply} message UnhandledMessageReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnhandledMessageReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified UnhandledMessageReply message, length delimited. Does not implicitly {@link UnhandledMessageReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof UnhandledMessageReply
         * @static
         * @param {IUnhandledMessageReply} message UnhandledMessageReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnhandledMessageReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an UnhandledMessageReply message from the specified reader or buffer.
         * @function decode
         * @memberof UnhandledMessageReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UnhandledMessageReply} UnhandledMessageReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnhandledMessageReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UnhandledMessageReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes an UnhandledMessageReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UnhandledMessageReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UnhandledMessageReply} UnhandledMessageReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnhandledMessageReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an UnhandledMessageReply message.
         * @function verify
         * @memberof UnhandledMessageReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnhandledMessageReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates an UnhandledMessageReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof UnhandledMessageReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {UnhandledMessageReply} UnhandledMessageReply
         */
        UnhandledMessageReply.fromObject = function fromObject(object) {
            if (object instanceof $root.UnhandledMessageReply)
                return object;
            return new $root.UnhandledMessageReply();
        };
    
        /**
         * Creates a plain object from an UnhandledMessageReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof UnhandledMessageReply
         * @static
         * @param {UnhandledMessageReply} message UnhandledMessageReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnhandledMessageReply.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this UnhandledMessageReply to JSON.
         * @function toJSON
         * @memberof UnhandledMessageReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnhandledMessageReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return UnhandledMessageReply;
    })();
    
    $root.ConnectionReadyReply = (function() {
    
        /**
         * Properties of a ConnectionReadyReply.
         * @exports IConnectionReadyReply
         * @interface IConnectionReadyReply
         */
    
        /**
         * Constructs a new ConnectionReadyReply.
         * @exports ConnectionReadyReply
         * @classdesc Represents a ConnectionReadyReply.
         * @constructor
         * @param {IConnectionReadyReply=} [properties] Properties to set
         */
        function ConnectionReadyReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new ConnectionReadyReply instance using the specified properties.
         * @function create
         * @memberof ConnectionReadyReply
         * @static
         * @param {IConnectionReadyReply=} [properties] Properties to set
         * @returns {ConnectionReadyReply} ConnectionReadyReply instance
         */
        ConnectionReadyReply.create = function create(properties) {
            return new ConnectionReadyReply(properties);
        };
    
        /**
         * Encodes the specified ConnectionReadyReply message. Does not implicitly {@link ConnectionReadyReply.verify|verify} messages.
         * @function encode
         * @memberof ConnectionReadyReply
         * @static
         * @param {IConnectionReadyReply} message ConnectionReadyReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectionReadyReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified ConnectionReadyReply message, length delimited. Does not implicitly {@link ConnectionReadyReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ConnectionReadyReply
         * @static
         * @param {IConnectionReadyReply} message ConnectionReadyReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectionReadyReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ConnectionReadyReply message from the specified reader or buffer.
         * @function decode
         * @memberof ConnectionReadyReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ConnectionReadyReply} ConnectionReadyReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectionReadyReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConnectionReadyReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ConnectionReadyReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ConnectionReadyReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ConnectionReadyReply} ConnectionReadyReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectionReadyReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ConnectionReadyReply message.
         * @function verify
         * @memberof ConnectionReadyReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnectionReadyReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a ConnectionReadyReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ConnectionReadyReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ConnectionReadyReply} ConnectionReadyReply
         */
        ConnectionReadyReply.fromObject = function fromObject(object) {
            if (object instanceof $root.ConnectionReadyReply)
                return object;
            return new $root.ConnectionReadyReply();
        };
    
        /**
         * Creates a plain object from a ConnectionReadyReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ConnectionReadyReply
         * @static
         * @param {ConnectionReadyReply} message ConnectionReadyReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnectionReadyReply.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this ConnectionReadyReply to JSON.
         * @function toJSON
         * @memberof ConnectionReadyReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnectionReadyReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ConnectionReadyReply;
    })();
    
    $root.RecipientUnavailableReply = (function() {
    
        /**
         * Properties of a RecipientUnavailableReply.
         * @exports IRecipientUnavailableReply
         * @interface IRecipientUnavailableReply
         * @property {Uint8Array} recipientAddress RecipientUnavailableReply recipientAddress
         */
    
        /**
         * Constructs a new RecipientUnavailableReply.
         * @exports RecipientUnavailableReply
         * @classdesc Represents a RecipientUnavailableReply.
         * @constructor
         * @param {IRecipientUnavailableReply=} [properties] Properties to set
         */
        function RecipientUnavailableReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * RecipientUnavailableReply recipientAddress.
         * @member {Uint8Array}recipientAddress
         * @memberof RecipientUnavailableReply
         * @instance
         */
        RecipientUnavailableReply.prototype.recipientAddress = $util.newBuffer([]);
    
        /**
         * Creates a new RecipientUnavailableReply instance using the specified properties.
         * @function create
         * @memberof RecipientUnavailableReply
         * @static
         * @param {IRecipientUnavailableReply=} [properties] Properties to set
         * @returns {RecipientUnavailableReply} RecipientUnavailableReply instance
         */
        RecipientUnavailableReply.create = function create(properties) {
            return new RecipientUnavailableReply(properties);
        };
    
        /**
         * Encodes the specified RecipientUnavailableReply message. Does not implicitly {@link RecipientUnavailableReply.verify|verify} messages.
         * @function encode
         * @memberof RecipientUnavailableReply
         * @static
         * @param {IRecipientUnavailableReply} message RecipientUnavailableReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecipientUnavailableReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recipientAddress);
            return writer;
        };
    
        /**
         * Encodes the specified RecipientUnavailableReply message, length delimited. Does not implicitly {@link RecipientUnavailableReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RecipientUnavailableReply
         * @static
         * @param {IRecipientUnavailableReply} message RecipientUnavailableReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecipientUnavailableReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RecipientUnavailableReply message from the specified reader or buffer.
         * @function decode
         * @memberof RecipientUnavailableReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RecipientUnavailableReply} RecipientUnavailableReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecipientUnavailableReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RecipientUnavailableReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recipientAddress = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("recipientAddress"))
                throw $util.ProtocolError("missing required 'recipientAddress'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a RecipientUnavailableReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RecipientUnavailableReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RecipientUnavailableReply} RecipientUnavailableReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecipientUnavailableReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RecipientUnavailableReply message.
         * @function verify
         * @memberof RecipientUnavailableReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecipientUnavailableReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!(message.recipientAddress && typeof message.recipientAddress.length === "number" || $util.isString(message.recipientAddress)))
                return "recipientAddress: buffer expected";
            return null;
        };
    
        /**
         * Creates a RecipientUnavailableReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RecipientUnavailableReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RecipientUnavailableReply} RecipientUnavailableReply
         */
        RecipientUnavailableReply.fromObject = function fromObject(object) {
            if (object instanceof $root.RecipientUnavailableReply)
                return object;
            var message = new $root.RecipientUnavailableReply();
            if (object.recipientAddress != null)
                if (typeof object.recipientAddress === "string")
                    $util.base64.decode(object.recipientAddress, message.recipientAddress = $util.newBuffer($util.base64.length(object.recipientAddress)), 0);
                else if (object.recipientAddress.length)
                    message.recipientAddress = object.recipientAddress;
            return message;
        };
    
        /**
         * Creates a plain object from a RecipientUnavailableReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RecipientUnavailableReply
         * @static
         * @param {RecipientUnavailableReply} message RecipientUnavailableReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecipientUnavailableReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.recipientAddress = options.bytes === String ? "" : [];
            if (message.recipientAddress != null && message.hasOwnProperty("recipientAddress"))
                object.recipientAddress = options.bytes === String ? $util.base64.encode(message.recipientAddress, 0, message.recipientAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.recipientAddress) : message.recipientAddress;
            return object;
        };
    
        /**
         * Converts this RecipientUnavailableReply to JSON.
         * @function toJSON
         * @memberof RecipientUnavailableReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecipientUnavailableReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return RecipientUnavailableReply;
    })();
    
    $root.ListStreamsRequest = (function() {
    
        /**
         * Properties of a ListStreamsRequest.
         * @exports IListStreamsRequest
         * @interface IListStreamsRequest
         */
    
        /**
         * Constructs a new ListStreamsRequest.
         * @exports ListStreamsRequest
         * @classdesc Represents a ListStreamsRequest.
         * @constructor
         * @param {IListStreamsRequest=} [properties] Properties to set
         */
        function ListStreamsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new ListStreamsRequest instance using the specified properties.
         * @function create
         * @memberof ListStreamsRequest
         * @static
         * @param {IListStreamsRequest=} [properties] Properties to set
         * @returns {ListStreamsRequest} ListStreamsRequest instance
         */
        ListStreamsRequest.create = function create(properties) {
            return new ListStreamsRequest(properties);
        };
    
        /**
         * Encodes the specified ListStreamsRequest message. Does not implicitly {@link ListStreamsRequest.verify|verify} messages.
         * @function encode
         * @memberof ListStreamsRequest
         * @static
         * @param {IListStreamsRequest} message ListStreamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListStreamsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified ListStreamsRequest message, length delimited. Does not implicitly {@link ListStreamsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ListStreamsRequest
         * @static
         * @param {IListStreamsRequest} message ListStreamsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListStreamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ListStreamsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ListStreamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ListStreamsRequest} ListStreamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListStreamsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListStreamsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ListStreamsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ListStreamsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ListStreamsRequest} ListStreamsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListStreamsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ListStreamsRequest message.
         * @function verify
         * @memberof ListStreamsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListStreamsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a ListStreamsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ListStreamsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ListStreamsRequest} ListStreamsRequest
         */
        ListStreamsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ListStreamsRequest)
                return object;
            return new $root.ListStreamsRequest();
        };
    
        /**
         * Creates a plain object from a ListStreamsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ListStreamsRequest
         * @static
         * @param {ListStreamsRequest} message ListStreamsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListStreamsRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this ListStreamsRequest to JSON.
         * @function toJSON
         * @memberof ListStreamsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListStreamsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ListStreamsRequest;
    })();
    
    $root.ListStreamsReply = (function() {
    
        /**
         * Properties of a ListStreamsReply.
         * @exports IListStreamsReply
         * @interface IListStreamsReply
         * @property {Uint8Array} encodedStreamMessage ListStreamsReply encodedStreamMessage
         */
    
        /**
         * Constructs a new ListStreamsReply.
         * @exports ListStreamsReply
         * @classdesc Represents a ListStreamsReply.
         * @constructor
         * @param {IListStreamsReply=} [properties] Properties to set
         */
        function ListStreamsReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ListStreamsReply encodedStreamMessage.
         * @member {Uint8Array}encodedStreamMessage
         * @memberof ListStreamsReply
         * @instance
         */
        ListStreamsReply.prototype.encodedStreamMessage = $util.newBuffer([]);
    
        /**
         * Creates a new ListStreamsReply instance using the specified properties.
         * @function create
         * @memberof ListStreamsReply
         * @static
         * @param {IListStreamsReply=} [properties] Properties to set
         * @returns {ListStreamsReply} ListStreamsReply instance
         */
        ListStreamsReply.create = function create(properties) {
            return new ListStreamsReply(properties);
        };
    
        /**
         * Encodes the specified ListStreamsReply message. Does not implicitly {@link ListStreamsReply.verify|verify} messages.
         * @function encode
         * @memberof ListStreamsReply
         * @static
         * @param {IListStreamsReply} message ListStreamsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListStreamsReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1000, wireType 2 =*/8002).bytes(message.encodedStreamMessage);
            return writer;
        };
    
        /**
         * Encodes the specified ListStreamsReply message, length delimited. Does not implicitly {@link ListStreamsReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ListStreamsReply
         * @static
         * @param {IListStreamsReply} message ListStreamsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListStreamsReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ListStreamsReply message from the specified reader or buffer.
         * @function decode
         * @memberof ListStreamsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ListStreamsReply} ListStreamsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListStreamsReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListStreamsReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.encodedStreamMessage = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("encodedStreamMessage"))
                throw $util.ProtocolError("missing required 'encodedStreamMessage'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a ListStreamsReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ListStreamsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ListStreamsReply} ListStreamsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListStreamsReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ListStreamsReply message.
         * @function verify
         * @memberof ListStreamsReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListStreamsReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!(message.encodedStreamMessage && typeof message.encodedStreamMessage.length === "number" || $util.isString(message.encodedStreamMessage)))
                return "encodedStreamMessage: buffer expected";
            return null;
        };
    
        /**
         * Creates a ListStreamsReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ListStreamsReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ListStreamsReply} ListStreamsReply
         */
        ListStreamsReply.fromObject = function fromObject(object) {
            if (object instanceof $root.ListStreamsReply)
                return object;
            var message = new $root.ListStreamsReply();
            if (object.encodedStreamMessage != null)
                if (typeof object.encodedStreamMessage === "string")
                    $util.base64.decode(object.encodedStreamMessage, message.encodedStreamMessage = $util.newBuffer($util.base64.length(object.encodedStreamMessage)), 0);
                else if (object.encodedStreamMessage.length)
                    message.encodedStreamMessage = object.encodedStreamMessage;
            return message;
        };
    
        /**
         * Creates a plain object from a ListStreamsReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ListStreamsReply
         * @static
         * @param {ListStreamsReply} message ListStreamsReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListStreamsReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.encodedStreamMessage = options.bytes === String ? "" : [];
            if (message.encodedStreamMessage != null && message.hasOwnProperty("encodedStreamMessage"))
                object.encodedStreamMessage = options.bytes === String ? $util.base64.encode(message.encodedStreamMessage, 0, message.encodedStreamMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.encodedStreamMessage) : message.encodedStreamMessage;
            return object;
        };
    
        /**
         * Converts this ListStreamsReply to JSON.
         * @function toJSON
         * @memberof ListStreamsReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListStreamsReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ListStreamsReply;
    })();
    
    $root.ListOperationsRequest = (function() {
    
        /**
         * Properties of a ListOperationsRequest.
         * @exports IListOperationsRequest
         * @interface IListOperationsRequest
         */
    
        /**
         * Constructs a new ListOperationsRequest.
         * @exports ListOperationsRequest
         * @classdesc Represents a ListOperationsRequest.
         * @constructor
         * @param {IListOperationsRequest=} [properties] Properties to set
         */
        function ListOperationsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new ListOperationsRequest instance using the specified properties.
         * @function create
         * @memberof ListOperationsRequest
         * @static
         * @param {IListOperationsRequest=} [properties] Properties to set
         * @returns {ListOperationsRequest} ListOperationsRequest instance
         */
        ListOperationsRequest.create = function create(properties) {
            return new ListOperationsRequest(properties);
        };
    
        /**
         * Encodes the specified ListOperationsRequest message. Does not implicitly {@link ListOperationsRequest.verify|verify} messages.
         * @function encode
         * @memberof ListOperationsRequest
         * @static
         * @param {IListOperationsRequest} message ListOperationsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListOperationsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified ListOperationsRequest message, length delimited. Does not implicitly {@link ListOperationsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ListOperationsRequest
         * @static
         * @param {IListOperationsRequest} message ListOperationsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListOperationsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ListOperationsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ListOperationsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ListOperationsRequest} ListOperationsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListOperationsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListOperationsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ListOperationsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ListOperationsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ListOperationsRequest} ListOperationsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListOperationsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ListOperationsRequest message.
         * @function verify
         * @memberof ListOperationsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListOperationsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a ListOperationsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ListOperationsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ListOperationsRequest} ListOperationsRequest
         */
        ListOperationsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ListOperationsRequest)
                return object;
            return new $root.ListOperationsRequest();
        };
    
        /**
         * Creates a plain object from a ListOperationsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ListOperationsRequest
         * @static
         * @param {ListOperationsRequest} message ListOperationsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListOperationsRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this ListOperationsRequest to JSON.
         * @function toJSON
         * @memberof ListOperationsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListOperationsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ListOperationsRequest;
    })();
    
    $root.ListOperationsReply = (function() {
    
        /**
         * Properties of a ListOperationsReply.
         * @exports IListOperationsReply
         * @interface IListOperationsReply
         * @property {string} name ListOperationsReply name
         */
    
        /**
         * Constructs a new ListOperationsReply.
         * @exports ListOperationsReply
         * @classdesc Represents a ListOperationsReply.
         * @constructor
         * @param {IListOperationsReply=} [properties] Properties to set
         */
        function ListOperationsReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ListOperationsReply name.
         * @member {string}name
         * @memberof ListOperationsReply
         * @instance
         */
        ListOperationsReply.prototype.name = "";
    
        /**
         * Creates a new ListOperationsReply instance using the specified properties.
         * @function create
         * @memberof ListOperationsReply
         * @static
         * @param {IListOperationsReply=} [properties] Properties to set
         * @returns {ListOperationsReply} ListOperationsReply instance
         */
        ListOperationsReply.create = function create(properties) {
            return new ListOperationsReply(properties);
        };
    
        /**
         * Encodes the specified ListOperationsReply message. Does not implicitly {@link ListOperationsReply.verify|verify} messages.
         * @function encode
         * @memberof ListOperationsReply
         * @static
         * @param {IListOperationsReply} message ListOperationsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListOperationsReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1000, wireType 2 =*/8002).string(message.name);
            return writer;
        };
    
        /**
         * Encodes the specified ListOperationsReply message, length delimited. Does not implicitly {@link ListOperationsReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ListOperationsReply
         * @static
         * @param {IListOperationsReply} message ListOperationsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListOperationsReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ListOperationsReply message from the specified reader or buffer.
         * @function decode
         * @memberof ListOperationsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ListOperationsReply} ListOperationsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListOperationsReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListOperationsReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a ListOperationsReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ListOperationsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ListOperationsReply} ListOperationsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListOperationsReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ListOperationsReply message.
         * @function verify
         * @memberof ListOperationsReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListOperationsReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            return null;
        };
    
        /**
         * Creates a ListOperationsReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ListOperationsReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ListOperationsReply} ListOperationsReply
         */
        ListOperationsReply.fromObject = function fromObject(object) {
            if (object instanceof $root.ListOperationsReply)
                return object;
            var message = new $root.ListOperationsReply();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };
    
        /**
         * Creates a plain object from a ListOperationsReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ListOperationsReply
         * @static
         * @param {ListOperationsReply} message ListOperationsReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListOperationsReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.name = "";
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };
    
        /**
         * Converts this ListOperationsReply to JSON.
         * @function toJSON
         * @memberof ListOperationsReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListOperationsReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ListOperationsReply;
    })();
    
    $root.IdentifyCirculatorRequest = (function() {
    
        /**
         * Properties of an IdentifyCirculatorRequest.
         * @exports IIdentifyCirculatorRequest
         * @interface IIdentifyCirculatorRequest
         */
    
        /**
         * Constructs a new IdentifyCirculatorRequest.
         * @exports IdentifyCirculatorRequest
         * @classdesc Represents an IdentifyCirculatorRequest.
         * @constructor
         * @param {IIdentifyCirculatorRequest=} [properties] Properties to set
         */
        function IdentifyCirculatorRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new IdentifyCirculatorRequest instance using the specified properties.
         * @function create
         * @memberof IdentifyCirculatorRequest
         * @static
         * @param {IIdentifyCirculatorRequest=} [properties] Properties to set
         * @returns {IdentifyCirculatorRequest} IdentifyCirculatorRequest instance
         */
        IdentifyCirculatorRequest.create = function create(properties) {
            return new IdentifyCirculatorRequest(properties);
        };
    
        /**
         * Encodes the specified IdentifyCirculatorRequest message. Does not implicitly {@link IdentifyCirculatorRequest.verify|verify} messages.
         * @function encode
         * @memberof IdentifyCirculatorRequest
         * @static
         * @param {IIdentifyCirculatorRequest} message IdentifyCirculatorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentifyCirculatorRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified IdentifyCirculatorRequest message, length delimited. Does not implicitly {@link IdentifyCirculatorRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof IdentifyCirculatorRequest
         * @static
         * @param {IIdentifyCirculatorRequest} message IdentifyCirculatorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentifyCirculatorRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an IdentifyCirculatorRequest message from the specified reader or buffer.
         * @function decode
         * @memberof IdentifyCirculatorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {IdentifyCirculatorRequest} IdentifyCirculatorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentifyCirculatorRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IdentifyCirculatorRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes an IdentifyCirculatorRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof IdentifyCirculatorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {IdentifyCirculatorRequest} IdentifyCirculatorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentifyCirculatorRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an IdentifyCirculatorRequest message.
         * @function verify
         * @memberof IdentifyCirculatorRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentifyCirculatorRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates an IdentifyCirculatorRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof IdentifyCirculatorRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {IdentifyCirculatorRequest} IdentifyCirculatorRequest
         */
        IdentifyCirculatorRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.IdentifyCirculatorRequest)
                return object;
            return new $root.IdentifyCirculatorRequest();
        };
    
        /**
         * Creates a plain object from an IdentifyCirculatorRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof IdentifyCirculatorRequest
         * @static
         * @param {IdentifyCirculatorRequest} message IdentifyCirculatorRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentifyCirculatorRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this IdentifyCirculatorRequest to JSON.
         * @function toJSON
         * @memberof IdentifyCirculatorRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentifyCirculatorRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return IdentifyCirculatorRequest;
    })();
    
    $root.IdentifyCirculatorReply = (function() {
    
        /**
         * Properties of an IdentifyCirculatorReply.
         * @exports IIdentifyCirculatorReply
         * @interface IIdentifyCirculatorReply
         * @property {string} name IdentifyCirculatorReply name
         * @property {string} [firmwareVersion] IdentifyCirculatorReply firmwareVersion
         * @property {string} hardwareVersion IdentifyCirculatorReply hardwareVersion
         * @property {string} [serialNumber] IdentifyCirculatorReply serialNumber
         * @property {string} [bleMacAddress] IdentifyCirculatorReply bleMacAddress
         * @property {string} [softdeviceVersion] IdentifyCirculatorReply softdeviceVersion
         * @property {string} [bootloaderVersion] IdentifyCirculatorReply bootloaderVersion
         * @property {string} [appFirmwareVersion] IdentifyCirculatorReply appFirmwareVersion
         * @property {string} [espFirmwareVersion] IdentifyCirculatorReply espFirmwareVersion
         * @property {string} [certificateVersion] IdentifyCirculatorReply certificateVersion
         * @property {string} [modelNumber] IdentifyCirculatorReply modelNumber
         * @property {number} [apiVersion] IdentifyCirculatorReply apiVersion
         * @property {number} [hardwareOptions] IdentifyCirculatorReply hardwareOptions
         * @property {number} [buildDate] IdentifyCirculatorReply buildDate
         */
    
        /**
         * Constructs a new IdentifyCirculatorReply.
         * @exports IdentifyCirculatorReply
         * @classdesc Represents an IdentifyCirculatorReply.
         * @constructor
         * @param {IIdentifyCirculatorReply=} [properties] Properties to set
         */
        function IdentifyCirculatorReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * IdentifyCirculatorReply name.
         * @member {string}name
         * @memberof IdentifyCirculatorReply
         * @instance
         */
        IdentifyCirculatorReply.prototype.name = "";
    
        /**
         * IdentifyCirculatorReply firmwareVersion.
         * @member {string}firmwareVersion
         * @memberof IdentifyCirculatorReply
         * @instance
         */
        IdentifyCirculatorReply.prototype.firmwareVersion = "";
    
        /**
         * IdentifyCirculatorReply hardwareVersion.
         * @member {string}hardwareVersion
         * @memberof IdentifyCirculatorReply
         * @instance
         */
        IdentifyCirculatorReply.prototype.hardwareVersion = "";
    
        /**
         * IdentifyCirculatorReply serialNumber.
         * @member {string}serialNumber
         * @memberof IdentifyCirculatorReply
         * @instance
         */
        IdentifyCirculatorReply.prototype.serialNumber = "";
    
        /**
         * IdentifyCirculatorReply bleMacAddress.
         * @member {string}bleMacAddress
         * @memberof IdentifyCirculatorReply
         * @instance
         */
        IdentifyCirculatorReply.prototype.bleMacAddress = "";
    
        /**
         * IdentifyCirculatorReply softdeviceVersion.
         * @member {string}softdeviceVersion
         * @memberof IdentifyCirculatorReply
         * @instance
         */
        IdentifyCirculatorReply.prototype.softdeviceVersion = "";
    
        /**
         * IdentifyCirculatorReply bootloaderVersion.
         * @member {string}bootloaderVersion
         * @memberof IdentifyCirculatorReply
         * @instance
         */
        IdentifyCirculatorReply.prototype.bootloaderVersion = "";
    
        /**
         * IdentifyCirculatorReply appFirmwareVersion.
         * @member {string}appFirmwareVersion
         * @memberof IdentifyCirculatorReply
         * @instance
         */
        IdentifyCirculatorReply.prototype.appFirmwareVersion = "";
    
        /**
         * IdentifyCirculatorReply espFirmwareVersion.
         * @member {string}espFirmwareVersion
         * @memberof IdentifyCirculatorReply
         * @instance
         */
        IdentifyCirculatorReply.prototype.espFirmwareVersion = "";
    
        /**
         * IdentifyCirculatorReply certificateVersion.
         * @member {string}certificateVersion
         * @memberof IdentifyCirculatorReply
         * @instance
         */
        IdentifyCirculatorReply.prototype.certificateVersion = "";
    
        /**
         * IdentifyCirculatorReply modelNumber.
         * @member {string}modelNumber
         * @memberof IdentifyCirculatorReply
         * @instance
         */
        IdentifyCirculatorReply.prototype.modelNumber = "";
    
        /**
         * IdentifyCirculatorReply apiVersion.
         * @member {number}apiVersion
         * @memberof IdentifyCirculatorReply
         * @instance
         */
        IdentifyCirculatorReply.prototype.apiVersion = 0;
    
        /**
         * IdentifyCirculatorReply hardwareOptions.
         * @member {number}hardwareOptions
         * @memberof IdentifyCirculatorReply
         * @instance
         */
        IdentifyCirculatorReply.prototype.hardwareOptions = 0;
    
        /**
         * IdentifyCirculatorReply buildDate.
         * @member {number}buildDate
         * @memberof IdentifyCirculatorReply
         * @instance
         */
        IdentifyCirculatorReply.prototype.buildDate = 0;
    
        /**
         * Creates a new IdentifyCirculatorReply instance using the specified properties.
         * @function create
         * @memberof IdentifyCirculatorReply
         * @static
         * @param {IIdentifyCirculatorReply=} [properties] Properties to set
         * @returns {IdentifyCirculatorReply} IdentifyCirculatorReply instance
         */
        IdentifyCirculatorReply.create = function create(properties) {
            return new IdentifyCirculatorReply(properties);
        };
    
        /**
         * Encodes the specified IdentifyCirculatorReply message. Does not implicitly {@link IdentifyCirculatorReply.verify|verify} messages.
         * @function encode
         * @memberof IdentifyCirculatorReply
         * @static
         * @param {IIdentifyCirculatorReply} message IdentifyCirculatorReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentifyCirculatorReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.firmwareVersion != null && message.hasOwnProperty("firmwareVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.firmwareVersion);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.hardwareVersion);
            if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.serialNumber);
            if (message.bleMacAddress != null && message.hasOwnProperty("bleMacAddress"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.bleMacAddress);
            if (message.softdeviceVersion != null && message.hasOwnProperty("softdeviceVersion"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.softdeviceVersion);
            if (message.bootloaderVersion != null && message.hasOwnProperty("bootloaderVersion"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.bootloaderVersion);
            if (message.appFirmwareVersion != null && message.hasOwnProperty("appFirmwareVersion"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.appFirmwareVersion);
            if (message.espFirmwareVersion != null && message.hasOwnProperty("espFirmwareVersion"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.espFirmwareVersion);
            if (message.certificateVersion != null && message.hasOwnProperty("certificateVersion"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.certificateVersion);
            if (message.modelNumber != null && message.hasOwnProperty("modelNumber"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.modelNumber);
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.apiVersion);
            if (message.hardwareOptions != null && message.hasOwnProperty("hardwareOptions"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.hardwareOptions);
            if (message.buildDate != null && message.hasOwnProperty("buildDate"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.buildDate);
            return writer;
        };
    
        /**
         * Encodes the specified IdentifyCirculatorReply message, length delimited. Does not implicitly {@link IdentifyCirculatorReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof IdentifyCirculatorReply
         * @static
         * @param {IIdentifyCirculatorReply} message IdentifyCirculatorReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdentifyCirculatorReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an IdentifyCirculatorReply message from the specified reader or buffer.
         * @function decode
         * @memberof IdentifyCirculatorReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {IdentifyCirculatorReply} IdentifyCirculatorReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentifyCirculatorReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IdentifyCirculatorReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.firmwareVersion = reader.string();
                    break;
                case 3:
                    message.hardwareVersion = reader.string();
                    break;
                case 4:
                    message.serialNumber = reader.string();
                    break;
                case 5:
                    message.bleMacAddress = reader.string();
                    break;
                case 6:
                    message.softdeviceVersion = reader.string();
                    break;
                case 7:
                    message.bootloaderVersion = reader.string();
                    break;
                case 8:
                    message.appFirmwareVersion = reader.string();
                    break;
                case 9:
                    message.espFirmwareVersion = reader.string();
                    break;
                case 10:
                    message.certificateVersion = reader.string();
                    break;
                case 11:
                    message.modelNumber = reader.string();
                    break;
                case 12:
                    message.apiVersion = reader.uint32();
                    break;
                case 13:
                    message.hardwareOptions = reader.uint32();
                    break;
                case 14:
                    message.buildDate = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("hardwareVersion"))
                throw $util.ProtocolError("missing required 'hardwareVersion'", { instance: message });
            return message;
        };
    
        /**
         * Decodes an IdentifyCirculatorReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof IdentifyCirculatorReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {IdentifyCirculatorReply} IdentifyCirculatorReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdentifyCirculatorReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an IdentifyCirculatorReply message.
         * @function verify
         * @memberof IdentifyCirculatorReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdentifyCirculatorReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (message.firmwareVersion != null && message.hasOwnProperty("firmwareVersion"))
                if (!$util.isString(message.firmwareVersion))
                    return "firmwareVersion: string expected";
            if (!$util.isString(message.hardwareVersion))
                return "hardwareVersion: string expected";
            if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
                if (!$util.isString(message.serialNumber))
                    return "serialNumber: string expected";
            if (message.bleMacAddress != null && message.hasOwnProperty("bleMacAddress"))
                if (!$util.isString(message.bleMacAddress))
                    return "bleMacAddress: string expected";
            if (message.softdeviceVersion != null && message.hasOwnProperty("softdeviceVersion"))
                if (!$util.isString(message.softdeviceVersion))
                    return "softdeviceVersion: string expected";
            if (message.bootloaderVersion != null && message.hasOwnProperty("bootloaderVersion"))
                if (!$util.isString(message.bootloaderVersion))
                    return "bootloaderVersion: string expected";
            if (message.appFirmwareVersion != null && message.hasOwnProperty("appFirmwareVersion"))
                if (!$util.isString(message.appFirmwareVersion))
                    return "appFirmwareVersion: string expected";
            if (message.espFirmwareVersion != null && message.hasOwnProperty("espFirmwareVersion"))
                if (!$util.isString(message.espFirmwareVersion))
                    return "espFirmwareVersion: string expected";
            if (message.certificateVersion != null && message.hasOwnProperty("certificateVersion"))
                if (!$util.isString(message.certificateVersion))
                    return "certificateVersion: string expected";
            if (message.modelNumber != null && message.hasOwnProperty("modelNumber"))
                if (!$util.isString(message.modelNumber))
                    return "modelNumber: string expected";
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
                if (!$util.isInteger(message.apiVersion))
                    return "apiVersion: integer expected";
            if (message.hardwareOptions != null && message.hasOwnProperty("hardwareOptions"))
                if (!$util.isInteger(message.hardwareOptions))
                    return "hardwareOptions: integer expected";
            if (message.buildDate != null && message.hasOwnProperty("buildDate"))
                if (!$util.isInteger(message.buildDate))
                    return "buildDate: integer expected";
            return null;
        };
    
        /**
         * Creates an IdentifyCirculatorReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof IdentifyCirculatorReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {IdentifyCirculatorReply} IdentifyCirculatorReply
         */
        IdentifyCirculatorReply.fromObject = function fromObject(object) {
            if (object instanceof $root.IdentifyCirculatorReply)
                return object;
            var message = new $root.IdentifyCirculatorReply();
            if (object.name != null)
                message.name = String(object.name);
            if (object.firmwareVersion != null)
                message.firmwareVersion = String(object.firmwareVersion);
            if (object.hardwareVersion != null)
                message.hardwareVersion = String(object.hardwareVersion);
            if (object.serialNumber != null)
                message.serialNumber = String(object.serialNumber);
            if (object.bleMacAddress != null)
                message.bleMacAddress = String(object.bleMacAddress);
            if (object.softdeviceVersion != null)
                message.softdeviceVersion = String(object.softdeviceVersion);
            if (object.bootloaderVersion != null)
                message.bootloaderVersion = String(object.bootloaderVersion);
            if (object.appFirmwareVersion != null)
                message.appFirmwareVersion = String(object.appFirmwareVersion);
            if (object.espFirmwareVersion != null)
                message.espFirmwareVersion = String(object.espFirmwareVersion);
            if (object.certificateVersion != null)
                message.certificateVersion = String(object.certificateVersion);
            if (object.modelNumber != null)
                message.modelNumber = String(object.modelNumber);
            if (object.apiVersion != null)
                message.apiVersion = object.apiVersion >>> 0;
            if (object.hardwareOptions != null)
                message.hardwareOptions = object.hardwareOptions >>> 0;
            if (object.buildDate != null)
                message.buildDate = object.buildDate >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from an IdentifyCirculatorReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof IdentifyCirculatorReply
         * @static
         * @param {IdentifyCirculatorReply} message IdentifyCirculatorReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdentifyCirculatorReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.firmwareVersion = "";
                object.hardwareVersion = "";
                object.serialNumber = "";
                object.bleMacAddress = "";
                object.softdeviceVersion = "";
                object.bootloaderVersion = "";
                object.appFirmwareVersion = "";
                object.espFirmwareVersion = "";
                object.certificateVersion = "";
                object.modelNumber = "";
                object.apiVersion = 0;
                object.hardwareOptions = 0;
                object.buildDate = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.firmwareVersion != null && message.hasOwnProperty("firmwareVersion"))
                object.firmwareVersion = message.firmwareVersion;
            if (message.hardwareVersion != null && message.hasOwnProperty("hardwareVersion"))
                object.hardwareVersion = message.hardwareVersion;
            if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
                object.serialNumber = message.serialNumber;
            if (message.bleMacAddress != null && message.hasOwnProperty("bleMacAddress"))
                object.bleMacAddress = message.bleMacAddress;
            if (message.softdeviceVersion != null && message.hasOwnProperty("softdeviceVersion"))
                object.softdeviceVersion = message.softdeviceVersion;
            if (message.bootloaderVersion != null && message.hasOwnProperty("bootloaderVersion"))
                object.bootloaderVersion = message.bootloaderVersion;
            if (message.appFirmwareVersion != null && message.hasOwnProperty("appFirmwareVersion"))
                object.appFirmwareVersion = message.appFirmwareVersion;
            if (message.espFirmwareVersion != null && message.hasOwnProperty("espFirmwareVersion"))
                object.espFirmwareVersion = message.espFirmwareVersion;
            if (message.certificateVersion != null && message.hasOwnProperty("certificateVersion"))
                object.certificateVersion = message.certificateVersion;
            if (message.modelNumber != null && message.hasOwnProperty("modelNumber"))
                object.modelNumber = message.modelNumber;
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
                object.apiVersion = message.apiVersion;
            if (message.hardwareOptions != null && message.hasOwnProperty("hardwareOptions"))
                object.hardwareOptions = message.hardwareOptions;
            if (message.buildDate != null && message.hasOwnProperty("buildDate"))
                object.buildDate = message.buildDate;
            return object;
        };
    
        /**
         * Converts this IdentifyCirculatorReply to JSON.
         * @function toJSON
         * @memberof IdentifyCirculatorReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdentifyCirculatorReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return IdentifyCirculatorReply;
    })();
    
    $root.RenameCirculatorRequest = (function() {
    
        /**
         * Properties of a RenameCirculatorRequest.
         * @exports IRenameCirculatorRequest
         * @interface IRenameCirculatorRequest
         * @property {string} name RenameCirculatorRequest name
         */
    
        /**
         * Constructs a new RenameCirculatorRequest.
         * @exports RenameCirculatorRequest
         * @classdesc Represents a RenameCirculatorRequest.
         * @constructor
         * @param {IRenameCirculatorRequest=} [properties] Properties to set
         */
        function RenameCirculatorRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * RenameCirculatorRequest name.
         * @member {string}name
         * @memberof RenameCirculatorRequest
         * @instance
         */
        RenameCirculatorRequest.prototype.name = "";
    
        /**
         * Creates a new RenameCirculatorRequest instance using the specified properties.
         * @function create
         * @memberof RenameCirculatorRequest
         * @static
         * @param {IRenameCirculatorRequest=} [properties] Properties to set
         * @returns {RenameCirculatorRequest} RenameCirculatorRequest instance
         */
        RenameCirculatorRequest.create = function create(properties) {
            return new RenameCirculatorRequest(properties);
        };
    
        /**
         * Encodes the specified RenameCirculatorRequest message. Does not implicitly {@link RenameCirculatorRequest.verify|verify} messages.
         * @function encode
         * @memberof RenameCirculatorRequest
         * @static
         * @param {IRenameCirculatorRequest} message RenameCirculatorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameCirculatorRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            return writer;
        };
    
        /**
         * Encodes the specified RenameCirculatorRequest message, length delimited. Does not implicitly {@link RenameCirculatorRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RenameCirculatorRequest
         * @static
         * @param {IRenameCirculatorRequest} message RenameCirculatorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameCirculatorRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RenameCirculatorRequest message from the specified reader or buffer.
         * @function decode
         * @memberof RenameCirculatorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RenameCirculatorRequest} RenameCirculatorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameCirculatorRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RenameCirculatorRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a RenameCirculatorRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RenameCirculatorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RenameCirculatorRequest} RenameCirculatorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameCirculatorRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RenameCirculatorRequest message.
         * @function verify
         * @memberof RenameCirculatorRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RenameCirculatorRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            return null;
        };
    
        /**
         * Creates a RenameCirculatorRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RenameCirculatorRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RenameCirculatorRequest} RenameCirculatorRequest
         */
        RenameCirculatorRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.RenameCirculatorRequest)
                return object;
            var message = new $root.RenameCirculatorRequest();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };
    
        /**
         * Creates a plain object from a RenameCirculatorRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RenameCirculatorRequest
         * @static
         * @param {RenameCirculatorRequest} message RenameCirculatorRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RenameCirculatorRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.name = "";
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };
    
        /**
         * Converts this RenameCirculatorRequest to JSON.
         * @function toJSON
         * @memberof RenameCirculatorRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RenameCirculatorRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return RenameCirculatorRequest;
    })();
    
    $root.RenameCirculatorReply = (function() {
    
        /**
         * Properties of a RenameCirculatorReply.
         * @exports IRenameCirculatorReply
         * @interface IRenameCirculatorReply
         * @property {Result} [result] RenameCirculatorReply result
         * @property {string} name RenameCirculatorReply name
         */
    
        /**
         * Constructs a new RenameCirculatorReply.
         * @exports RenameCirculatorReply
         * @classdesc Represents a RenameCirculatorReply.
         * @constructor
         * @param {IRenameCirculatorReply=} [properties] Properties to set
         */
        function RenameCirculatorReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * RenameCirculatorReply result.
         * @member {Result}result
         * @memberof RenameCirculatorReply
         * @instance
         */
        RenameCirculatorReply.prototype.result = 0;
    
        /**
         * RenameCirculatorReply name.
         * @member {string}name
         * @memberof RenameCirculatorReply
         * @instance
         */
        RenameCirculatorReply.prototype.name = "";
    
        /**
         * Creates a new RenameCirculatorReply instance using the specified properties.
         * @function create
         * @memberof RenameCirculatorReply
         * @static
         * @param {IRenameCirculatorReply=} [properties] Properties to set
         * @returns {RenameCirculatorReply} RenameCirculatorReply instance
         */
        RenameCirculatorReply.create = function create(properties) {
            return new RenameCirculatorReply(properties);
        };
    
        /**
         * Encodes the specified RenameCirculatorReply message. Does not implicitly {@link RenameCirculatorReply.verify|verify} messages.
         * @function encode
         * @memberof RenameCirculatorReply
         * @static
         * @param {IRenameCirculatorReply} message RenameCirculatorReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameCirculatorReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };
    
        /**
         * Encodes the specified RenameCirculatorReply message, length delimited. Does not implicitly {@link RenameCirculatorReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RenameCirculatorReply
         * @static
         * @param {IRenameCirculatorReply} message RenameCirculatorReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenameCirculatorReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RenameCirculatorReply message from the specified reader or buffer.
         * @function decode
         * @memberof RenameCirculatorReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RenameCirculatorReply} RenameCirculatorReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameCirculatorReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RenameCirculatorReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a RenameCirculatorReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RenameCirculatorReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RenameCirculatorReply} RenameCirculatorReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenameCirculatorReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RenameCirculatorReply message.
         * @function verify
         * @memberof RenameCirculatorReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RenameCirculatorReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            if (!$util.isString(message.name))
                return "name: string expected";
            return null;
        };
    
        /**
         * Creates a RenameCirculatorReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RenameCirculatorReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RenameCirculatorReply} RenameCirculatorReply
         */
        RenameCirculatorReply.fromObject = function fromObject(object) {
            if (object instanceof $root.RenameCirculatorReply)
                return object;
            var message = new $root.RenameCirculatorReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };
    
        /**
         * Creates a plain object from a RenameCirculatorReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RenameCirculatorReply
         * @static
         * @param {RenameCirculatorReply} message RenameCirculatorReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RenameCirculatorReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
                object.name = "";
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };
    
        /**
         * Converts this RenameCirculatorReply to JSON.
         * @function toJSON
         * @memberof RenameCirculatorReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RenameCirculatorReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return RenameCirculatorReply;
    })();
    
    $root.SetMessagingAddressRequest = (function() {
    
        /**
         * Properties of a SetMessagingAddressRequest.
         * @exports ISetMessagingAddressRequest
         * @interface ISetMessagingAddressRequest
         * @property {Uint8Array} address SetMessagingAddressRequest address
         */
    
        /**
         * Constructs a new SetMessagingAddressRequest.
         * @exports SetMessagingAddressRequest
         * @classdesc Represents a SetMessagingAddressRequest.
         * @constructor
         * @param {ISetMessagingAddressRequest=} [properties] Properties to set
         */
        function SetMessagingAddressRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * SetMessagingAddressRequest address.
         * @member {Uint8Array}address
         * @memberof SetMessagingAddressRequest
         * @instance
         */
        SetMessagingAddressRequest.prototype.address = $util.newBuffer([]);
    
        /**
         * Creates a new SetMessagingAddressRequest instance using the specified properties.
         * @function create
         * @memberof SetMessagingAddressRequest
         * @static
         * @param {ISetMessagingAddressRequest=} [properties] Properties to set
         * @returns {SetMessagingAddressRequest} SetMessagingAddressRequest instance
         */
        SetMessagingAddressRequest.create = function create(properties) {
            return new SetMessagingAddressRequest(properties);
        };
    
        /**
         * Encodes the specified SetMessagingAddressRequest message. Does not implicitly {@link SetMessagingAddressRequest.verify|verify} messages.
         * @function encode
         * @memberof SetMessagingAddressRequest
         * @static
         * @param {ISetMessagingAddressRequest} message SetMessagingAddressRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetMessagingAddressRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
            return writer;
        };
    
        /**
         * Encodes the specified SetMessagingAddressRequest message, length delimited. Does not implicitly {@link SetMessagingAddressRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SetMessagingAddressRequest
         * @static
         * @param {ISetMessagingAddressRequest} message SetMessagingAddressRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetMessagingAddressRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SetMessagingAddressRequest message from the specified reader or buffer.
         * @function decode
         * @memberof SetMessagingAddressRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SetMessagingAddressRequest} SetMessagingAddressRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetMessagingAddressRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetMessagingAddressRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("address"))
                throw $util.ProtocolError("missing required 'address'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SetMessagingAddressRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SetMessagingAddressRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SetMessagingAddressRequest} SetMessagingAddressRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetMessagingAddressRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SetMessagingAddressRequest message.
         * @function verify
         * @memberof SetMessagingAddressRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetMessagingAddressRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                return "address: buffer expected";
            return null;
        };
    
        /**
         * Creates a SetMessagingAddressRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SetMessagingAddressRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SetMessagingAddressRequest} SetMessagingAddressRequest
         */
        SetMessagingAddressRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.SetMessagingAddressRequest)
                return object;
            var message = new $root.SetMessagingAddressRequest();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            return message;
        };
    
        /**
         * Creates a plain object from a SetMessagingAddressRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SetMessagingAddressRequest
         * @static
         * @param {SetMessagingAddressRequest} message SetMessagingAddressRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetMessagingAddressRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.address = options.bytes === String ? "" : [];
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            return object;
        };
    
        /**
         * Converts this SetMessagingAddressRequest to JSON.
         * @function toJSON
         * @memberof SetMessagingAddressRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetMessagingAddressRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SetMessagingAddressRequest;
    })();
    
    $root.SetMessagingAddressReply = (function() {
    
        /**
         * Properties of a SetMessagingAddressReply.
         * @exports ISetMessagingAddressReply
         * @interface ISetMessagingAddressReply
         * @property {Result} [result] SetMessagingAddressReply result
         */
    
        /**
         * Constructs a new SetMessagingAddressReply.
         * @exports SetMessagingAddressReply
         * @classdesc Represents a SetMessagingAddressReply.
         * @constructor
         * @param {ISetMessagingAddressReply=} [properties] Properties to set
         */
        function SetMessagingAddressReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * SetMessagingAddressReply result.
         * @member {Result}result
         * @memberof SetMessagingAddressReply
         * @instance
         */
        SetMessagingAddressReply.prototype.result = 0;
    
        /**
         * Creates a new SetMessagingAddressReply instance using the specified properties.
         * @function create
         * @memberof SetMessagingAddressReply
         * @static
         * @param {ISetMessagingAddressReply=} [properties] Properties to set
         * @returns {SetMessagingAddressReply} SetMessagingAddressReply instance
         */
        SetMessagingAddressReply.create = function create(properties) {
            return new SetMessagingAddressReply(properties);
        };
    
        /**
         * Encodes the specified SetMessagingAddressReply message. Does not implicitly {@link SetMessagingAddressReply.verify|verify} messages.
         * @function encode
         * @memberof SetMessagingAddressReply
         * @static
         * @param {ISetMessagingAddressReply} message SetMessagingAddressReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetMessagingAddressReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified SetMessagingAddressReply message, length delimited. Does not implicitly {@link SetMessagingAddressReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SetMessagingAddressReply
         * @static
         * @param {ISetMessagingAddressReply} message SetMessagingAddressReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetMessagingAddressReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SetMessagingAddressReply message from the specified reader or buffer.
         * @function decode
         * @memberof SetMessagingAddressReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SetMessagingAddressReply} SetMessagingAddressReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetMessagingAddressReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetMessagingAddressReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a SetMessagingAddressReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SetMessagingAddressReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SetMessagingAddressReply} SetMessagingAddressReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetMessagingAddressReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SetMessagingAddressReply message.
         * @function verify
         * @memberof SetMessagingAddressReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetMessagingAddressReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a SetMessagingAddressReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SetMessagingAddressReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SetMessagingAddressReply} SetMessagingAddressReply
         */
        SetMessagingAddressReply.fromObject = function fromObject(object) {
            if (object instanceof $root.SetMessagingAddressReply)
                return object;
            var message = new $root.SetMessagingAddressReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a SetMessagingAddressReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SetMessagingAddressReply
         * @static
         * @param {SetMessagingAddressReply} message SetMessagingAddressReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetMessagingAddressReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this SetMessagingAddressReply to JSON.
         * @function toJSON
         * @memberof SetMessagingAddressReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetMessagingAddressReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SetMessagingAddressReply;
    })();
    
    $root.DisplayLedRequest = (function() {
    
        /**
         * Properties of a DisplayLedRequest.
         * @exports IDisplayLedRequest
         * @interface IDisplayLedRequest
         * @property {LedColor} ledColor DisplayLedRequest ledColor
         * @property {LedPattern} ledPattern DisplayLedRequest ledPattern
         * @property {number} durationMilliseconds DisplayLedRequest durationMilliseconds
         */
    
        /**
         * Constructs a new DisplayLedRequest.
         * @exports DisplayLedRequest
         * @classdesc Represents a DisplayLedRequest.
         * @constructor
         * @param {IDisplayLedRequest=} [properties] Properties to set
         */
        function DisplayLedRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * DisplayLedRequest ledColor.
         * @member {LedColor}ledColor
         * @memberof DisplayLedRequest
         * @instance
         */
        DisplayLedRequest.prototype.ledColor = 0;
    
        /**
         * DisplayLedRequest ledPattern.
         * @member {LedPattern}ledPattern
         * @memberof DisplayLedRequest
         * @instance
         */
        DisplayLedRequest.prototype.ledPattern = 0;
    
        /**
         * DisplayLedRequest durationMilliseconds.
         * @member {number}durationMilliseconds
         * @memberof DisplayLedRequest
         * @instance
         */
        DisplayLedRequest.prototype.durationMilliseconds = 0;
    
        /**
         * Creates a new DisplayLedRequest instance using the specified properties.
         * @function create
         * @memberof DisplayLedRequest
         * @static
         * @param {IDisplayLedRequest=} [properties] Properties to set
         * @returns {DisplayLedRequest} DisplayLedRequest instance
         */
        DisplayLedRequest.create = function create(properties) {
            return new DisplayLedRequest(properties);
        };
    
        /**
         * Encodes the specified DisplayLedRequest message. Does not implicitly {@link DisplayLedRequest.verify|verify} messages.
         * @function encode
         * @memberof DisplayLedRequest
         * @static
         * @param {IDisplayLedRequest} message DisplayLedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisplayLedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ledColor);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ledPattern);
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.durationMilliseconds);
            return writer;
        };
    
        /**
         * Encodes the specified DisplayLedRequest message, length delimited. Does not implicitly {@link DisplayLedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DisplayLedRequest
         * @static
         * @param {IDisplayLedRequest} message DisplayLedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisplayLedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a DisplayLedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof DisplayLedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DisplayLedRequest} DisplayLedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisplayLedRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DisplayLedRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ledColor = reader.int32();
                    break;
                case 2:
                    message.ledPattern = reader.int32();
                    break;
                case 3:
                    message.durationMilliseconds = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("ledColor"))
                throw $util.ProtocolError("missing required 'ledColor'", { instance: message });
            if (!message.hasOwnProperty("ledPattern"))
                throw $util.ProtocolError("missing required 'ledPattern'", { instance: message });
            if (!message.hasOwnProperty("durationMilliseconds"))
                throw $util.ProtocolError("missing required 'durationMilliseconds'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a DisplayLedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DisplayLedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DisplayLedRequest} DisplayLedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisplayLedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a DisplayLedRequest message.
         * @function verify
         * @memberof DisplayLedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisplayLedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.ledColor) {
            default:
                return "ledColor: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
                break;
            }
            switch (message.ledPattern) {
            default:
                return "ledPattern: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
            if (!$util.isInteger(message.durationMilliseconds))
                return "durationMilliseconds: integer expected";
            return null;
        };
    
        /**
         * Creates a DisplayLedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DisplayLedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DisplayLedRequest} DisplayLedRequest
         */
        DisplayLedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.DisplayLedRequest)
                return object;
            var message = new $root.DisplayLedRequest();
            switch (object.ledColor) {
            case "LED_COLOR_RED":
            case 0:
                message.ledColor = 0;
                break;
            case "LED_COLOR_GREEN":
            case 1:
                message.ledColor = 1;
                break;
            case "LED_COLOR_BLUE":
            case 2:
                message.ledColor = 2;
                break;
            case "LED_COLOR_WHITE":
            case 3:
                message.ledColor = 3;
                break;
            case "LED_COLOR_ORANGE":
            case 4:
                message.ledColor = 4;
                break;
            case "LED_COLOR_YELLOW":
            case 5:
                message.ledColor = 5;
                break;
            case "LED_COLOR_BLACK":
            case 6:
                message.ledColor = 6;
                break;
            case "LED_COLOR_PURPLE":
            case 7:
                message.ledColor = 7;
                break;
            }
            switch (object.ledPattern) {
            case "LED_PATTERN_BLINK":
            case 0:
                message.ledPattern = 0;
                break;
            case "LED_PATTERN_BREATHE":
            case 1:
                message.ledPattern = 1;
                break;
            case "LED_PATTERN_DOUBLE_BLINK":
            case 2:
                message.ledPattern = 2;
                break;
            case "LED_PATTERN_DOUBLE_PULSE":
            case 3:
                message.ledPattern = 3;
                break;
            case "LED_PATTERN_SOLID":
            case 4:
                message.ledPattern = 4;
                break;
            }
            if (object.durationMilliseconds != null)
                message.durationMilliseconds = object.durationMilliseconds >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a DisplayLedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DisplayLedRequest
         * @static
         * @param {DisplayLedRequest} message DisplayLedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DisplayLedRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.ledColor = options.enums === String ? "LED_COLOR_RED" : 0;
                object.ledPattern = options.enums === String ? "LED_PATTERN_BLINK" : 0;
                object.durationMilliseconds = 0;
            }
            if (message.ledColor != null && message.hasOwnProperty("ledColor"))
                object.ledColor = options.enums === String ? $root.LedColor[message.ledColor] : message.ledColor;
            if (message.ledPattern != null && message.hasOwnProperty("ledPattern"))
                object.ledPattern = options.enums === String ? $root.LedPattern[message.ledPattern] : message.ledPattern;
            if (message.durationMilliseconds != null && message.hasOwnProperty("durationMilliseconds"))
                object.durationMilliseconds = message.durationMilliseconds;
            return object;
        };
    
        /**
         * Converts this DisplayLedRequest to JSON.
         * @function toJSON
         * @memberof DisplayLedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DisplayLedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return DisplayLedRequest;
    })();
    
    $root.DisplayLedReply = (function() {
    
        /**
         * Properties of a DisplayLedReply.
         * @exports IDisplayLedReply
         * @interface IDisplayLedReply
         * @property {Result} result DisplayLedReply result
         */
    
        /**
         * Constructs a new DisplayLedReply.
         * @exports DisplayLedReply
         * @classdesc Represents a DisplayLedReply.
         * @constructor
         * @param {IDisplayLedReply=} [properties] Properties to set
         */
        function DisplayLedReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * DisplayLedReply result.
         * @member {Result}result
         * @memberof DisplayLedReply
         * @instance
         */
        DisplayLedReply.prototype.result = 0;
    
        /**
         * Creates a new DisplayLedReply instance using the specified properties.
         * @function create
         * @memberof DisplayLedReply
         * @static
         * @param {IDisplayLedReply=} [properties] Properties to set
         * @returns {DisplayLedReply} DisplayLedReply instance
         */
        DisplayLedReply.create = function create(properties) {
            return new DisplayLedReply(properties);
        };
    
        /**
         * Encodes the specified DisplayLedReply message. Does not implicitly {@link DisplayLedReply.verify|verify} messages.
         * @function encode
         * @memberof DisplayLedReply
         * @static
         * @param {IDisplayLedReply} message DisplayLedReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisplayLedReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified DisplayLedReply message, length delimited. Does not implicitly {@link DisplayLedReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DisplayLedReply
         * @static
         * @param {IDisplayLedReply} message DisplayLedReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisplayLedReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a DisplayLedReply message from the specified reader or buffer.
         * @function decode
         * @memberof DisplayLedReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DisplayLedReply} DisplayLedReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisplayLedReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DisplayLedReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a DisplayLedReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DisplayLedReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DisplayLedReply} DisplayLedReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisplayLedReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a DisplayLedReply message.
         * @function verify
         * @memberof DisplayLedReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisplayLedReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.result) {
            default:
                return "result: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                break;
            }
            return null;
        };
    
        /**
         * Creates a DisplayLedReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DisplayLedReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DisplayLedReply} DisplayLedReply
         */
        DisplayLedReply.fromObject = function fromObject(object) {
            if (object instanceof $root.DisplayLedReply)
                return object;
            var message = new $root.DisplayLedReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a DisplayLedReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DisplayLedReply
         * @static
         * @param {DisplayLedReply} message DisplayLedReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DisplayLedReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this DisplayLedReply to JSON.
         * @function toJSON
         * @memberof DisplayLedReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DisplayLedReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return DisplayLedReply;
    })();
    
    $root.Noop = (function() {
    
        /**
         * Properties of a Noop.
         * @exports INoop
         * @interface INoop
         */
    
        /**
         * Constructs a new Noop.
         * @exports Noop
         * @classdesc Represents a Noop.
         * @constructor
         * @param {INoop=} [properties] Properties to set
         */
        function Noop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new Noop instance using the specified properties.
         * @function create
         * @memberof Noop
         * @static
         * @param {INoop=} [properties] Properties to set
         * @returns {Noop} Noop instance
         */
        Noop.create = function create(properties) {
            return new Noop(properties);
        };
    
        /**
         * Encodes the specified Noop message. Does not implicitly {@link Noop.verify|verify} messages.
         * @function encode
         * @memberof Noop
         * @static
         * @param {INoop} message Noop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Noop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified Noop message, length delimited. Does not implicitly {@link Noop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Noop
         * @static
         * @param {INoop} message Noop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Noop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a Noop message from the specified reader or buffer.
         * @function decode
         * @memberof Noop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Noop} Noop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Noop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Noop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a Noop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Noop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Noop} Noop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Noop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a Noop message.
         * @function verify
         * @memberof Noop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Noop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a Noop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Noop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Noop} Noop
         */
        Noop.fromObject = function fromObject(object) {
            if (object instanceof $root.Noop)
                return object;
            return new $root.Noop();
        };
    
        /**
         * Creates a plain object from a Noop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Noop
         * @static
         * @param {Noop} message Noop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Noop.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this Noop to JSON.
         * @function toJSON
         * @memberof Noop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Noop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return Noop;
    })();
    
    $root.Ping = (function() {
    
        /**
         * Properties of a Ping.
         * @exports IPing
         * @interface IPing
         */
    
        /**
         * Constructs a new Ping.
         * @exports Ping
         * @classdesc Represents a Ping.
         * @constructor
         * @param {IPing=} [properties] Properties to set
         */
        function Ping(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new Ping instance using the specified properties.
         * @function create
         * @memberof Ping
         * @static
         * @param {IPing=} [properties] Properties to set
         * @returns {Ping} Ping instance
         */
        Ping.create = function create(properties) {
            return new Ping(properties);
        };
    
        /**
         * Encodes the specified Ping message. Does not implicitly {@link Ping.verify|verify} messages.
         * @function encode
         * @memberof Ping
         * @static
         * @param {IPing} message Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ping.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified Ping message, length delimited. Does not implicitly {@link Ping.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ping
         * @static
         * @param {IPing} message Ping message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Ping.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a Ping message from the specified reader or buffer.
         * @function decode
         * @memberof Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ping} Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ping.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ping();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a Ping message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ping
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ping} Ping
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Ping.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a Ping message.
         * @function verify
         * @memberof Ping
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Ping.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a Ping message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ping
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ping} Ping
         */
        Ping.fromObject = function fromObject(object) {
            if (object instanceof $root.Ping)
                return object;
            return new $root.Ping();
        };
    
        /**
         * Creates a plain object from a Ping message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ping
         * @static
         * @param {Ping} message Ping
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Ping.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this Ping to JSON.
         * @function toJSON
         * @memberof Ping
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Ping.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return Ping;
    })();
    
    $root.Pong = (function() {
    
        /**
         * Properties of a Pong.
         * @exports IPong
         * @interface IPong
         */
    
        /**
         * Constructs a new Pong.
         * @exports Pong
         * @classdesc Represents a Pong.
         * @constructor
         * @param {IPong=} [properties] Properties to set
         */
        function Pong(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new Pong instance using the specified properties.
         * @function create
         * @memberof Pong
         * @static
         * @param {IPong=} [properties] Properties to set
         * @returns {Pong} Pong instance
         */
        Pong.create = function create(properties) {
            return new Pong(properties);
        };
    
        /**
         * Encodes the specified Pong message. Does not implicitly {@link Pong.verify|verify} messages.
         * @function encode
         * @memberof Pong
         * @static
         * @param {IPong} message Pong message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pong.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified Pong message, length delimited. Does not implicitly {@link Pong.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Pong
         * @static
         * @param {IPong} message Pong message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pong.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a Pong message from the specified reader or buffer.
         * @function decode
         * @memberof Pong
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Pong} Pong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pong.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Pong();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a Pong message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Pong
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Pong} Pong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pong.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a Pong message.
         * @function verify
         * @memberof Pong
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Pong.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a Pong message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Pong
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Pong} Pong
         */
        Pong.fromObject = function fromObject(object) {
            if (object instanceof $root.Pong)
                return object;
            return new $root.Pong();
        };
    
        /**
         * Creates a plain object from a Pong message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Pong
         * @static
         * @param {Pong} message Pong
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Pong.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this Pong to JSON.
         * @function toJSON
         * @memberof Pong
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Pong.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return Pong;
    })();
    
    $root.KeepAlive = (function() {
    
        /**
         * Properties of a KeepAlive.
         * @exports IKeepAlive
         * @interface IKeepAlive
         */
    
        /**
         * Constructs a new KeepAlive.
         * @exports KeepAlive
         * @classdesc Represents a KeepAlive.
         * @constructor
         * @param {IKeepAlive=} [properties] Properties to set
         */
        function KeepAlive(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new KeepAlive instance using the specified properties.
         * @function create
         * @memberof KeepAlive
         * @static
         * @param {IKeepAlive=} [properties] Properties to set
         * @returns {KeepAlive} KeepAlive instance
         */
        KeepAlive.create = function create(properties) {
            return new KeepAlive(properties);
        };
    
        /**
         * Encodes the specified KeepAlive message. Does not implicitly {@link KeepAlive.verify|verify} messages.
         * @function encode
         * @memberof KeepAlive
         * @static
         * @param {IKeepAlive} message KeepAlive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeepAlive.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified KeepAlive message, length delimited. Does not implicitly {@link KeepAlive.verify|verify} messages.
         * @function encodeDelimited
         * @memberof KeepAlive
         * @static
         * @param {IKeepAlive} message KeepAlive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeepAlive.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a KeepAlive message from the specified reader or buffer.
         * @function decode
         * @memberof KeepAlive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {KeepAlive} KeepAlive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeepAlive.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.KeepAlive();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a KeepAlive message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof KeepAlive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {KeepAlive} KeepAlive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeepAlive.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a KeepAlive message.
         * @function verify
         * @memberof KeepAlive
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeepAlive.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a KeepAlive message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof KeepAlive
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {KeepAlive} KeepAlive
         */
        KeepAlive.fromObject = function fromObject(object) {
            if (object instanceof $root.KeepAlive)
                return object;
            return new $root.KeepAlive();
        };
    
        /**
         * Creates a plain object from a KeepAlive message. Also converts values to other types if specified.
         * @function toObject
         * @memberof KeepAlive
         * @static
         * @param {KeepAlive} message KeepAlive
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeepAlive.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this KeepAlive to JSON.
         * @function toJSON
         * @memberof KeepAlive
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeepAlive.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return KeepAlive;
    })();
    
    /**
     * Result enum.
     * @exports Result
     * @enum {string}
     * @property {number} CS_SUCCESS=0 < Successful command
     * @property {number} CS_ERROR_SVC_HANDLER_MISSING=1 < SVC handler is missing
     * @property {number} CS_ERROR_SOFTDEVICE_NOT_ENABLED=2 < SoftDevice has not been enabled
     * @property {number} CS_ERROR_INTERNAL=3 < Internal Error
     * @property {number} CS_ERROR_NO_MEM=4 < No Memory for operation
     * @property {number} CS_ERROR_NOT_FOUND=5 < Not found
     * @property {number} CS_ERROR_NOT_SUPPORTED=6 < Not supported
     * @property {number} CS_ERROR_INVALID_PARAM=7 < Invalid Parameter
     * @property {number} CS_ERROR_INVALID_STATE=8 < Invalid state, operation disallowed in this state
     * @property {number} CS_ERROR_INVALID_LENGTH=9 < Invalid Length
     * @property {number} CS_ERROR_INVALID_FLAGS=10 < Invalid Flags
     * @property {number} CS_ERROR_INVALID_DATA=11 < Invalid Data
     * @property {number} CS_ERROR_DATA_SIZE=12 < Data size exceeds limit
     * @property {number} CS_ERROR_TIMEOUT=13 < Operation timed out
     * @property {number} CS_ERROR_NULL=14 < Null Pointer
     * @property {number} CS_ERROR_FORBIDDEN=15 < Forbidden Operation
     * @property {number} CS_ERROR_INVALID_ADDR=16 < Bad Memory Address
     * @property {number} CS_ERROR_BUSY=17 < Busy
     * @property {number} CS_ERROR_IO_FAILED=18 CS_ERROR_IO_FAILED value
     * @property {number} CS_ERROR_ALREADY_EXISTS=19 CS_ERROR_ALREADY_EXISTS value
     * @property {number} CS_ERROR_END_OF_FILE=20 CS_ERROR_END_OF_FILE value
     * @property {number} CS_ERROR_NOT_CONNECTED=21 < Circulator is not connected
     * @property {number} CS_ERROR_UNKNOWN_RPC_MSG=22 < RPC message not recognized
     * @property {number} CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT=23 < Duplicate AP scan result
     * @property {number} CS_ERROR_WIFI_KEY_ERROR=24 < WiFi key is incorrect
     * @property {number} CS_ERROR_WIFI_INVALID_ROLE=25 < WiFi operation requested is not supported for current role
     * @property {number} CS_ERROR_WIFI_INVALID_SEC_TYPE=26 < WiFi security mode is not correct for network
     * @property {number} CS_ERROR_WIFI_INVALID_WEP_IND=27 < WiFi WEP key index is invalid
     * @property {number} CS_ERROR_WIFI_ALREADY_DISCONN=28 < WiFi already disconnected
     * @property {number} CS_ERROR_WIFI_NOT_CONN=29 < WiFi not connected
     * @property {number} CS_ERROR_WIFI_DISCONNECT=30 < Unexpected disconnection
     * @property {number} CS_ERROR_WIFI_INVALID_PWD=31 < WiFi password incorrect
     * @property {number} CS_ERROR_WIFI_RX_BUFF=32 < WiFi Rx buffer overrun
     * @property {number} CS_ERROR_WIFI_AP_TERM_CONN=33 < AP terminated connection
     * @property {number} CS_ERROR_INVALID_SOCKET=34 < Unable to open a valid BSD socket
     * @property {number} CS_ERROR_IO_IN_PROGRESS=35 < Async I/O incomplete -- try again
     * @property {number} CS_ERROR_GEN_SOCK_FAILURE=36 < General socket failure
     */
    $root.Result = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CS_SUCCESS"] = 0;
        values[valuesById[1] = "CS_ERROR_SVC_HANDLER_MISSING"] = 1;
        values[valuesById[2] = "CS_ERROR_SOFTDEVICE_NOT_ENABLED"] = 2;
        values[valuesById[3] = "CS_ERROR_INTERNAL"] = 3;
        values[valuesById[4] = "CS_ERROR_NO_MEM"] = 4;
        values[valuesById[5] = "CS_ERROR_NOT_FOUND"] = 5;
        values[valuesById[6] = "CS_ERROR_NOT_SUPPORTED"] = 6;
        values[valuesById[7] = "CS_ERROR_INVALID_PARAM"] = 7;
        values[valuesById[8] = "CS_ERROR_INVALID_STATE"] = 8;
        values[valuesById[9] = "CS_ERROR_INVALID_LENGTH"] = 9;
        values[valuesById[10] = "CS_ERROR_INVALID_FLAGS"] = 10;
        values[valuesById[11] = "CS_ERROR_INVALID_DATA"] = 11;
        values[valuesById[12] = "CS_ERROR_DATA_SIZE"] = 12;
        values[valuesById[13] = "CS_ERROR_TIMEOUT"] = 13;
        values[valuesById[14] = "CS_ERROR_NULL"] = 14;
        values[valuesById[15] = "CS_ERROR_FORBIDDEN"] = 15;
        values[valuesById[16] = "CS_ERROR_INVALID_ADDR"] = 16;
        values[valuesById[17] = "CS_ERROR_BUSY"] = 17;
        values[valuesById[18] = "CS_ERROR_IO_FAILED"] = 18;
        values[valuesById[19] = "CS_ERROR_ALREADY_EXISTS"] = 19;
        values[valuesById[20] = "CS_ERROR_END_OF_FILE"] = 20;
        values[valuesById[21] = "CS_ERROR_NOT_CONNECTED"] = 21;
        values[valuesById[22] = "CS_ERROR_UNKNOWN_RPC_MSG"] = 22;
        values[valuesById[23] = "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT"] = 23;
        values[valuesById[24] = "CS_ERROR_WIFI_KEY_ERROR"] = 24;
        values[valuesById[25] = "CS_ERROR_WIFI_INVALID_ROLE"] = 25;
        values[valuesById[26] = "CS_ERROR_WIFI_INVALID_SEC_TYPE"] = 26;
        values[valuesById[27] = "CS_ERROR_WIFI_INVALID_WEP_IND"] = 27;
        values[valuesById[28] = "CS_ERROR_WIFI_ALREADY_DISCONN"] = 28;
        values[valuesById[29] = "CS_ERROR_WIFI_NOT_CONN"] = 29;
        values[valuesById[30] = "CS_ERROR_WIFI_DISCONNECT"] = 30;
        values[valuesById[31] = "CS_ERROR_WIFI_INVALID_PWD"] = 31;
        values[valuesById[32] = "CS_ERROR_WIFI_RX_BUFF"] = 32;
        values[valuesById[33] = "CS_ERROR_WIFI_AP_TERM_CONN"] = 33;
        values[valuesById[34] = "CS_ERROR_INVALID_SOCKET"] = 34;
        values[valuesById[35] = "CS_ERROR_IO_IN_PROGRESS"] = 35;
        values[valuesById[36] = "CS_ERROR_GEN_SOCK_FAILURE"] = 36;
        return values;
    })();
    
    $root.CirculatorProgram = (function() {
    
        /**
         * Properties of a CirculatorProgram.
         * @exports ICirculatorProgram
         * @interface ICirculatorProgram
         * @property {number} setPoint CirculatorProgram setPoint
         * @property {number} [cookTime] CirculatorProgram cookTime
         * @property {number} [delayedStart] CirculatorProgram delayedStart
         * @property {number} [holdingTemperature] CirculatorProgram holdingTemperature
         * @property {ProgramType} programType CirculatorProgram programType
         * @property {IProgramMetadata} [programMetadata] CirculatorProgram programMetadata
         */
    
        /**
         * Constructs a new CirculatorProgram.
         * @exports CirculatorProgram
         * @classdesc Represents a CirculatorProgram.
         * @constructor
         * @param {ICirculatorProgram=} [properties] Properties to set
         */
        function CirculatorProgram(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CirculatorProgram setPoint.
         * @member {number}setPoint
         * @memberof CirculatorProgram
         * @instance
         */
        CirculatorProgram.prototype.setPoint = 0;
    
        /**
         * CirculatorProgram cookTime.
         * @member {number}cookTime
         * @memberof CirculatorProgram
         * @instance
         */
        CirculatorProgram.prototype.cookTime = 0;
    
        /**
         * CirculatorProgram delayedStart.
         * @member {number}delayedStart
         * @memberof CirculatorProgram
         * @instance
         */
        CirculatorProgram.prototype.delayedStart = 0;
    
        /**
         * CirculatorProgram holdingTemperature.
         * @member {number}holdingTemperature
         * @memberof CirculatorProgram
         * @instance
         */
        CirculatorProgram.prototype.holdingTemperature = 0;
    
        /**
         * CirculatorProgram programType.
         * @member {ProgramType}programType
         * @memberof CirculatorProgram
         * @instance
         */
        CirculatorProgram.prototype.programType = 0;
    
        /**
         * CirculatorProgram programMetadata.
         * @member {(IProgramMetadata|null|undefined)}programMetadata
         * @memberof CirculatorProgram
         * @instance
         */
        CirculatorProgram.prototype.programMetadata = null;
    
        /**
         * Creates a new CirculatorProgram instance using the specified properties.
         * @function create
         * @memberof CirculatorProgram
         * @static
         * @param {ICirculatorProgram=} [properties] Properties to set
         * @returns {CirculatorProgram} CirculatorProgram instance
         */
        CirculatorProgram.create = function create(properties) {
            return new CirculatorProgram(properties);
        };
    
        /**
         * Encodes the specified CirculatorProgram message. Does not implicitly {@link CirculatorProgram.verify|verify} messages.
         * @function encode
         * @memberof CirculatorProgram
         * @static
         * @param {ICirculatorProgram} message CirculatorProgram message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CirculatorProgram.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.setPoint);
            if (message.cookTime != null && message.hasOwnProperty("cookTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cookTime);
            if (message.delayedStart != null && message.hasOwnProperty("delayedStart"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.delayedStart);
            if (message.holdingTemperature != null && message.hasOwnProperty("holdingTemperature"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.holdingTemperature);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.programType);
            if (message.programMetadata != null && message.hasOwnProperty("programMetadata"))
                $root.ProgramMetadata.encode(message.programMetadata, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified CirculatorProgram message, length delimited. Does not implicitly {@link CirculatorProgram.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CirculatorProgram
         * @static
         * @param {ICirculatorProgram} message CirculatorProgram message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CirculatorProgram.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CirculatorProgram message from the specified reader or buffer.
         * @function decode
         * @memberof CirculatorProgram
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CirculatorProgram} CirculatorProgram
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CirculatorProgram.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CirculatorProgram();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.setPoint = reader.float();
                    break;
                case 2:
                    message.cookTime = reader.uint32();
                    break;
                case 3:
                    message.delayedStart = reader.uint32();
                    break;
                case 4:
                    message.holdingTemperature = reader.float();
                    break;
                case 5:
                    message.programType = reader.int32();
                    break;
                case 6:
                    message.programMetadata = $root.ProgramMetadata.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("setPoint"))
                throw $util.ProtocolError("missing required 'setPoint'", { instance: message });
            if (!message.hasOwnProperty("programType"))
                throw $util.ProtocolError("missing required 'programType'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CirculatorProgram message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CirculatorProgram
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CirculatorProgram} CirculatorProgram
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CirculatorProgram.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CirculatorProgram message.
         * @function verify
         * @memberof CirculatorProgram
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CirculatorProgram.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.setPoint !== "number")
                return "setPoint: number expected";
            if (message.cookTime != null && message.hasOwnProperty("cookTime"))
                if (!$util.isInteger(message.cookTime))
                    return "cookTime: integer expected";
            if (message.delayedStart != null && message.hasOwnProperty("delayedStart"))
                if (!$util.isInteger(message.delayedStart))
                    return "delayedStart: integer expected";
            if (message.holdingTemperature != null && message.hasOwnProperty("holdingTemperature"))
                if (typeof message.holdingTemperature !== "number")
                    return "holdingTemperature: number expected";
            switch (message.programType) {
            default:
                return "programType: enum value expected";
            case 0:
            case 1:
                break;
            }
            if (message.programMetadata != null && message.hasOwnProperty("programMetadata")) {
                var error = $root.ProgramMetadata.verify(message.programMetadata);
                if (error)
                    return "programMetadata." + error;
            }
            return null;
        };
    
        /**
         * Creates a CirculatorProgram message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CirculatorProgram
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CirculatorProgram} CirculatorProgram
         */
        CirculatorProgram.fromObject = function fromObject(object) {
            if (object instanceof $root.CirculatorProgram)
                return object;
            var message = new $root.CirculatorProgram();
            if (object.setPoint != null)
                message.setPoint = Number(object.setPoint);
            if (object.cookTime != null)
                message.cookTime = object.cookTime >>> 0;
            if (object.delayedStart != null)
                message.delayedStart = object.delayedStart >>> 0;
            if (object.holdingTemperature != null)
                message.holdingTemperature = Number(object.holdingTemperature);
            switch (object.programType) {
            case "MANUAL":
            case 0:
                message.programType = 0;
                break;
            case "AUTOMATIC":
            case 1:
                message.programType = 1;
                break;
            }
            if (object.programMetadata != null) {
                if (typeof object.programMetadata !== "object")
                    throw TypeError(".CirculatorProgram.programMetadata: object expected");
                message.programMetadata = $root.ProgramMetadata.fromObject(object.programMetadata);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CirculatorProgram message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CirculatorProgram
         * @static
         * @param {CirculatorProgram} message CirculatorProgram
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CirculatorProgram.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.setPoint = 0;
                object.cookTime = 0;
                object.delayedStart = 0;
                object.holdingTemperature = 0;
                object.programType = options.enums === String ? "MANUAL" : 0;
                object.programMetadata = null;
            }
            if (message.setPoint != null && message.hasOwnProperty("setPoint"))
                object.setPoint = options.json && !isFinite(message.setPoint) ? String(message.setPoint) : message.setPoint;
            if (message.cookTime != null && message.hasOwnProperty("cookTime"))
                object.cookTime = message.cookTime;
            if (message.delayedStart != null && message.hasOwnProperty("delayedStart"))
                object.delayedStart = message.delayedStart;
            if (message.holdingTemperature != null && message.hasOwnProperty("holdingTemperature"))
                object.holdingTemperature = options.json && !isFinite(message.holdingTemperature) ? String(message.holdingTemperature) : message.holdingTemperature;
            if (message.programType != null && message.hasOwnProperty("programType"))
                object.programType = options.enums === String ? $root.ProgramType[message.programType] : message.programType;
            if (message.programMetadata != null && message.hasOwnProperty("programMetadata"))
                object.programMetadata = $root.ProgramMetadata.toObject(message.programMetadata, options);
            return object;
        };
    
        /**
         * Converts this CirculatorProgram to JSON.
         * @function toJSON
         * @memberof CirculatorProgram
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CirculatorProgram.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CirculatorProgram;
    })();
    
    /**
     * ProgramType enum.
     * @exports ProgramType
     * @enum {string}
     * @property {number} MANUAL=0 MANUAL value
     * @property {number} AUTOMATIC=1 AUTOMATIC value
     */
    $root.ProgramType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MANUAL"] = 0;
        values[valuesById[1] = "AUTOMATIC"] = 1;
        return values;
    })();
    
    /**
     * ProgramStep enum.
     * @exports ProgramStep
     * @enum {string}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} PRE_HEAT=1 PRE_HEAT value
     * @property {number} WAIT_FOR_FOOD=2 WAIT_FOR_FOOD value
     * @property {number} COOK=3 COOK value
     * @property {number} WAIT_FOR_REMOVE_FOOD=4 WAIT_FOR_REMOVE_FOOD value
     * @property {number} ERROR=5 ERROR value
     */
    $root.ProgramStep = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "PRE_HEAT"] = 1;
        values[valuesById[2] = "WAIT_FOR_FOOD"] = 2;
        values[valuesById[3] = "COOK"] = 3;
        values[valuesById[4] = "WAIT_FOR_REMOVE_FOOD"] = 4;
        values[valuesById[5] = "ERROR"] = 5;
        return values;
    })();
    
    $root.ProgramMetadata = (function() {
    
        /**
         * Properties of a ProgramMetadata.
         * @exports IProgramMetadata
         * @interface IProgramMetadata
         * @property {string} [guideId] ProgramMetadata guideId
         * @property {string} [programId] ProgramMetadata programId
         * @property {string} [timerId] ProgramMetadata timerId
         * @property {string} [cookId] ProgramMetadata cookId
         */
    
        /**
         * Constructs a new ProgramMetadata.
         * @exports ProgramMetadata
         * @classdesc Represents a ProgramMetadata.
         * @constructor
         * @param {IProgramMetadata=} [properties] Properties to set
         */
        function ProgramMetadata(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ProgramMetadata guideId.
         * @member {string}guideId
         * @memberof ProgramMetadata
         * @instance
         */
        ProgramMetadata.prototype.guideId = "";
    
        /**
         * ProgramMetadata programId.
         * @member {string}programId
         * @memberof ProgramMetadata
         * @instance
         */
        ProgramMetadata.prototype.programId = "";
    
        /**
         * ProgramMetadata timerId.
         * @member {string}timerId
         * @memberof ProgramMetadata
         * @instance
         */
        ProgramMetadata.prototype.timerId = "";
    
        /**
         * ProgramMetadata cookId.
         * @member {string}cookId
         * @memberof ProgramMetadata
         * @instance
         */
        ProgramMetadata.prototype.cookId = "";
    
        /**
         * Creates a new ProgramMetadata instance using the specified properties.
         * @function create
         * @memberof ProgramMetadata
         * @static
         * @param {IProgramMetadata=} [properties] Properties to set
         * @returns {ProgramMetadata} ProgramMetadata instance
         */
        ProgramMetadata.create = function create(properties) {
            return new ProgramMetadata(properties);
        };
    
        /**
         * Encodes the specified ProgramMetadata message. Does not implicitly {@link ProgramMetadata.verify|verify} messages.
         * @function encode
         * @memberof ProgramMetadata
         * @static
         * @param {IProgramMetadata} message ProgramMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProgramMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.guideId != null && message.hasOwnProperty("guideId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.guideId);
            if (message.programId != null && message.hasOwnProperty("programId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.programId);
            if (message.timerId != null && message.hasOwnProperty("timerId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.timerId);
            if (message.cookId != null && message.hasOwnProperty("cookId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.cookId);
            return writer;
        };
    
        /**
         * Encodes the specified ProgramMetadata message, length delimited. Does not implicitly {@link ProgramMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ProgramMetadata
         * @static
         * @param {IProgramMetadata} message ProgramMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProgramMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ProgramMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof ProgramMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ProgramMetadata} ProgramMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProgramMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProgramMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.guideId = reader.string();
                    break;
                case 2:
                    message.programId = reader.string();
                    break;
                case 3:
                    message.timerId = reader.string();
                    break;
                case 4:
                    message.cookId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ProgramMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ProgramMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ProgramMetadata} ProgramMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProgramMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ProgramMetadata message.
         * @function verify
         * @memberof ProgramMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProgramMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.guideId != null && message.hasOwnProperty("guideId"))
                if (!$util.isString(message.guideId))
                    return "guideId: string expected";
            if (message.programId != null && message.hasOwnProperty("programId"))
                if (!$util.isString(message.programId))
                    return "programId: string expected";
            if (message.timerId != null && message.hasOwnProperty("timerId"))
                if (!$util.isString(message.timerId))
                    return "timerId: string expected";
            if (message.cookId != null && message.hasOwnProperty("cookId"))
                if (!$util.isString(message.cookId))
                    return "cookId: string expected";
            return null;
        };
    
        /**
         * Creates a ProgramMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ProgramMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ProgramMetadata} ProgramMetadata
         */
        ProgramMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.ProgramMetadata)
                return object;
            var message = new $root.ProgramMetadata();
            if (object.guideId != null)
                message.guideId = String(object.guideId);
            if (object.programId != null)
                message.programId = String(object.programId);
            if (object.timerId != null)
                message.timerId = String(object.timerId);
            if (object.cookId != null)
                message.cookId = String(object.cookId);
            return message;
        };
    
        /**
         * Creates a plain object from a ProgramMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ProgramMetadata
         * @static
         * @param {ProgramMetadata} message ProgramMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProgramMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.guideId = "";
                object.programId = "";
                object.timerId = "";
                object.cookId = "";
            }
            if (message.guideId != null && message.hasOwnProperty("guideId"))
                object.guideId = message.guideId;
            if (message.programId != null && message.hasOwnProperty("programId"))
                object.programId = message.programId;
            if (message.timerId != null && message.hasOwnProperty("timerId"))
                object.timerId = message.timerId;
            if (message.cookId != null && message.hasOwnProperty("cookId"))
                object.cookId = message.cookId;
            return object;
        };
    
        /**
         * Converts this ProgramMetadata to JSON.
         * @function toJSON
         * @memberof ProgramMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProgramMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ProgramMetadata;
    })();
    
    /**
     * ErrorState enum.
     * @exports ErrorState
     * @enum {string}
     * @property {number} NO_ERROR=0 NO_ERROR value
     * @property {number} SOFT_ERROR=1 SOFT_ERROR value
     * @property {number} HARD_ERROR=2 HARD_ERROR value
     */
    $root.ErrorState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_ERROR"] = 0;
        values[valuesById[1] = "SOFT_ERROR"] = 1;
        values[valuesById[2] = "HARD_ERROR"] = 2;
        return values;
    })();
    
    /**
     * LedColor enum.
     * @exports LedColor
     * @enum {string}
     * @property {number} LED_COLOR_RED=0 LED_COLOR_RED value
     * @property {number} LED_COLOR_GREEN=1 LED_COLOR_GREEN value
     * @property {number} LED_COLOR_BLUE=2 LED_COLOR_BLUE value
     * @property {number} LED_COLOR_WHITE=3 LED_COLOR_WHITE value
     * @property {number} LED_COLOR_ORANGE=4 LED_COLOR_ORANGE value
     * @property {number} LED_COLOR_YELLOW=5 LED_COLOR_YELLOW value
     * @property {number} LED_COLOR_BLACK=6 LED_COLOR_BLACK value
     * @property {number} LED_COLOR_PURPLE=7 LED_COLOR_PURPLE value
     */
    $root.LedColor = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LED_COLOR_RED"] = 0;
        values[valuesById[1] = "LED_COLOR_GREEN"] = 1;
        values[valuesById[2] = "LED_COLOR_BLUE"] = 2;
        values[valuesById[3] = "LED_COLOR_WHITE"] = 3;
        values[valuesById[4] = "LED_COLOR_ORANGE"] = 4;
        values[valuesById[5] = "LED_COLOR_YELLOW"] = 5;
        values[valuesById[6] = "LED_COLOR_BLACK"] = 6;
        values[valuesById[7] = "LED_COLOR_PURPLE"] = 7;
        return values;
    })();
    
    /**
     * LedPattern enum.
     * @exports LedPattern
     * @enum {string}
     * @property {number} LED_PATTERN_BLINK=0 LED_PATTERN_BLINK value
     * @property {number} LED_PATTERN_BREATHE=1 LED_PATTERN_BREATHE value
     * @property {number} LED_PATTERN_DOUBLE_BLINK=2 LED_PATTERN_DOUBLE_BLINK value
     * @property {number} LED_PATTERN_DOUBLE_PULSE=3 LED_PATTERN_DOUBLE_PULSE value
     * @property {number} LED_PATTERN_SOLID=4 LED_PATTERN_SOLID value
     */
    $root.LedPattern = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LED_PATTERN_BLINK"] = 0;
        values[valuesById[1] = "LED_PATTERN_BREATHE"] = 1;
        values[valuesById[2] = "LED_PATTERN_DOUBLE_BLINK"] = 2;
        values[valuesById[3] = "LED_PATTERN_DOUBLE_PULSE"] = 3;
        values[valuesById[4] = "LED_PATTERN_SOLID"] = 4;
        return values;
    })();
    
    $root.StartProgramRequest = (function() {
    
        /**
         * Properties of a StartProgramRequest.
         * @exports IStartProgramRequest
         * @interface IStartProgramRequest
         * @property {ICirculatorProgram} circulatorProgram StartProgramRequest circulatorProgram
         * @property {number} [feedId] StartProgramRequest feedId
         * @property {number} [sequenceNumber] StartProgramRequest sequenceNumber
         */
    
        /**
         * Constructs a new StartProgramRequest.
         * @exports StartProgramRequest
         * @classdesc Represents a StartProgramRequest.
         * @constructor
         * @param {IStartProgramRequest=} [properties] Properties to set
         */
        function StartProgramRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * StartProgramRequest circulatorProgram.
         * @member {ICirculatorProgram}circulatorProgram
         * @memberof StartProgramRequest
         * @instance
         */
        StartProgramRequest.prototype.circulatorProgram = null;
    
        /**
         * StartProgramRequest feedId.
         * @member {number}feedId
         * @memberof StartProgramRequest
         * @instance
         */
        StartProgramRequest.prototype.feedId = 0;
    
        /**
         * StartProgramRequest sequenceNumber.
         * @member {number}sequenceNumber
         * @memberof StartProgramRequest
         * @instance
         */
        StartProgramRequest.prototype.sequenceNumber = 0;
    
        /**
         * Creates a new StartProgramRequest instance using the specified properties.
         * @function create
         * @memberof StartProgramRequest
         * @static
         * @param {IStartProgramRequest=} [properties] Properties to set
         * @returns {StartProgramRequest} StartProgramRequest instance
         */
        StartProgramRequest.create = function create(properties) {
            return new StartProgramRequest(properties);
        };
    
        /**
         * Encodes the specified StartProgramRequest message. Does not implicitly {@link StartProgramRequest.verify|verify} messages.
         * @function encode
         * @memberof StartProgramRequest
         * @static
         * @param {IStartProgramRequest} message StartProgramRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartProgramRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.CirculatorProgram.encode(message.circulatorProgram, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.feedId);
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.sequenceNumber);
            return writer;
        };
    
        /**
         * Encodes the specified StartProgramRequest message, length delimited. Does not implicitly {@link StartProgramRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof StartProgramRequest
         * @static
         * @param {IStartProgramRequest} message StartProgramRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartProgramRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a StartProgramRequest message from the specified reader or buffer.
         * @function decode
         * @memberof StartProgramRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {StartProgramRequest} StartProgramRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartProgramRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartProgramRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.circulatorProgram = $root.CirculatorProgram.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.feedId = reader.uint32();
                    break;
                case 3:
                    message.sequenceNumber = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("circulatorProgram"))
                throw $util.ProtocolError("missing required 'circulatorProgram'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a StartProgramRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof StartProgramRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {StartProgramRequest} StartProgramRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartProgramRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a StartProgramRequest message.
         * @function verify
         * @memberof StartProgramRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartProgramRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var error = $root.CirculatorProgram.verify(message.circulatorProgram);
            if (error)
                return "circulatorProgram." + error;
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                if (!$util.isInteger(message.feedId))
                    return "feedId: integer expected";
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                if (!$util.isInteger(message.sequenceNumber))
                    return "sequenceNumber: integer expected";
            return null;
        };
    
        /**
         * Creates a StartProgramRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof StartProgramRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {StartProgramRequest} StartProgramRequest
         */
        StartProgramRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.StartProgramRequest)
                return object;
            var message = new $root.StartProgramRequest();
            if (object.circulatorProgram != null) {
                if (typeof object.circulatorProgram !== "object")
                    throw TypeError(".StartProgramRequest.circulatorProgram: object expected");
                message.circulatorProgram = $root.CirculatorProgram.fromObject(object.circulatorProgram);
            }
            if (object.feedId != null)
                message.feedId = object.feedId >>> 0;
            if (object.sequenceNumber != null)
                message.sequenceNumber = object.sequenceNumber >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a StartProgramRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof StartProgramRequest
         * @static
         * @param {StartProgramRequest} message StartProgramRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartProgramRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.circulatorProgram = null;
                object.feedId = 0;
                object.sequenceNumber = 0;
            }
            if (message.circulatorProgram != null && message.hasOwnProperty("circulatorProgram"))
                object.circulatorProgram = $root.CirculatorProgram.toObject(message.circulatorProgram, options);
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                object.feedId = message.feedId;
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                object.sequenceNumber = message.sequenceNumber;
            return object;
        };
    
        /**
         * Converts this StartProgramRequest to JSON.
         * @function toJSON
         * @memberof StartProgramRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartProgramRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return StartProgramRequest;
    })();
    
    $root.StartProgramReply = (function() {
    
        /**
         * Properties of a StartProgramReply.
         * @exports IStartProgramReply
         * @interface IStartProgramReply
         * @property {Result} [result] StartProgramReply result
         */
    
        /**
         * Constructs a new StartProgramReply.
         * @exports StartProgramReply
         * @classdesc Represents a StartProgramReply.
         * @constructor
         * @param {IStartProgramReply=} [properties] Properties to set
         */
        function StartProgramReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * StartProgramReply result.
         * @member {Result}result
         * @memberof StartProgramReply
         * @instance
         */
        StartProgramReply.prototype.result = 0;
    
        /**
         * Creates a new StartProgramReply instance using the specified properties.
         * @function create
         * @memberof StartProgramReply
         * @static
         * @param {IStartProgramReply=} [properties] Properties to set
         * @returns {StartProgramReply} StartProgramReply instance
         */
        StartProgramReply.create = function create(properties) {
            return new StartProgramReply(properties);
        };
    
        /**
         * Encodes the specified StartProgramReply message. Does not implicitly {@link StartProgramReply.verify|verify} messages.
         * @function encode
         * @memberof StartProgramReply
         * @static
         * @param {IStartProgramReply} message StartProgramReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartProgramReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified StartProgramReply message, length delimited. Does not implicitly {@link StartProgramReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof StartProgramReply
         * @static
         * @param {IStartProgramReply} message StartProgramReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartProgramReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a StartProgramReply message from the specified reader or buffer.
         * @function decode
         * @memberof StartProgramReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {StartProgramReply} StartProgramReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartProgramReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartProgramReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a StartProgramReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof StartProgramReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {StartProgramReply} StartProgramReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartProgramReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a StartProgramReply message.
         * @function verify
         * @memberof StartProgramReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartProgramReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a StartProgramReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof StartProgramReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {StartProgramReply} StartProgramReply
         */
        StartProgramReply.fromObject = function fromObject(object) {
            if (object instanceof $root.StartProgramReply)
                return object;
            var message = new $root.StartProgramReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a StartProgramReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof StartProgramReply
         * @static
         * @param {StartProgramReply} message StartProgramReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartProgramReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this StartProgramReply to JSON.
         * @function toJSON
         * @memberof StartProgramReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartProgramReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return StartProgramReply;
    })();
    
    $root.StopCirculatorRequest = (function() {
    
        /**
         * Properties of a StopCirculatorRequest.
         * @exports IStopCirculatorRequest
         * @interface IStopCirculatorRequest
         * @property {number} [feedId] StopCirculatorRequest feedId
         * @property {number} [sequenceNumber] StopCirculatorRequest sequenceNumber
         */
    
        /**
         * Constructs a new StopCirculatorRequest.
         * @exports StopCirculatorRequest
         * @classdesc Represents a StopCirculatorRequest.
         * @constructor
         * @param {IStopCirculatorRequest=} [properties] Properties to set
         */
        function StopCirculatorRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * StopCirculatorRequest feedId.
         * @member {number}feedId
         * @memberof StopCirculatorRequest
         * @instance
         */
        StopCirculatorRequest.prototype.feedId = 0;
    
        /**
         * StopCirculatorRequest sequenceNumber.
         * @member {number}sequenceNumber
         * @memberof StopCirculatorRequest
         * @instance
         */
        StopCirculatorRequest.prototype.sequenceNumber = 0;
    
        /**
         * Creates a new StopCirculatorRequest instance using the specified properties.
         * @function create
         * @memberof StopCirculatorRequest
         * @static
         * @param {IStopCirculatorRequest=} [properties] Properties to set
         * @returns {StopCirculatorRequest} StopCirculatorRequest instance
         */
        StopCirculatorRequest.create = function create(properties) {
            return new StopCirculatorRequest(properties);
        };
    
        /**
         * Encodes the specified StopCirculatorRequest message. Does not implicitly {@link StopCirculatorRequest.verify|verify} messages.
         * @function encode
         * @memberof StopCirculatorRequest
         * @static
         * @param {IStopCirculatorRequest} message StopCirculatorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopCirculatorRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.feedId);
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.sequenceNumber);
            return writer;
        };
    
        /**
         * Encodes the specified StopCirculatorRequest message, length delimited. Does not implicitly {@link StopCirculatorRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof StopCirculatorRequest
         * @static
         * @param {IStopCirculatorRequest} message StopCirculatorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopCirculatorRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a StopCirculatorRequest message from the specified reader or buffer.
         * @function decode
         * @memberof StopCirculatorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {StopCirculatorRequest} StopCirculatorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopCirculatorRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StopCirculatorRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.feedId = reader.uint32();
                    break;
                case 3:
                    message.sequenceNumber = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a StopCirculatorRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof StopCirculatorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {StopCirculatorRequest} StopCirculatorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopCirculatorRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a StopCirculatorRequest message.
         * @function verify
         * @memberof StopCirculatorRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopCirculatorRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                if (!$util.isInteger(message.feedId))
                    return "feedId: integer expected";
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                if (!$util.isInteger(message.sequenceNumber))
                    return "sequenceNumber: integer expected";
            return null;
        };
    
        /**
         * Creates a StopCirculatorRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof StopCirculatorRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {StopCirculatorRequest} StopCirculatorRequest
         */
        StopCirculatorRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.StopCirculatorRequest)
                return object;
            var message = new $root.StopCirculatorRequest();
            if (object.feedId != null)
                message.feedId = object.feedId >>> 0;
            if (object.sequenceNumber != null)
                message.sequenceNumber = object.sequenceNumber >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a StopCirculatorRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof StopCirculatorRequest
         * @static
         * @param {StopCirculatorRequest} message StopCirculatorRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopCirculatorRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.feedId = 0;
                object.sequenceNumber = 0;
            }
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                object.feedId = message.feedId;
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                object.sequenceNumber = message.sequenceNumber;
            return object;
        };
    
        /**
         * Converts this StopCirculatorRequest to JSON.
         * @function toJSON
         * @memberof StopCirculatorRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopCirculatorRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return StopCirculatorRequest;
    })();
    
    $root.StopCirculatorReply = (function() {
    
        /**
         * Properties of a StopCirculatorReply.
         * @exports IStopCirculatorReply
         * @interface IStopCirculatorReply
         * @property {Result} [result] StopCirculatorReply result
         */
    
        /**
         * Constructs a new StopCirculatorReply.
         * @exports StopCirculatorReply
         * @classdesc Represents a StopCirculatorReply.
         * @constructor
         * @param {IStopCirculatorReply=} [properties] Properties to set
         */
        function StopCirculatorReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * StopCirculatorReply result.
         * @member {Result}result
         * @memberof StopCirculatorReply
         * @instance
         */
        StopCirculatorReply.prototype.result = 0;
    
        /**
         * Creates a new StopCirculatorReply instance using the specified properties.
         * @function create
         * @memberof StopCirculatorReply
         * @static
         * @param {IStopCirculatorReply=} [properties] Properties to set
         * @returns {StopCirculatorReply} StopCirculatorReply instance
         */
        StopCirculatorReply.create = function create(properties) {
            return new StopCirculatorReply(properties);
        };
    
        /**
         * Encodes the specified StopCirculatorReply message. Does not implicitly {@link StopCirculatorReply.verify|verify} messages.
         * @function encode
         * @memberof StopCirculatorReply
         * @static
         * @param {IStopCirculatorReply} message StopCirculatorReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopCirculatorReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified StopCirculatorReply message, length delimited. Does not implicitly {@link StopCirculatorReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof StopCirculatorReply
         * @static
         * @param {IStopCirculatorReply} message StopCirculatorReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopCirculatorReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a StopCirculatorReply message from the specified reader or buffer.
         * @function decode
         * @memberof StopCirculatorReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {StopCirculatorReply} StopCirculatorReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopCirculatorReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StopCirculatorReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a StopCirculatorReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof StopCirculatorReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {StopCirculatorReply} StopCirculatorReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopCirculatorReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a StopCirculatorReply message.
         * @function verify
         * @memberof StopCirculatorReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopCirculatorReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a StopCirculatorReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof StopCirculatorReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {StopCirculatorReply} StopCirculatorReply
         */
        StopCirculatorReply.fromObject = function fromObject(object) {
            if (object instanceof $root.StopCirculatorReply)
                return object;
            var message = new $root.StopCirculatorReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a StopCirculatorReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof StopCirculatorReply
         * @static
         * @param {StopCirculatorReply} message StopCirculatorReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopCirculatorReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this StopCirculatorReply to JSON.
         * @function toJSON
         * @memberof StopCirculatorReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopCirculatorReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return StopCirculatorReply;
    })();
    
    $root.DropFoodRequest = (function() {
    
        /**
         * Properties of a DropFoodRequest.
         * @exports IDropFoodRequest
         * @interface IDropFoodRequest
         */
    
        /**
         * Constructs a new DropFoodRequest.
         * @exports DropFoodRequest
         * @classdesc Represents a DropFoodRequest.
         * @constructor
         * @param {IDropFoodRequest=} [properties] Properties to set
         */
        function DropFoodRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new DropFoodRequest instance using the specified properties.
         * @function create
         * @memberof DropFoodRequest
         * @static
         * @param {IDropFoodRequest=} [properties] Properties to set
         * @returns {DropFoodRequest} DropFoodRequest instance
         */
        DropFoodRequest.create = function create(properties) {
            return new DropFoodRequest(properties);
        };
    
        /**
         * Encodes the specified DropFoodRequest message. Does not implicitly {@link DropFoodRequest.verify|verify} messages.
         * @function encode
         * @memberof DropFoodRequest
         * @static
         * @param {IDropFoodRequest} message DropFoodRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DropFoodRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified DropFoodRequest message, length delimited. Does not implicitly {@link DropFoodRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DropFoodRequest
         * @static
         * @param {IDropFoodRequest} message DropFoodRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DropFoodRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a DropFoodRequest message from the specified reader or buffer.
         * @function decode
         * @memberof DropFoodRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DropFoodRequest} DropFoodRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DropFoodRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DropFoodRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a DropFoodRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DropFoodRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DropFoodRequest} DropFoodRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DropFoodRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a DropFoodRequest message.
         * @function verify
         * @memberof DropFoodRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DropFoodRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a DropFoodRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DropFoodRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DropFoodRequest} DropFoodRequest
         */
        DropFoodRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.DropFoodRequest)
                return object;
            return new $root.DropFoodRequest();
        };
    
        /**
         * Creates a plain object from a DropFoodRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DropFoodRequest
         * @static
         * @param {DropFoodRequest} message DropFoodRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DropFoodRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this DropFoodRequest to JSON.
         * @function toJSON
         * @memberof DropFoodRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DropFoodRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return DropFoodRequest;
    })();
    
    $root.DropFoodReply = (function() {
    
        /**
         * Properties of a DropFoodReply.
         * @exports IDropFoodReply
         * @interface IDropFoodReply
         * @property {Result} [result] DropFoodReply result
         */
    
        /**
         * Constructs a new DropFoodReply.
         * @exports DropFoodReply
         * @classdesc Represents a DropFoodReply.
         * @constructor
         * @param {IDropFoodReply=} [properties] Properties to set
         */
        function DropFoodReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * DropFoodReply result.
         * @member {Result}result
         * @memberof DropFoodReply
         * @instance
         */
        DropFoodReply.prototype.result = 0;
    
        /**
         * Creates a new DropFoodReply instance using the specified properties.
         * @function create
         * @memberof DropFoodReply
         * @static
         * @param {IDropFoodReply=} [properties] Properties to set
         * @returns {DropFoodReply} DropFoodReply instance
         */
        DropFoodReply.create = function create(properties) {
            return new DropFoodReply(properties);
        };
    
        /**
         * Encodes the specified DropFoodReply message. Does not implicitly {@link DropFoodReply.verify|verify} messages.
         * @function encode
         * @memberof DropFoodReply
         * @static
         * @param {IDropFoodReply} message DropFoodReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DropFoodReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified DropFoodReply message, length delimited. Does not implicitly {@link DropFoodReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DropFoodReply
         * @static
         * @param {IDropFoodReply} message DropFoodReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DropFoodReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a DropFoodReply message from the specified reader or buffer.
         * @function decode
         * @memberof DropFoodReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DropFoodReply} DropFoodReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DropFoodReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DropFoodReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a DropFoodReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DropFoodReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DropFoodReply} DropFoodReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DropFoodReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a DropFoodReply message.
         * @function verify
         * @memberof DropFoodReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DropFoodReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a DropFoodReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DropFoodReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DropFoodReply} DropFoodReply
         */
        DropFoodReply.fromObject = function fromObject(object) {
            if (object instanceof $root.DropFoodReply)
                return object;
            var message = new $root.DropFoodReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a DropFoodReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DropFoodReply
         * @static
         * @param {DropFoodReply} message DropFoodReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DropFoodReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this DropFoodReply to JSON.
         * @function toJSON
         * @memberof DropFoodReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DropFoodReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return DropFoodReply;
    })();
    
    /**
     * EventType enum.
     * @exports EventType
     * @enum {string}
     * @property {number} NO_EVENT=0 NO_EVENT value
     * @property {number} HW_FAILURE=1 HW_FAILURE value
     * @property {number} STOP_PROGRAM=2 STOP_PROGRAM value
     */
    $root.EventType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_EVENT"] = 0;
        values[valuesById[1] = "HW_FAILURE"] = 1;
        values[valuesById[2] = "STOP_PROGRAM"] = 2;
        return values;
    })();
    
    /**
     * EventReason enum.
     * @exports EventReason
     * @enum {string}
     * @property {number} NO_REASON=0 NO_REASON value
     * @property {number} HARDWARE_FAILURE=1 HARDWARE_FAILURE value
     * @property {number} BUTTON_PRESSED=2 BUTTON_PRESSED value
     * @property {number} LOW_WATER_LEVEL=3 LOW_WATER_LEVEL value
     * @property {number} TIPPED_OVER=4 TIPPED_OVER value
     * @property {number} OVERHEATING=5 OVERHEATING value
     * @property {number} POWER_LOSS=6 POWER_LOSS value
     * @property {number} HEATER_THERMISTOR=7 HEATER_THERMISTOR value
     * @property {number} BATH_THERMISTOR=8 BATH_THERMISTOR value
     * @property {number} PRESSURE_SENSOR=9 PRESSURE_SENSOR value
     * @property {number} ACCELEROMETER=10 ACCELEROMETER value
     * @property {number} BAD_MOTOR=11 BAD_MOTOR value
     * @property {number} STUCK_MOTOR=12 STUCK_MOTOR value
     * @property {number} BAD_HEATER=13 BAD_HEATER value
     */
    $root.EventReason = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_REASON"] = 0;
        values[valuesById[1] = "HARDWARE_FAILURE"] = 1;
        values[valuesById[2] = "BUTTON_PRESSED"] = 2;
        values[valuesById[3] = "LOW_WATER_LEVEL"] = 3;
        values[valuesById[4] = "TIPPED_OVER"] = 4;
        values[valuesById[5] = "OVERHEATING"] = 5;
        values[valuesById[6] = "POWER_LOSS"] = 6;
        values[valuesById[7] = "HEATER_THERMISTOR"] = 7;
        values[valuesById[8] = "BATH_THERMISTOR"] = 8;
        values[valuesById[9] = "PRESSURE_SENSOR"] = 9;
        values[valuesById[10] = "ACCELEROMETER"] = 10;
        values[valuesById[11] = "BAD_MOTOR"] = 11;
        values[valuesById[12] = "STUCK_MOTOR"] = 12;
        values[valuesById[13] = "BAD_HEATER"] = 13;
        return values;
    })();
    
    $root.ListRecentEventsRequest = (function() {
    
        /**
         * Properties of a ListRecentEventsRequest.
         * @exports IListRecentEventsRequest
         * @interface IListRecentEventsRequest
         */
    
        /**
         * Constructs a new ListRecentEventsRequest.
         * @exports ListRecentEventsRequest
         * @classdesc Represents a ListRecentEventsRequest.
         * @constructor
         * @param {IListRecentEventsRequest=} [properties] Properties to set
         */
        function ListRecentEventsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new ListRecentEventsRequest instance using the specified properties.
         * @function create
         * @memberof ListRecentEventsRequest
         * @static
         * @param {IListRecentEventsRequest=} [properties] Properties to set
         * @returns {ListRecentEventsRequest} ListRecentEventsRequest instance
         */
        ListRecentEventsRequest.create = function create(properties) {
            return new ListRecentEventsRequest(properties);
        };
    
        /**
         * Encodes the specified ListRecentEventsRequest message. Does not implicitly {@link ListRecentEventsRequest.verify|verify} messages.
         * @function encode
         * @memberof ListRecentEventsRequest
         * @static
         * @param {IListRecentEventsRequest} message ListRecentEventsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListRecentEventsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified ListRecentEventsRequest message, length delimited. Does not implicitly {@link ListRecentEventsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ListRecentEventsRequest
         * @static
         * @param {IListRecentEventsRequest} message ListRecentEventsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListRecentEventsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ListRecentEventsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ListRecentEventsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ListRecentEventsRequest} ListRecentEventsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListRecentEventsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListRecentEventsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ListRecentEventsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ListRecentEventsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ListRecentEventsRequest} ListRecentEventsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListRecentEventsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ListRecentEventsRequest message.
         * @function verify
         * @memberof ListRecentEventsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListRecentEventsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a ListRecentEventsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ListRecentEventsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ListRecentEventsRequest} ListRecentEventsRequest
         */
        ListRecentEventsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ListRecentEventsRequest)
                return object;
            return new $root.ListRecentEventsRequest();
        };
    
        /**
         * Creates a plain object from a ListRecentEventsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ListRecentEventsRequest
         * @static
         * @param {ListRecentEventsRequest} message ListRecentEventsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListRecentEventsRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this ListRecentEventsRequest to JSON.
         * @function toJSON
         * @memberof ListRecentEventsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListRecentEventsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ListRecentEventsRequest;
    })();
    
    $root.ListRecentEventsReply = (function() {
    
        /**
         * Properties of a ListRecentEventsReply.
         * @exports IListRecentEventsReply
         * @interface IListRecentEventsReply
         * @property {EventType} eventType ListRecentEventsReply eventType
         * @property {EventReason} eventReason ListRecentEventsReply eventReason
         * @property {number} eventTimestamp ListRecentEventsReply eventTimestamp
         * @property {number} [feedId] ListRecentEventsReply feedId
         * @property {number} [sequenceNumber] ListRecentEventsReply sequenceNumber
         */
    
        /**
         * Constructs a new ListRecentEventsReply.
         * @exports ListRecentEventsReply
         * @classdesc Represents a ListRecentEventsReply.
         * @constructor
         * @param {IListRecentEventsReply=} [properties] Properties to set
         */
        function ListRecentEventsReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ListRecentEventsReply eventType.
         * @member {EventType}eventType
         * @memberof ListRecentEventsReply
         * @instance
         */
        ListRecentEventsReply.prototype.eventType = 0;
    
        /**
         * ListRecentEventsReply eventReason.
         * @member {EventReason}eventReason
         * @memberof ListRecentEventsReply
         * @instance
         */
        ListRecentEventsReply.prototype.eventReason = 0;
    
        /**
         * ListRecentEventsReply eventTimestamp.
         * @member {number}eventTimestamp
         * @memberof ListRecentEventsReply
         * @instance
         */
        ListRecentEventsReply.prototype.eventTimestamp = 0;
    
        /**
         * ListRecentEventsReply feedId.
         * @member {number}feedId
         * @memberof ListRecentEventsReply
         * @instance
         */
        ListRecentEventsReply.prototype.feedId = 0;
    
        /**
         * ListRecentEventsReply sequenceNumber.
         * @member {number}sequenceNumber
         * @memberof ListRecentEventsReply
         * @instance
         */
        ListRecentEventsReply.prototype.sequenceNumber = 0;
    
        /**
         * Creates a new ListRecentEventsReply instance using the specified properties.
         * @function create
         * @memberof ListRecentEventsReply
         * @static
         * @param {IListRecentEventsReply=} [properties] Properties to set
         * @returns {ListRecentEventsReply} ListRecentEventsReply instance
         */
        ListRecentEventsReply.create = function create(properties) {
            return new ListRecentEventsReply(properties);
        };
    
        /**
         * Encodes the specified ListRecentEventsReply message. Does not implicitly {@link ListRecentEventsReply.verify|verify} messages.
         * @function encode
         * @memberof ListRecentEventsReply
         * @static
         * @param {IListRecentEventsReply} message ListRecentEventsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListRecentEventsReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eventType);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.eventReason);
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.eventTimestamp);
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.feedId);
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.sequenceNumber);
            return writer;
        };
    
        /**
         * Encodes the specified ListRecentEventsReply message, length delimited. Does not implicitly {@link ListRecentEventsReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ListRecentEventsReply
         * @static
         * @param {IListRecentEventsReply} message ListRecentEventsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListRecentEventsReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ListRecentEventsReply message from the specified reader or buffer.
         * @function decode
         * @memberof ListRecentEventsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ListRecentEventsReply} ListRecentEventsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListRecentEventsReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListRecentEventsReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.eventType = reader.int32();
                    break;
                case 2:
                    message.eventReason = reader.int32();
                    break;
                case 3:
                    message.eventTimestamp = reader.uint32();
                    break;
                case 4:
                    message.feedId = reader.uint32();
                    break;
                case 5:
                    message.sequenceNumber = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("eventType"))
                throw $util.ProtocolError("missing required 'eventType'", { instance: message });
            if (!message.hasOwnProperty("eventReason"))
                throw $util.ProtocolError("missing required 'eventReason'", { instance: message });
            if (!message.hasOwnProperty("eventTimestamp"))
                throw $util.ProtocolError("missing required 'eventTimestamp'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a ListRecentEventsReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ListRecentEventsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ListRecentEventsReply} ListRecentEventsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListRecentEventsReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ListRecentEventsReply message.
         * @function verify
         * @memberof ListRecentEventsReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListRecentEventsReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.eventType) {
            default:
                return "eventType: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
            switch (message.eventReason) {
            default:
                return "eventReason: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
                break;
            }
            if (!$util.isInteger(message.eventTimestamp))
                return "eventTimestamp: integer expected";
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                if (!$util.isInteger(message.feedId))
                    return "feedId: integer expected";
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                if (!$util.isInteger(message.sequenceNumber))
                    return "sequenceNumber: integer expected";
            return null;
        };
    
        /**
         * Creates a ListRecentEventsReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ListRecentEventsReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ListRecentEventsReply} ListRecentEventsReply
         */
        ListRecentEventsReply.fromObject = function fromObject(object) {
            if (object instanceof $root.ListRecentEventsReply)
                return object;
            var message = new $root.ListRecentEventsReply();
            switch (object.eventType) {
            case "NO_EVENT":
            case 0:
                message.eventType = 0;
                break;
            case "HW_FAILURE":
            case 1:
                message.eventType = 1;
                break;
            case "STOP_PROGRAM":
            case 2:
                message.eventType = 2;
                break;
            }
            switch (object.eventReason) {
            case "NO_REASON":
            case 0:
                message.eventReason = 0;
                break;
            case "HARDWARE_FAILURE":
            case 1:
                message.eventReason = 1;
                break;
            case "BUTTON_PRESSED":
            case 2:
                message.eventReason = 2;
                break;
            case "LOW_WATER_LEVEL":
            case 3:
                message.eventReason = 3;
                break;
            case "TIPPED_OVER":
            case 4:
                message.eventReason = 4;
                break;
            case "OVERHEATING":
            case 5:
                message.eventReason = 5;
                break;
            case "POWER_LOSS":
            case 6:
                message.eventReason = 6;
                break;
            case "HEATER_THERMISTOR":
            case 7:
                message.eventReason = 7;
                break;
            case "BATH_THERMISTOR":
            case 8:
                message.eventReason = 8;
                break;
            case "PRESSURE_SENSOR":
            case 9:
                message.eventReason = 9;
                break;
            case "ACCELEROMETER":
            case 10:
                message.eventReason = 10;
                break;
            case "BAD_MOTOR":
            case 11:
                message.eventReason = 11;
                break;
            case "STUCK_MOTOR":
            case 12:
                message.eventReason = 12;
                break;
            case "BAD_HEATER":
            case 13:
                message.eventReason = 13;
                break;
            }
            if (object.eventTimestamp != null)
                message.eventTimestamp = object.eventTimestamp >>> 0;
            if (object.feedId != null)
                message.feedId = object.feedId >>> 0;
            if (object.sequenceNumber != null)
                message.sequenceNumber = object.sequenceNumber >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a ListRecentEventsReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ListRecentEventsReply
         * @static
         * @param {ListRecentEventsReply} message ListRecentEventsReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListRecentEventsReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.eventType = options.enums === String ? "NO_EVENT" : 0;
                object.eventReason = options.enums === String ? "NO_REASON" : 0;
                object.eventTimestamp = 0;
                object.feedId = 0;
                object.sequenceNumber = 0;
            }
            if (message.eventType != null && message.hasOwnProperty("eventType"))
                object.eventType = options.enums === String ? $root.EventType[message.eventType] : message.eventType;
            if (message.eventReason != null && message.hasOwnProperty("eventReason"))
                object.eventReason = options.enums === String ? $root.EventReason[message.eventReason] : message.eventReason;
            if (message.eventTimestamp != null && message.hasOwnProperty("eventTimestamp"))
                object.eventTimestamp = message.eventTimestamp;
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                object.feedId = message.feedId;
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                object.sequenceNumber = message.sequenceNumber;
            return object;
        };
    
        /**
         * Converts this ListRecentEventsReply to JSON.
         * @function toJSON
         * @memberof ListRecentEventsReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListRecentEventsReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ListRecentEventsReply;
    })();
    
    $root.ClearErrorRequest = (function() {
    
        /**
         * Properties of a ClearErrorRequest.
         * @exports IClearErrorRequest
         * @interface IClearErrorRequest
         */
    
        /**
         * Constructs a new ClearErrorRequest.
         * @exports ClearErrorRequest
         * @classdesc Represents a ClearErrorRequest.
         * @constructor
         * @param {IClearErrorRequest=} [properties] Properties to set
         */
        function ClearErrorRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new ClearErrorRequest instance using the specified properties.
         * @function create
         * @memberof ClearErrorRequest
         * @static
         * @param {IClearErrorRequest=} [properties] Properties to set
         * @returns {ClearErrorRequest} ClearErrorRequest instance
         */
        ClearErrorRequest.create = function create(properties) {
            return new ClearErrorRequest(properties);
        };
    
        /**
         * Encodes the specified ClearErrorRequest message. Does not implicitly {@link ClearErrorRequest.verify|verify} messages.
         * @function encode
         * @memberof ClearErrorRequest
         * @static
         * @param {IClearErrorRequest} message ClearErrorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearErrorRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified ClearErrorRequest message, length delimited. Does not implicitly {@link ClearErrorRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ClearErrorRequest
         * @static
         * @param {IClearErrorRequest} message ClearErrorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearErrorRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ClearErrorRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ClearErrorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ClearErrorRequest} ClearErrorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearErrorRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClearErrorRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ClearErrorRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ClearErrorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ClearErrorRequest} ClearErrorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearErrorRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ClearErrorRequest message.
         * @function verify
         * @memberof ClearErrorRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClearErrorRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a ClearErrorRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ClearErrorRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ClearErrorRequest} ClearErrorRequest
         */
        ClearErrorRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ClearErrorRequest)
                return object;
            return new $root.ClearErrorRequest();
        };
    
        /**
         * Creates a plain object from a ClearErrorRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ClearErrorRequest
         * @static
         * @param {ClearErrorRequest} message ClearErrorRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClearErrorRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this ClearErrorRequest to JSON.
         * @function toJSON
         * @memberof ClearErrorRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClearErrorRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ClearErrorRequest;
    })();
    
    $root.ClearErrorReply = (function() {
    
        /**
         * Properties of a ClearErrorReply.
         * @exports IClearErrorReply
         * @interface IClearErrorReply
         * @property {Result} result ClearErrorReply result
         */
    
        /**
         * Constructs a new ClearErrorReply.
         * @exports ClearErrorReply
         * @classdesc Represents a ClearErrorReply.
         * @constructor
         * @param {IClearErrorReply=} [properties] Properties to set
         */
        function ClearErrorReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ClearErrorReply result.
         * @member {Result}result
         * @memberof ClearErrorReply
         * @instance
         */
        ClearErrorReply.prototype.result = 0;
    
        /**
         * Creates a new ClearErrorReply instance using the specified properties.
         * @function create
         * @memberof ClearErrorReply
         * @static
         * @param {IClearErrorReply=} [properties] Properties to set
         * @returns {ClearErrorReply} ClearErrorReply instance
         */
        ClearErrorReply.create = function create(properties) {
            return new ClearErrorReply(properties);
        };
    
        /**
         * Encodes the specified ClearErrorReply message. Does not implicitly {@link ClearErrorReply.verify|verify} messages.
         * @function encode
         * @memberof ClearErrorReply
         * @static
         * @param {IClearErrorReply} message ClearErrorReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearErrorReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified ClearErrorReply message, length delimited. Does not implicitly {@link ClearErrorReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ClearErrorReply
         * @static
         * @param {IClearErrorReply} message ClearErrorReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearErrorReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ClearErrorReply message from the specified reader or buffer.
         * @function decode
         * @memberof ClearErrorReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ClearErrorReply} ClearErrorReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearErrorReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClearErrorReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a ClearErrorReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ClearErrorReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ClearErrorReply} ClearErrorReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearErrorReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ClearErrorReply message.
         * @function verify
         * @memberof ClearErrorReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClearErrorReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.result) {
            default:
                return "result: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                break;
            }
            return null;
        };
    
        /**
         * Creates a ClearErrorReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ClearErrorReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ClearErrorReply} ClearErrorReply
         */
        ClearErrorReply.fromObject = function fromObject(object) {
            if (object instanceof $root.ClearErrorReply)
                return object;
            var message = new $root.ClearErrorReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a ClearErrorReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ClearErrorReply
         * @static
         * @param {ClearErrorReply} message ClearErrorReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClearErrorReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this ClearErrorReply to JSON.
         * @function toJSON
         * @memberof ClearErrorReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClearErrorReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ClearErrorReply;
    })();
    
    /**
     * SecurityType enum.
     * @exports SecurityType
     * @enum {string}
     * @property {number} OPEN=0 OPEN value
     * @property {number} WEP=1 WEP value
     * @property {number} WPA=2 WPA value
     * @property {number} WPS=3 WPS value
     * @property {number} UNKNOWN_WIFI=4 UNKNOWN_WIFI value
     * @property {number} WPA2=5 WPA2 value
     * @property {number} WPA_WPA2=6 WPA_WPA2 value
     */
    $root.SecurityType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OPEN"] = 0;
        values[valuesById[1] = "WEP"] = 1;
        values[valuesById[2] = "WPA"] = 2;
        values[valuesById[3] = "WPS"] = 3;
        values[valuesById[4] = "UNKNOWN_WIFI"] = 4;
        values[valuesById[5] = "WPA2"] = 5;
        values[valuesById[6] = "WPA_WPA2"] = 6;
        return values;
    })();
    
    $root.ListWifiRequest = (function() {
    
        /**
         * Properties of a ListWifiRequest.
         * @exports IListWifiRequest
         * @interface IListWifiRequest
         * @property {boolean} [start] ListWifiRequest start
         */
    
        /**
         * Constructs a new ListWifiRequest.
         * @exports ListWifiRequest
         * @classdesc Represents a ListWifiRequest.
         * @constructor
         * @param {IListWifiRequest=} [properties] Properties to set
         */
        function ListWifiRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ListWifiRequest start.
         * @member {boolean}start
         * @memberof ListWifiRequest
         * @instance
         */
        ListWifiRequest.prototype.start = false;
    
        /**
         * Creates a new ListWifiRequest instance using the specified properties.
         * @function create
         * @memberof ListWifiRequest
         * @static
         * @param {IListWifiRequest=} [properties] Properties to set
         * @returns {ListWifiRequest} ListWifiRequest instance
         */
        ListWifiRequest.create = function create(properties) {
            return new ListWifiRequest(properties);
        };
    
        /**
         * Encodes the specified ListWifiRequest message. Does not implicitly {@link ListWifiRequest.verify|verify} messages.
         * @function encode
         * @memberof ListWifiRequest
         * @static
         * @param {IListWifiRequest} message ListWifiRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListWifiRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.start != null && message.hasOwnProperty("start"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.start);
            return writer;
        };
    
        /**
         * Encodes the specified ListWifiRequest message, length delimited. Does not implicitly {@link ListWifiRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ListWifiRequest
         * @static
         * @param {IListWifiRequest} message ListWifiRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListWifiRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ListWifiRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ListWifiRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ListWifiRequest} ListWifiRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListWifiRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListWifiRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.start = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ListWifiRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ListWifiRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ListWifiRequest} ListWifiRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListWifiRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ListWifiRequest message.
         * @function verify
         * @memberof ListWifiRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListWifiRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.start != null && message.hasOwnProperty("start"))
                if (typeof message.start !== "boolean")
                    return "start: boolean expected";
            return null;
        };
    
        /**
         * Creates a ListWifiRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ListWifiRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ListWifiRequest} ListWifiRequest
         */
        ListWifiRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ListWifiRequest)
                return object;
            var message = new $root.ListWifiRequest();
            if (object.start != null)
                message.start = Boolean(object.start);
            return message;
        };
    
        /**
         * Creates a plain object from a ListWifiRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ListWifiRequest
         * @static
         * @param {ListWifiRequest} message ListWifiRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListWifiRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.start = false;
            if (message.start != null && message.hasOwnProperty("start"))
                object.start = message.start;
            return object;
        };
    
        /**
         * Converts this ListWifiRequest to JSON.
         * @function toJSON
         * @memberof ListWifiRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListWifiRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ListWifiRequest;
    })();
    
    $root.ListWifiReply = (function() {
    
        /**
         * Properties of a ListWifiReply.
         * @exports IListWifiReply
         * @interface IListWifiReply
         * @property {string} SSID ListWifiReply SSID
         * @property {SecurityType} securityType ListWifiReply securityType
         * @property {number} rssi ListWifiReply rssi
         */
    
        /**
         * Constructs a new ListWifiReply.
         * @exports ListWifiReply
         * @classdesc Represents a ListWifiReply.
         * @constructor
         * @param {IListWifiReply=} [properties] Properties to set
         */
        function ListWifiReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ListWifiReply SSID.
         * @member {string}SSID
         * @memberof ListWifiReply
         * @instance
         */
        ListWifiReply.prototype.SSID = "";
    
        /**
         * ListWifiReply securityType.
         * @member {SecurityType}securityType
         * @memberof ListWifiReply
         * @instance
         */
        ListWifiReply.prototype.securityType = 0;
    
        /**
         * ListWifiReply rssi.
         * @member {number}rssi
         * @memberof ListWifiReply
         * @instance
         */
        ListWifiReply.prototype.rssi = 0;
    
        /**
         * Creates a new ListWifiReply instance using the specified properties.
         * @function create
         * @memberof ListWifiReply
         * @static
         * @param {IListWifiReply=} [properties] Properties to set
         * @returns {ListWifiReply} ListWifiReply instance
         */
        ListWifiReply.create = function create(properties) {
            return new ListWifiReply(properties);
        };
    
        /**
         * Encodes the specified ListWifiReply message. Does not implicitly {@link ListWifiReply.verify|verify} messages.
         * @function encode
         * @memberof ListWifiReply
         * @static
         * @param {IListWifiReply} message ListWifiReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListWifiReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1000, wireType 2 =*/8002).string(message.SSID);
            writer.uint32(/* id 1001, wireType 0 =*/8008).int32(message.securityType);
            writer.uint32(/* id 1002, wireType 0 =*/8016).sint32(message.rssi);
            return writer;
        };
    
        /**
         * Encodes the specified ListWifiReply message, length delimited. Does not implicitly {@link ListWifiReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ListWifiReply
         * @static
         * @param {IListWifiReply} message ListWifiReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListWifiReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ListWifiReply message from the specified reader or buffer.
         * @function decode
         * @memberof ListWifiReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ListWifiReply} ListWifiReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListWifiReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListWifiReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1000:
                    message.SSID = reader.string();
                    break;
                case 1001:
                    message.securityType = reader.int32();
                    break;
                case 1002:
                    message.rssi = reader.sint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("SSID"))
                throw $util.ProtocolError("missing required 'SSID'", { instance: message });
            if (!message.hasOwnProperty("securityType"))
                throw $util.ProtocolError("missing required 'securityType'", { instance: message });
            if (!message.hasOwnProperty("rssi"))
                throw $util.ProtocolError("missing required 'rssi'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a ListWifiReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ListWifiReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ListWifiReply} ListWifiReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListWifiReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ListWifiReply message.
         * @function verify
         * @memberof ListWifiReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListWifiReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.SSID))
                return "SSID: string expected";
            switch (message.securityType) {
            default:
                return "securityType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
                break;
            }
            if (!$util.isInteger(message.rssi))
                return "rssi: integer expected";
            return null;
        };
    
        /**
         * Creates a ListWifiReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ListWifiReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ListWifiReply} ListWifiReply
         */
        ListWifiReply.fromObject = function fromObject(object) {
            if (object instanceof $root.ListWifiReply)
                return object;
            var message = new $root.ListWifiReply();
            if (object.SSID != null)
                message.SSID = String(object.SSID);
            switch (object.securityType) {
            case "OPEN":
            case 0:
                message.securityType = 0;
                break;
            case "WEP":
            case 1:
                message.securityType = 1;
                break;
            case "WPA":
            case 2:
                message.securityType = 2;
                break;
            case "WPS":
            case 3:
                message.securityType = 3;
                break;
            case "UNKNOWN_WIFI":
            case 4:
                message.securityType = 4;
                break;
            case "WPA2":
            case 5:
                message.securityType = 5;
                break;
            case "WPA_WPA2":
            case 6:
                message.securityType = 6;
                break;
            }
            if (object.rssi != null)
                message.rssi = object.rssi | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a ListWifiReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ListWifiReply
         * @static
         * @param {ListWifiReply} message ListWifiReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListWifiReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.SSID = "";
                object.securityType = options.enums === String ? "OPEN" : 0;
                object.rssi = 0;
            }
            if (message.SSID != null && message.hasOwnProperty("SSID"))
                object.SSID = message.SSID;
            if (message.securityType != null && message.hasOwnProperty("securityType"))
                object.securityType = options.enums === String ? $root.SecurityType[message.securityType] : message.securityType;
            if (message.rssi != null && message.hasOwnProperty("rssi"))
                object.rssi = message.rssi;
            return object;
        };
    
        /**
         * Converts this ListWifiReply to JSON.
         * @function toJSON
         * @memberof ListWifiReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListWifiReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ListWifiReply;
    })();
    
    $root.ConnectWifiRequest = (function() {
    
        /**
         * Properties of a ConnectWifiRequest.
         * @exports IConnectWifiRequest
         * @interface IConnectWifiRequest
         * @property {string} SSID ConnectWifiRequest SSID
         * @property {string} passphrase ConnectWifiRequest passphrase
         * @property {SecurityType} securityType ConnectWifiRequest securityType
         */
    
        /**
         * Constructs a new ConnectWifiRequest.
         * @exports ConnectWifiRequest
         * @classdesc Represents a ConnectWifiRequest.
         * @constructor
         * @param {IConnectWifiRequest=} [properties] Properties to set
         */
        function ConnectWifiRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ConnectWifiRequest SSID.
         * @member {string}SSID
         * @memberof ConnectWifiRequest
         * @instance
         */
        ConnectWifiRequest.prototype.SSID = "";
    
        /**
         * ConnectWifiRequest passphrase.
         * @member {string}passphrase
         * @memberof ConnectWifiRequest
         * @instance
         */
        ConnectWifiRequest.prototype.passphrase = "";
    
        /**
         * ConnectWifiRequest securityType.
         * @member {SecurityType}securityType
         * @memberof ConnectWifiRequest
         * @instance
         */
        ConnectWifiRequest.prototype.securityType = 0;
    
        /**
         * Creates a new ConnectWifiRequest instance using the specified properties.
         * @function create
         * @memberof ConnectWifiRequest
         * @static
         * @param {IConnectWifiRequest=} [properties] Properties to set
         * @returns {ConnectWifiRequest} ConnectWifiRequest instance
         */
        ConnectWifiRequest.create = function create(properties) {
            return new ConnectWifiRequest(properties);
        };
    
        /**
         * Encodes the specified ConnectWifiRequest message. Does not implicitly {@link ConnectWifiRequest.verify|verify} messages.
         * @function encode
         * @memberof ConnectWifiRequest
         * @static
         * @param {IConnectWifiRequest} message ConnectWifiRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectWifiRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.SSID);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.passphrase);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.securityType);
            return writer;
        };
    
        /**
         * Encodes the specified ConnectWifiRequest message, length delimited. Does not implicitly {@link ConnectWifiRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ConnectWifiRequest
         * @static
         * @param {IConnectWifiRequest} message ConnectWifiRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectWifiRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ConnectWifiRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ConnectWifiRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ConnectWifiRequest} ConnectWifiRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectWifiRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConnectWifiRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.SSID = reader.string();
                    break;
                case 2:
                    message.passphrase = reader.string();
                    break;
                case 3:
                    message.securityType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("SSID"))
                throw $util.ProtocolError("missing required 'SSID'", { instance: message });
            if (!message.hasOwnProperty("passphrase"))
                throw $util.ProtocolError("missing required 'passphrase'", { instance: message });
            if (!message.hasOwnProperty("securityType"))
                throw $util.ProtocolError("missing required 'securityType'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a ConnectWifiRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ConnectWifiRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ConnectWifiRequest} ConnectWifiRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectWifiRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ConnectWifiRequest message.
         * @function verify
         * @memberof ConnectWifiRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnectWifiRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.SSID))
                return "SSID: string expected";
            if (!$util.isString(message.passphrase))
                return "passphrase: string expected";
            switch (message.securityType) {
            default:
                return "securityType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
                break;
            }
            return null;
        };
    
        /**
         * Creates a ConnectWifiRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ConnectWifiRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ConnectWifiRequest} ConnectWifiRequest
         */
        ConnectWifiRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ConnectWifiRequest)
                return object;
            var message = new $root.ConnectWifiRequest();
            if (object.SSID != null)
                message.SSID = String(object.SSID);
            if (object.passphrase != null)
                message.passphrase = String(object.passphrase);
            switch (object.securityType) {
            case "OPEN":
            case 0:
                message.securityType = 0;
                break;
            case "WEP":
            case 1:
                message.securityType = 1;
                break;
            case "WPA":
            case 2:
                message.securityType = 2;
                break;
            case "WPS":
            case 3:
                message.securityType = 3;
                break;
            case "UNKNOWN_WIFI":
            case 4:
                message.securityType = 4;
                break;
            case "WPA2":
            case 5:
                message.securityType = 5;
                break;
            case "WPA_WPA2":
            case 6:
                message.securityType = 6;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a ConnectWifiRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ConnectWifiRequest
         * @static
         * @param {ConnectWifiRequest} message ConnectWifiRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnectWifiRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.SSID = "";
                object.passphrase = "";
                object.securityType = options.enums === String ? "OPEN" : 0;
            }
            if (message.SSID != null && message.hasOwnProperty("SSID"))
                object.SSID = message.SSID;
            if (message.passphrase != null && message.hasOwnProperty("passphrase"))
                object.passphrase = message.passphrase;
            if (message.securityType != null && message.hasOwnProperty("securityType"))
                object.securityType = options.enums === String ? $root.SecurityType[message.securityType] : message.securityType;
            return object;
        };
    
        /**
         * Converts this ConnectWifiRequest to JSON.
         * @function toJSON
         * @memberof ConnectWifiRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnectWifiRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ConnectWifiRequest;
    })();
    
    $root.ConnectWifiReply = (function() {
    
        /**
         * Properties of a ConnectWifiReply.
         * @exports IConnectWifiReply
         * @interface IConnectWifiReply
         * @property {Result} [result] ConnectWifiReply result
         */
    
        /**
         * Constructs a new ConnectWifiReply.
         * @exports ConnectWifiReply
         * @classdesc Represents a ConnectWifiReply.
         * @constructor
         * @param {IConnectWifiReply=} [properties] Properties to set
         */
        function ConnectWifiReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ConnectWifiReply result.
         * @member {Result}result
         * @memberof ConnectWifiReply
         * @instance
         */
        ConnectWifiReply.prototype.result = 0;
    
        /**
         * Creates a new ConnectWifiReply instance using the specified properties.
         * @function create
         * @memberof ConnectWifiReply
         * @static
         * @param {IConnectWifiReply=} [properties] Properties to set
         * @returns {ConnectWifiReply} ConnectWifiReply instance
         */
        ConnectWifiReply.create = function create(properties) {
            return new ConnectWifiReply(properties);
        };
    
        /**
         * Encodes the specified ConnectWifiReply message. Does not implicitly {@link ConnectWifiReply.verify|verify} messages.
         * @function encode
         * @memberof ConnectWifiReply
         * @static
         * @param {IConnectWifiReply} message ConnectWifiReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectWifiReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified ConnectWifiReply message, length delimited. Does not implicitly {@link ConnectWifiReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ConnectWifiReply
         * @static
         * @param {IConnectWifiReply} message ConnectWifiReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectWifiReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ConnectWifiReply message from the specified reader or buffer.
         * @function decode
         * @memberof ConnectWifiReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ConnectWifiReply} ConnectWifiReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectWifiReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConnectWifiReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ConnectWifiReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ConnectWifiReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ConnectWifiReply} ConnectWifiReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectWifiReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ConnectWifiReply message.
         * @function verify
         * @memberof ConnectWifiReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnectWifiReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a ConnectWifiReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ConnectWifiReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ConnectWifiReply} ConnectWifiReply
         */
        ConnectWifiReply.fromObject = function fromObject(object) {
            if (object instanceof $root.ConnectWifiReply)
                return object;
            var message = new $root.ConnectWifiReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a ConnectWifiReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ConnectWifiReply
         * @static
         * @param {ConnectWifiReply} message ConnectWifiReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnectWifiReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this ConnectWifiReply to JSON.
         * @function toJSON
         * @memberof ConnectWifiReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnectWifiReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ConnectWifiReply;
    })();
    
    /**
     * WifiConnectionStatus enum.
     * @exports WifiConnectionStatus
     * @enum {string}
     * @property {number} WIFI_IDLE=0 WIFI_IDLE value
     * @property {number} WIFI_CONNECTING=1 WIFI_CONNECTING value
     * @property {number} WIFI_WRONG_PASSWORD=2 WIFI_WRONG_PASSWORD value
     * @property {number} WIFI_NO_AP_FOUND=3 WIFI_NO_AP_FOUND value
     * @property {number} WIFI_CONNECT_FAIL=4 WIFI_CONNECT_FAIL value
     * @property {number} WIFI_GOT_IP=5 WIFI_GOT_IP value
     */
    $root.WifiConnectionStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "WIFI_IDLE"] = 0;
        values[valuesById[1] = "WIFI_CONNECTING"] = 1;
        values[valuesById[2] = "WIFI_WRONG_PASSWORD"] = 2;
        values[valuesById[3] = "WIFI_NO_AP_FOUND"] = 3;
        values[valuesById[4] = "WIFI_CONNECT_FAIL"] = 4;
        values[valuesById[5] = "WIFI_GOT_IP"] = 5;
        return values;
    })();
    
    $root.ListWifiProfileRequest = (function() {
    
        /**
         * Properties of a ListWifiProfileRequest.
         * @exports IListWifiProfileRequest
         * @interface IListWifiProfileRequest
         */
    
        /**
         * Constructs a new ListWifiProfileRequest.
         * @exports ListWifiProfileRequest
         * @classdesc Represents a ListWifiProfileRequest.
         * @constructor
         * @param {IListWifiProfileRequest=} [properties] Properties to set
         */
        function ListWifiProfileRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new ListWifiProfileRequest instance using the specified properties.
         * @function create
         * @memberof ListWifiProfileRequest
         * @static
         * @param {IListWifiProfileRequest=} [properties] Properties to set
         * @returns {ListWifiProfileRequest} ListWifiProfileRequest instance
         */
        ListWifiProfileRequest.create = function create(properties) {
            return new ListWifiProfileRequest(properties);
        };
    
        /**
         * Encodes the specified ListWifiProfileRequest message. Does not implicitly {@link ListWifiProfileRequest.verify|verify} messages.
         * @function encode
         * @memberof ListWifiProfileRequest
         * @static
         * @param {IListWifiProfileRequest} message ListWifiProfileRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListWifiProfileRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified ListWifiProfileRequest message, length delimited. Does not implicitly {@link ListWifiProfileRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ListWifiProfileRequest
         * @static
         * @param {IListWifiProfileRequest} message ListWifiProfileRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListWifiProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ListWifiProfileRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ListWifiProfileRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ListWifiProfileRequest} ListWifiProfileRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListWifiProfileRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListWifiProfileRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ListWifiProfileRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ListWifiProfileRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ListWifiProfileRequest} ListWifiProfileRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListWifiProfileRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ListWifiProfileRequest message.
         * @function verify
         * @memberof ListWifiProfileRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListWifiProfileRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a ListWifiProfileRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ListWifiProfileRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ListWifiProfileRequest} ListWifiProfileRequest
         */
        ListWifiProfileRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ListWifiProfileRequest)
                return object;
            return new $root.ListWifiProfileRequest();
        };
    
        /**
         * Creates a plain object from a ListWifiProfileRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ListWifiProfileRequest
         * @static
         * @param {ListWifiProfileRequest} message ListWifiProfileRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListWifiProfileRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this ListWifiProfileRequest to JSON.
         * @function toJSON
         * @memberof ListWifiProfileRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListWifiProfileRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ListWifiProfileRequest;
    })();
    
    $root.ListWifiProfileReply = (function() {
    
        /**
         * Properties of a ListWifiProfileReply.
         * @exports IListWifiProfileReply
         * @interface IListWifiProfileReply
         * @property {Result} result ListWifiProfileReply result
         * @property {string} SSID ListWifiProfileReply SSID
         * @property {boolean} [bearerTokenSet] ListWifiProfileReply bearerTokenSet
         * @property {WifiConnectionStatus} [connectionStatus] ListWifiProfileReply connectionStatus
         * @property {number} [timeSinceLastPacketMS] ListWifiProfileReply timeSinceLastPacketMS
         * @property {number} [cloudStatus] ListWifiProfileReply cloudStatus
         * @property {Uint8Array} [MACADDR] ListWifiProfileReply MACADDR
         */
    
        /**
         * Constructs a new ListWifiProfileReply.
         * @exports ListWifiProfileReply
         * @classdesc Represents a ListWifiProfileReply.
         * @constructor
         * @param {IListWifiProfileReply=} [properties] Properties to set
         */
        function ListWifiProfileReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ListWifiProfileReply result.
         * @member {Result}result
         * @memberof ListWifiProfileReply
         * @instance
         */
        ListWifiProfileReply.prototype.result = 0;
    
        /**
         * ListWifiProfileReply SSID.
         * @member {string}SSID
         * @memberof ListWifiProfileReply
         * @instance
         */
        ListWifiProfileReply.prototype.SSID = "";
    
        /**
         * ListWifiProfileReply bearerTokenSet.
         * @member {boolean}bearerTokenSet
         * @memberof ListWifiProfileReply
         * @instance
         */
        ListWifiProfileReply.prototype.bearerTokenSet = false;
    
        /**
         * ListWifiProfileReply connectionStatus.
         * @member {WifiConnectionStatus}connectionStatus
         * @memberof ListWifiProfileReply
         * @instance
         */
        ListWifiProfileReply.prototype.connectionStatus = 0;
    
        /**
         * ListWifiProfileReply timeSinceLastPacketMS.
         * @member {number}timeSinceLastPacketMS
         * @memberof ListWifiProfileReply
         * @instance
         */
        ListWifiProfileReply.prototype.timeSinceLastPacketMS = 0;
    
        /**
         * ListWifiProfileReply cloudStatus.
         * @member {number}cloudStatus
         * @memberof ListWifiProfileReply
         * @instance
         */
        ListWifiProfileReply.prototype.cloudStatus = 0;
    
        /**
         * ListWifiProfileReply MACADDR.
         * @member {Uint8Array}MACADDR
         * @memberof ListWifiProfileReply
         * @instance
         */
        ListWifiProfileReply.prototype.MACADDR = $util.newBuffer([]);
    
        /**
         * Creates a new ListWifiProfileReply instance using the specified properties.
         * @function create
         * @memberof ListWifiProfileReply
         * @static
         * @param {IListWifiProfileReply=} [properties] Properties to set
         * @returns {ListWifiProfileReply} ListWifiProfileReply instance
         */
        ListWifiProfileReply.create = function create(properties) {
            return new ListWifiProfileReply(properties);
        };
    
        /**
         * Encodes the specified ListWifiProfileReply message. Does not implicitly {@link ListWifiProfileReply.verify|verify} messages.
         * @function encode
         * @memberof ListWifiProfileReply
         * @static
         * @param {IListWifiProfileReply} message ListWifiProfileReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListWifiProfileReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.SSID);
            if (message.bearerTokenSet != null && message.hasOwnProperty("bearerTokenSet"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.bearerTokenSet);
            if (message.connectionStatus != null && message.hasOwnProperty("connectionStatus"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.connectionStatus);
            if (message.timeSinceLastPacketMS != null && message.hasOwnProperty("timeSinceLastPacketMS"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.timeSinceLastPacketMS);
            if (message.cloudStatus != null && message.hasOwnProperty("cloudStatus"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.cloudStatus);
            if (message.MACADDR != null && message.hasOwnProperty("MACADDR"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.MACADDR);
            return writer;
        };
    
        /**
         * Encodes the specified ListWifiProfileReply message, length delimited. Does not implicitly {@link ListWifiProfileReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ListWifiProfileReply
         * @static
         * @param {IListWifiProfileReply} message ListWifiProfileReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListWifiProfileReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ListWifiProfileReply message from the specified reader or buffer.
         * @function decode
         * @memberof ListWifiProfileReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ListWifiProfileReply} ListWifiProfileReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListWifiProfileReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListWifiProfileReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.SSID = reader.string();
                    break;
                case 3:
                    message.bearerTokenSet = reader.bool();
                    break;
                case 4:
                    message.connectionStatus = reader.int32();
                    break;
                case 5:
                    message.timeSinceLastPacketMS = reader.uint32();
                    break;
                case 6:
                    message.cloudStatus = reader.uint32();
                    break;
                case 7:
                    message.MACADDR = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            if (!message.hasOwnProperty("SSID"))
                throw $util.ProtocolError("missing required 'SSID'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a ListWifiProfileReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ListWifiProfileReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ListWifiProfileReply} ListWifiProfileReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListWifiProfileReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ListWifiProfileReply message.
         * @function verify
         * @memberof ListWifiProfileReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListWifiProfileReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.result) {
            default:
                return "result: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                break;
            }
            if (!$util.isString(message.SSID))
                return "SSID: string expected";
            if (message.bearerTokenSet != null && message.hasOwnProperty("bearerTokenSet"))
                if (typeof message.bearerTokenSet !== "boolean")
                    return "bearerTokenSet: boolean expected";
            if (message.connectionStatus != null && message.hasOwnProperty("connectionStatus"))
                switch (message.connectionStatus) {
                default:
                    return "connectionStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.timeSinceLastPacketMS != null && message.hasOwnProperty("timeSinceLastPacketMS"))
                if (!$util.isInteger(message.timeSinceLastPacketMS))
                    return "timeSinceLastPacketMS: integer expected";
            if (message.cloudStatus != null && message.hasOwnProperty("cloudStatus"))
                if (!$util.isInteger(message.cloudStatus))
                    return "cloudStatus: integer expected";
            if (message.MACADDR != null && message.hasOwnProperty("MACADDR"))
                if (!(message.MACADDR && typeof message.MACADDR.length === "number" || $util.isString(message.MACADDR)))
                    return "MACADDR: buffer expected";
            return null;
        };
    
        /**
         * Creates a ListWifiProfileReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ListWifiProfileReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ListWifiProfileReply} ListWifiProfileReply
         */
        ListWifiProfileReply.fromObject = function fromObject(object) {
            if (object instanceof $root.ListWifiProfileReply)
                return object;
            var message = new $root.ListWifiProfileReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            if (object.SSID != null)
                message.SSID = String(object.SSID);
            if (object.bearerTokenSet != null)
                message.bearerTokenSet = Boolean(object.bearerTokenSet);
            switch (object.connectionStatus) {
            case "WIFI_IDLE":
            case 0:
                message.connectionStatus = 0;
                break;
            case "WIFI_CONNECTING":
            case 1:
                message.connectionStatus = 1;
                break;
            case "WIFI_WRONG_PASSWORD":
            case 2:
                message.connectionStatus = 2;
                break;
            case "WIFI_NO_AP_FOUND":
            case 3:
                message.connectionStatus = 3;
                break;
            case "WIFI_CONNECT_FAIL":
            case 4:
                message.connectionStatus = 4;
                break;
            case "WIFI_GOT_IP":
            case 5:
                message.connectionStatus = 5;
                break;
            }
            if (object.timeSinceLastPacketMS != null)
                message.timeSinceLastPacketMS = object.timeSinceLastPacketMS >>> 0;
            if (object.cloudStatus != null)
                message.cloudStatus = object.cloudStatus >>> 0;
            if (object.MACADDR != null)
                if (typeof object.MACADDR === "string")
                    $util.base64.decode(object.MACADDR, message.MACADDR = $util.newBuffer($util.base64.length(object.MACADDR)), 0);
                else if (object.MACADDR.length)
                    message.MACADDR = object.MACADDR;
            return message;
        };
    
        /**
         * Creates a plain object from a ListWifiProfileReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ListWifiProfileReply
         * @static
         * @param {ListWifiProfileReply} message ListWifiProfileReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListWifiProfileReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
                object.SSID = "";
                object.bearerTokenSet = false;
                object.connectionStatus = options.enums === String ? "WIFI_IDLE" : 0;
                object.timeSinceLastPacketMS = 0;
                object.cloudStatus = 0;
                object.MACADDR = options.bytes === String ? "" : [];
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            if (message.SSID != null && message.hasOwnProperty("SSID"))
                object.SSID = message.SSID;
            if (message.bearerTokenSet != null && message.hasOwnProperty("bearerTokenSet"))
                object.bearerTokenSet = message.bearerTokenSet;
            if (message.connectionStatus != null && message.hasOwnProperty("connectionStatus"))
                object.connectionStatus = options.enums === String ? $root.WifiConnectionStatus[message.connectionStatus] : message.connectionStatus;
            if (message.timeSinceLastPacketMS != null && message.hasOwnProperty("timeSinceLastPacketMS"))
                object.timeSinceLastPacketMS = message.timeSinceLastPacketMS;
            if (message.cloudStatus != null && message.hasOwnProperty("cloudStatus"))
                object.cloudStatus = message.cloudStatus;
            if (message.MACADDR != null && message.hasOwnProperty("MACADDR"))
                object.MACADDR = options.bytes === String ? $util.base64.encode(message.MACADDR, 0, message.MACADDR.length) : options.bytes === Array ? Array.prototype.slice.call(message.MACADDR) : message.MACADDR;
            return object;
        };
    
        /**
         * Converts this ListWifiProfileReply to JSON.
         * @function toJSON
         * @memberof ListWifiProfileReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListWifiProfileReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ListWifiProfileReply;
    })();
    
    $root.ForgetWifiProfileRequest = (function() {
    
        /**
         * Properties of a ForgetWifiProfileRequest.
         * @exports IForgetWifiProfileRequest
         * @interface IForgetWifiProfileRequest
         */
    
        /**
         * Constructs a new ForgetWifiProfileRequest.
         * @exports ForgetWifiProfileRequest
         * @classdesc Represents a ForgetWifiProfileRequest.
         * @constructor
         * @param {IForgetWifiProfileRequest=} [properties] Properties to set
         */
        function ForgetWifiProfileRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new ForgetWifiProfileRequest instance using the specified properties.
         * @function create
         * @memberof ForgetWifiProfileRequest
         * @static
         * @param {IForgetWifiProfileRequest=} [properties] Properties to set
         * @returns {ForgetWifiProfileRequest} ForgetWifiProfileRequest instance
         */
        ForgetWifiProfileRequest.create = function create(properties) {
            return new ForgetWifiProfileRequest(properties);
        };
    
        /**
         * Encodes the specified ForgetWifiProfileRequest message. Does not implicitly {@link ForgetWifiProfileRequest.verify|verify} messages.
         * @function encode
         * @memberof ForgetWifiProfileRequest
         * @static
         * @param {IForgetWifiProfileRequest} message ForgetWifiProfileRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForgetWifiProfileRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified ForgetWifiProfileRequest message, length delimited. Does not implicitly {@link ForgetWifiProfileRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ForgetWifiProfileRequest
         * @static
         * @param {IForgetWifiProfileRequest} message ForgetWifiProfileRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForgetWifiProfileRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ForgetWifiProfileRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ForgetWifiProfileRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ForgetWifiProfileRequest} ForgetWifiProfileRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForgetWifiProfileRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ForgetWifiProfileRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ForgetWifiProfileRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ForgetWifiProfileRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ForgetWifiProfileRequest} ForgetWifiProfileRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForgetWifiProfileRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ForgetWifiProfileRequest message.
         * @function verify
         * @memberof ForgetWifiProfileRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ForgetWifiProfileRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a ForgetWifiProfileRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ForgetWifiProfileRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ForgetWifiProfileRequest} ForgetWifiProfileRequest
         */
        ForgetWifiProfileRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ForgetWifiProfileRequest)
                return object;
            return new $root.ForgetWifiProfileRequest();
        };
    
        /**
         * Creates a plain object from a ForgetWifiProfileRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ForgetWifiProfileRequest
         * @static
         * @param {ForgetWifiProfileRequest} message ForgetWifiProfileRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ForgetWifiProfileRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this ForgetWifiProfileRequest to JSON.
         * @function toJSON
         * @memberof ForgetWifiProfileRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ForgetWifiProfileRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ForgetWifiProfileRequest;
    })();
    
    $root.ForgetWifiProfileReply = (function() {
    
        /**
         * Properties of a ForgetWifiProfileReply.
         * @exports IForgetWifiProfileReply
         * @interface IForgetWifiProfileReply
         * @property {Result} [result] ForgetWifiProfileReply result
         */
    
        /**
         * Constructs a new ForgetWifiProfileReply.
         * @exports ForgetWifiProfileReply
         * @classdesc Represents a ForgetWifiProfileReply.
         * @constructor
         * @param {IForgetWifiProfileReply=} [properties] Properties to set
         */
        function ForgetWifiProfileReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ForgetWifiProfileReply result.
         * @member {Result}result
         * @memberof ForgetWifiProfileReply
         * @instance
         */
        ForgetWifiProfileReply.prototype.result = 0;
    
        /**
         * Creates a new ForgetWifiProfileReply instance using the specified properties.
         * @function create
         * @memberof ForgetWifiProfileReply
         * @static
         * @param {IForgetWifiProfileReply=} [properties] Properties to set
         * @returns {ForgetWifiProfileReply} ForgetWifiProfileReply instance
         */
        ForgetWifiProfileReply.create = function create(properties) {
            return new ForgetWifiProfileReply(properties);
        };
    
        /**
         * Encodes the specified ForgetWifiProfileReply message. Does not implicitly {@link ForgetWifiProfileReply.verify|verify} messages.
         * @function encode
         * @memberof ForgetWifiProfileReply
         * @static
         * @param {IForgetWifiProfileReply} message ForgetWifiProfileReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForgetWifiProfileReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified ForgetWifiProfileReply message, length delimited. Does not implicitly {@link ForgetWifiProfileReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ForgetWifiProfileReply
         * @static
         * @param {IForgetWifiProfileReply} message ForgetWifiProfileReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForgetWifiProfileReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ForgetWifiProfileReply message from the specified reader or buffer.
         * @function decode
         * @memberof ForgetWifiProfileReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ForgetWifiProfileReply} ForgetWifiProfileReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForgetWifiProfileReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ForgetWifiProfileReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ForgetWifiProfileReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ForgetWifiProfileReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ForgetWifiProfileReply} ForgetWifiProfileReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForgetWifiProfileReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ForgetWifiProfileReply message.
         * @function verify
         * @memberof ForgetWifiProfileReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ForgetWifiProfileReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a ForgetWifiProfileReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ForgetWifiProfileReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ForgetWifiProfileReply} ForgetWifiProfileReply
         */
        ForgetWifiProfileReply.fromObject = function fromObject(object) {
            if (object instanceof $root.ForgetWifiProfileReply)
                return object;
            var message = new $root.ForgetWifiProfileReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a ForgetWifiProfileReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ForgetWifiProfileReply
         * @static
         * @param {ForgetWifiProfileReply} message ForgetWifiProfileReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ForgetWifiProfileReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this ForgetWifiProfileReply to JSON.
         * @function toJSON
         * @memberof ForgetWifiProfileReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ForgetWifiProfileReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ForgetWifiProfileReply;
    })();
    
    $root.DisconnectWifiRequest = (function() {
    
        /**
         * Properties of a DisconnectWifiRequest.
         * @exports IDisconnectWifiRequest
         * @interface IDisconnectWifiRequest
         */
    
        /**
         * Constructs a new DisconnectWifiRequest.
         * @exports DisconnectWifiRequest
         * @classdesc Represents a DisconnectWifiRequest.
         * @constructor
         * @param {IDisconnectWifiRequest=} [properties] Properties to set
         */
        function DisconnectWifiRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new DisconnectWifiRequest instance using the specified properties.
         * @function create
         * @memberof DisconnectWifiRequest
         * @static
         * @param {IDisconnectWifiRequest=} [properties] Properties to set
         * @returns {DisconnectWifiRequest} DisconnectWifiRequest instance
         */
        DisconnectWifiRequest.create = function create(properties) {
            return new DisconnectWifiRequest(properties);
        };
    
        /**
         * Encodes the specified DisconnectWifiRequest message. Does not implicitly {@link DisconnectWifiRequest.verify|verify} messages.
         * @function encode
         * @memberof DisconnectWifiRequest
         * @static
         * @param {IDisconnectWifiRequest} message DisconnectWifiRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectWifiRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified DisconnectWifiRequest message, length delimited. Does not implicitly {@link DisconnectWifiRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DisconnectWifiRequest
         * @static
         * @param {IDisconnectWifiRequest} message DisconnectWifiRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectWifiRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a DisconnectWifiRequest message from the specified reader or buffer.
         * @function decode
         * @memberof DisconnectWifiRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DisconnectWifiRequest} DisconnectWifiRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectWifiRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DisconnectWifiRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a DisconnectWifiRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DisconnectWifiRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DisconnectWifiRequest} DisconnectWifiRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectWifiRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a DisconnectWifiRequest message.
         * @function verify
         * @memberof DisconnectWifiRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisconnectWifiRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a DisconnectWifiRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DisconnectWifiRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DisconnectWifiRequest} DisconnectWifiRequest
         */
        DisconnectWifiRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.DisconnectWifiRequest)
                return object;
            return new $root.DisconnectWifiRequest();
        };
    
        /**
         * Creates a plain object from a DisconnectWifiRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DisconnectWifiRequest
         * @static
         * @param {DisconnectWifiRequest} message DisconnectWifiRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DisconnectWifiRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this DisconnectWifiRequest to JSON.
         * @function toJSON
         * @memberof DisconnectWifiRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DisconnectWifiRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return DisconnectWifiRequest;
    })();
    
    $root.DisconnectWifiReply = (function() {
    
        /**
         * Properties of a DisconnectWifiReply.
         * @exports IDisconnectWifiReply
         * @interface IDisconnectWifiReply
         * @property {Result} [result] DisconnectWifiReply result
         */
    
        /**
         * Constructs a new DisconnectWifiReply.
         * @exports DisconnectWifiReply
         * @classdesc Represents a DisconnectWifiReply.
         * @constructor
         * @param {IDisconnectWifiReply=} [properties] Properties to set
         */
        function DisconnectWifiReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * DisconnectWifiReply result.
         * @member {Result}result
         * @memberof DisconnectWifiReply
         * @instance
         */
        DisconnectWifiReply.prototype.result = 0;
    
        /**
         * Creates a new DisconnectWifiReply instance using the specified properties.
         * @function create
         * @memberof DisconnectWifiReply
         * @static
         * @param {IDisconnectWifiReply=} [properties] Properties to set
         * @returns {DisconnectWifiReply} DisconnectWifiReply instance
         */
        DisconnectWifiReply.create = function create(properties) {
            return new DisconnectWifiReply(properties);
        };
    
        /**
         * Encodes the specified DisconnectWifiReply message. Does not implicitly {@link DisconnectWifiReply.verify|verify} messages.
         * @function encode
         * @memberof DisconnectWifiReply
         * @static
         * @param {IDisconnectWifiReply} message DisconnectWifiReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectWifiReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified DisconnectWifiReply message, length delimited. Does not implicitly {@link DisconnectWifiReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DisconnectWifiReply
         * @static
         * @param {IDisconnectWifiReply} message DisconnectWifiReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectWifiReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a DisconnectWifiReply message from the specified reader or buffer.
         * @function decode
         * @memberof DisconnectWifiReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DisconnectWifiReply} DisconnectWifiReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectWifiReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DisconnectWifiReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a DisconnectWifiReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DisconnectWifiReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DisconnectWifiReply} DisconnectWifiReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectWifiReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a DisconnectWifiReply message.
         * @function verify
         * @memberof DisconnectWifiReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisconnectWifiReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a DisconnectWifiReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DisconnectWifiReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DisconnectWifiReply} DisconnectWifiReply
         */
        DisconnectWifiReply.fromObject = function fromObject(object) {
            if (object instanceof $root.DisconnectWifiReply)
                return object;
            var message = new $root.DisconnectWifiReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a DisconnectWifiReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DisconnectWifiReply
         * @static
         * @param {DisconnectWifiReply} message DisconnectWifiReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DisconnectWifiReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this DisconnectWifiReply to JSON.
         * @function toJSON
         * @memberof DisconnectWifiReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DisconnectWifiReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return DisconnectWifiReply;
    })();
    
    $root.WifiDFUStatusRequest = (function() {
    
        /**
         * Properties of a WifiDFUStatusRequest.
         * @exports IWifiDFUStatusRequest
         * @interface IWifiDFUStatusRequest
         */
    
        /**
         * Constructs a new WifiDFUStatusRequest.
         * @exports WifiDFUStatusRequest
         * @classdesc Represents a WifiDFUStatusRequest.
         * @constructor
         * @param {IWifiDFUStatusRequest=} [properties] Properties to set
         */
        function WifiDFUStatusRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new WifiDFUStatusRequest instance using the specified properties.
         * @function create
         * @memberof WifiDFUStatusRequest
         * @static
         * @param {IWifiDFUStatusRequest=} [properties] Properties to set
         * @returns {WifiDFUStatusRequest} WifiDFUStatusRequest instance
         */
        WifiDFUStatusRequest.create = function create(properties) {
            return new WifiDFUStatusRequest(properties);
        };
    
        /**
         * Encodes the specified WifiDFUStatusRequest message. Does not implicitly {@link WifiDFUStatusRequest.verify|verify} messages.
         * @function encode
         * @memberof WifiDFUStatusRequest
         * @static
         * @param {IWifiDFUStatusRequest} message WifiDFUStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WifiDFUStatusRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified WifiDFUStatusRequest message, length delimited. Does not implicitly {@link WifiDFUStatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof WifiDFUStatusRequest
         * @static
         * @param {IWifiDFUStatusRequest} message WifiDFUStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WifiDFUStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a WifiDFUStatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof WifiDFUStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {WifiDFUStatusRequest} WifiDFUStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WifiDFUStatusRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WifiDFUStatusRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a WifiDFUStatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof WifiDFUStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {WifiDFUStatusRequest} WifiDFUStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WifiDFUStatusRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a WifiDFUStatusRequest message.
         * @function verify
         * @memberof WifiDFUStatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WifiDFUStatusRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a WifiDFUStatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof WifiDFUStatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {WifiDFUStatusRequest} WifiDFUStatusRequest
         */
        WifiDFUStatusRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.WifiDFUStatusRequest)
                return object;
            return new $root.WifiDFUStatusRequest();
        };
    
        /**
         * Creates a plain object from a WifiDFUStatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof WifiDFUStatusRequest
         * @static
         * @param {WifiDFUStatusRequest} message WifiDFUStatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WifiDFUStatusRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this WifiDFUStatusRequest to JSON.
         * @function toJSON
         * @memberof WifiDFUStatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WifiDFUStatusRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return WifiDFUStatusRequest;
    })();
    
    $root.WifiDFUSlotStatus = (function() {
    
        /**
         * Properties of a WifiDFUSlotStatus.
         * @exports IWifiDFUSlotStatus
         * @interface IWifiDFUSlotStatus
         * @property {boolean} valid WifiDFUSlotStatus valid
         * @property {Uint8Array} [sha256] WifiDFUSlotStatus sha256
         */
    
        /**
         * Constructs a new WifiDFUSlotStatus.
         * @exports WifiDFUSlotStatus
         * @classdesc Represents a WifiDFUSlotStatus.
         * @constructor
         * @param {IWifiDFUSlotStatus=} [properties] Properties to set
         */
        function WifiDFUSlotStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * WifiDFUSlotStatus valid.
         * @member {boolean}valid
         * @memberof WifiDFUSlotStatus
         * @instance
         */
        WifiDFUSlotStatus.prototype.valid = false;
    
        /**
         * WifiDFUSlotStatus sha256.
         * @member {Uint8Array}sha256
         * @memberof WifiDFUSlotStatus
         * @instance
         */
        WifiDFUSlotStatus.prototype.sha256 = $util.newBuffer([]);
    
        /**
         * Creates a new WifiDFUSlotStatus instance using the specified properties.
         * @function create
         * @memberof WifiDFUSlotStatus
         * @static
         * @param {IWifiDFUSlotStatus=} [properties] Properties to set
         * @returns {WifiDFUSlotStatus} WifiDFUSlotStatus instance
         */
        WifiDFUSlotStatus.create = function create(properties) {
            return new WifiDFUSlotStatus(properties);
        };
    
        /**
         * Encodes the specified WifiDFUSlotStatus message. Does not implicitly {@link WifiDFUSlotStatus.verify|verify} messages.
         * @function encode
         * @memberof WifiDFUSlotStatus
         * @static
         * @param {IWifiDFUSlotStatus} message WifiDFUSlotStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WifiDFUSlotStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.valid);
            if (message.sha256 != null && message.hasOwnProperty("sha256"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sha256);
            return writer;
        };
    
        /**
         * Encodes the specified WifiDFUSlotStatus message, length delimited. Does not implicitly {@link WifiDFUSlotStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof WifiDFUSlotStatus
         * @static
         * @param {IWifiDFUSlotStatus} message WifiDFUSlotStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WifiDFUSlotStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a WifiDFUSlotStatus message from the specified reader or buffer.
         * @function decode
         * @memberof WifiDFUSlotStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {WifiDFUSlotStatus} WifiDFUSlotStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WifiDFUSlotStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WifiDFUSlotStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.valid = reader.bool();
                    break;
                case 2:
                    message.sha256 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("valid"))
                throw $util.ProtocolError("missing required 'valid'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a WifiDFUSlotStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof WifiDFUSlotStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {WifiDFUSlotStatus} WifiDFUSlotStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WifiDFUSlotStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a WifiDFUSlotStatus message.
         * @function verify
         * @memberof WifiDFUSlotStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WifiDFUSlotStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.valid !== "boolean")
                return "valid: boolean expected";
            if (message.sha256 != null && message.hasOwnProperty("sha256"))
                if (!(message.sha256 && typeof message.sha256.length === "number" || $util.isString(message.sha256)))
                    return "sha256: buffer expected";
            return null;
        };
    
        /**
         * Creates a WifiDFUSlotStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof WifiDFUSlotStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {WifiDFUSlotStatus} WifiDFUSlotStatus
         */
        WifiDFUSlotStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.WifiDFUSlotStatus)
                return object;
            var message = new $root.WifiDFUSlotStatus();
            if (object.valid != null)
                message.valid = Boolean(object.valid);
            if (object.sha256 != null)
                if (typeof object.sha256 === "string")
                    $util.base64.decode(object.sha256, message.sha256 = $util.newBuffer($util.base64.length(object.sha256)), 0);
                else if (object.sha256.length)
                    message.sha256 = object.sha256;
            return message;
        };
    
        /**
         * Creates a plain object from a WifiDFUSlotStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof WifiDFUSlotStatus
         * @static
         * @param {WifiDFUSlotStatus} message WifiDFUSlotStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WifiDFUSlotStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.valid = false;
                object.sha256 = options.bytes === String ? "" : [];
            }
            if (message.valid != null && message.hasOwnProperty("valid"))
                object.valid = message.valid;
            if (message.sha256 != null && message.hasOwnProperty("sha256"))
                object.sha256 = options.bytes === String ? $util.base64.encode(message.sha256, 0, message.sha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.sha256) : message.sha256;
            return object;
        };
    
        /**
         * Converts this WifiDFUSlotStatus to JSON.
         * @function toJSON
         * @memberof WifiDFUSlotStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WifiDFUSlotStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return WifiDFUSlotStatus;
    })();
    
    $root.WifiDFUStatusReply = (function() {
    
        /**
         * Properties of a WifiDFUStatusReply.
         * @exports IWifiDFUStatusReply
         * @interface IWifiDFUStatusReply
         * @property {Result} result WifiDFUStatusReply result
         * @property {number} runningSlot WifiDFUStatusReply runningSlot
         * @property {Array.<IWifiDFUSlotStatus>} [slot] WifiDFUStatusReply slot
         */
    
        /**
         * Constructs a new WifiDFUStatusReply.
         * @exports WifiDFUStatusReply
         * @classdesc Represents a WifiDFUStatusReply.
         * @constructor
         * @param {IWifiDFUStatusReply=} [properties] Properties to set
         */
        function WifiDFUStatusReply(properties) {
            this.slot = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * WifiDFUStatusReply result.
         * @member {Result}result
         * @memberof WifiDFUStatusReply
         * @instance
         */
        WifiDFUStatusReply.prototype.result = 0;
    
        /**
         * WifiDFUStatusReply runningSlot.
         * @member {number}runningSlot
         * @memberof WifiDFUStatusReply
         * @instance
         */
        WifiDFUStatusReply.prototype.runningSlot = 0;
    
        /**
         * WifiDFUStatusReply slot.
         * @member {Array.<IWifiDFUSlotStatus>}slot
         * @memberof WifiDFUStatusReply
         * @instance
         */
        WifiDFUStatusReply.prototype.slot = $util.emptyArray;
    
        /**
         * Creates a new WifiDFUStatusReply instance using the specified properties.
         * @function create
         * @memberof WifiDFUStatusReply
         * @static
         * @param {IWifiDFUStatusReply=} [properties] Properties to set
         * @returns {WifiDFUStatusReply} WifiDFUStatusReply instance
         */
        WifiDFUStatusReply.create = function create(properties) {
            return new WifiDFUStatusReply(properties);
        };
    
        /**
         * Encodes the specified WifiDFUStatusReply message. Does not implicitly {@link WifiDFUStatusReply.verify|verify} messages.
         * @function encode
         * @memberof WifiDFUStatusReply
         * @static
         * @param {IWifiDFUStatusReply} message WifiDFUStatusReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WifiDFUStatusReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.runningSlot);
            if (message.slot != null && message.slot.length)
                for (var i = 0; i < message.slot.length; ++i)
                    $root.WifiDFUSlotStatus.encode(message.slot[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified WifiDFUStatusReply message, length delimited. Does not implicitly {@link WifiDFUStatusReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof WifiDFUStatusReply
         * @static
         * @param {IWifiDFUStatusReply} message WifiDFUStatusReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WifiDFUStatusReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a WifiDFUStatusReply message from the specified reader or buffer.
         * @function decode
         * @memberof WifiDFUStatusReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {WifiDFUStatusReply} WifiDFUStatusReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WifiDFUStatusReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WifiDFUStatusReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.runningSlot = reader.uint32();
                    break;
                case 3:
                    if (!(message.slot && message.slot.length))
                        message.slot = [];
                    message.slot.push($root.WifiDFUSlotStatus.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            if (!message.hasOwnProperty("runningSlot"))
                throw $util.ProtocolError("missing required 'runningSlot'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a WifiDFUStatusReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof WifiDFUStatusReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {WifiDFUStatusReply} WifiDFUStatusReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WifiDFUStatusReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a WifiDFUStatusReply message.
         * @function verify
         * @memberof WifiDFUStatusReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WifiDFUStatusReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.result) {
            default:
                return "result: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                break;
            }
            if (!$util.isInteger(message.runningSlot))
                return "runningSlot: integer expected";
            if (message.slot != null && message.hasOwnProperty("slot")) {
                if (!Array.isArray(message.slot))
                    return "slot: array expected";
                for (var i = 0; i < message.slot.length; ++i) {
                    var error = $root.WifiDFUSlotStatus.verify(message.slot[i]);
                    if (error)
                        return "slot." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a WifiDFUStatusReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof WifiDFUStatusReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {WifiDFUStatusReply} WifiDFUStatusReply
         */
        WifiDFUStatusReply.fromObject = function fromObject(object) {
            if (object instanceof $root.WifiDFUStatusReply)
                return object;
            var message = new $root.WifiDFUStatusReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            if (object.runningSlot != null)
                message.runningSlot = object.runningSlot >>> 0;
            if (object.slot) {
                if (!Array.isArray(object.slot))
                    throw TypeError(".WifiDFUStatusReply.slot: array expected");
                message.slot = [];
                for (var i = 0; i < object.slot.length; ++i) {
                    if (typeof object.slot[i] !== "object")
                        throw TypeError(".WifiDFUStatusReply.slot: object expected");
                    message.slot[i] = $root.WifiDFUSlotStatus.fromObject(object.slot[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a WifiDFUStatusReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof WifiDFUStatusReply
         * @static
         * @param {WifiDFUStatusReply} message WifiDFUStatusReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WifiDFUStatusReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.slot = [];
            if (options.defaults) {
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
                object.runningSlot = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            if (message.runningSlot != null && message.hasOwnProperty("runningSlot"))
                object.runningSlot = message.runningSlot;
            if (message.slot && message.slot.length) {
                object.slot = [];
                for (var j = 0; j < message.slot.length; ++j)
                    object.slot[j] = $root.WifiDFUSlotStatus.toObject(message.slot[j], options);
            }
            return object;
        };
    
        /**
         * Converts this WifiDFUStatusReply to JSON.
         * @function toJSON
         * @memberof WifiDFUStatusReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WifiDFUStatusReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return WifiDFUStatusReply;
    })();
    
    $root.WifiDFUSetFirmware = (function() {
    
        /**
         * Properties of a WifiDFUSetFirmware.
         * @exports IWifiDFUSetFirmware
         * @interface IWifiDFUSetFirmware
         * @property {Uint8Array} sha256 WifiDFUSetFirmware sha256
         */
    
        /**
         * Constructs a new WifiDFUSetFirmware.
         * @exports WifiDFUSetFirmware
         * @classdesc Represents a WifiDFUSetFirmware.
         * @constructor
         * @param {IWifiDFUSetFirmware=} [properties] Properties to set
         */
        function WifiDFUSetFirmware(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * WifiDFUSetFirmware sha256.
         * @member {Uint8Array}sha256
         * @memberof WifiDFUSetFirmware
         * @instance
         */
        WifiDFUSetFirmware.prototype.sha256 = $util.newBuffer([]);
    
        /**
         * Creates a new WifiDFUSetFirmware instance using the specified properties.
         * @function create
         * @memberof WifiDFUSetFirmware
         * @static
         * @param {IWifiDFUSetFirmware=} [properties] Properties to set
         * @returns {WifiDFUSetFirmware} WifiDFUSetFirmware instance
         */
        WifiDFUSetFirmware.create = function create(properties) {
            return new WifiDFUSetFirmware(properties);
        };
    
        /**
         * Encodes the specified WifiDFUSetFirmware message. Does not implicitly {@link WifiDFUSetFirmware.verify|verify} messages.
         * @function encode
         * @memberof WifiDFUSetFirmware
         * @static
         * @param {IWifiDFUSetFirmware} message WifiDFUSetFirmware message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WifiDFUSetFirmware.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sha256);
            return writer;
        };
    
        /**
         * Encodes the specified WifiDFUSetFirmware message, length delimited. Does not implicitly {@link WifiDFUSetFirmware.verify|verify} messages.
         * @function encodeDelimited
         * @memberof WifiDFUSetFirmware
         * @static
         * @param {IWifiDFUSetFirmware} message WifiDFUSetFirmware message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WifiDFUSetFirmware.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a WifiDFUSetFirmware message from the specified reader or buffer.
         * @function decode
         * @memberof WifiDFUSetFirmware
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {WifiDFUSetFirmware} WifiDFUSetFirmware
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WifiDFUSetFirmware.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WifiDFUSetFirmware();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sha256 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("sha256"))
                throw $util.ProtocolError("missing required 'sha256'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a WifiDFUSetFirmware message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof WifiDFUSetFirmware
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {WifiDFUSetFirmware} WifiDFUSetFirmware
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WifiDFUSetFirmware.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a WifiDFUSetFirmware message.
         * @function verify
         * @memberof WifiDFUSetFirmware
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WifiDFUSetFirmware.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!(message.sha256 && typeof message.sha256.length === "number" || $util.isString(message.sha256)))
                return "sha256: buffer expected";
            return null;
        };
    
        /**
         * Creates a WifiDFUSetFirmware message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof WifiDFUSetFirmware
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {WifiDFUSetFirmware} WifiDFUSetFirmware
         */
        WifiDFUSetFirmware.fromObject = function fromObject(object) {
            if (object instanceof $root.WifiDFUSetFirmware)
                return object;
            var message = new $root.WifiDFUSetFirmware();
            if (object.sha256 != null)
                if (typeof object.sha256 === "string")
                    $util.base64.decode(object.sha256, message.sha256 = $util.newBuffer($util.base64.length(object.sha256)), 0);
                else if (object.sha256.length)
                    message.sha256 = object.sha256;
            return message;
        };
    
        /**
         * Creates a plain object from a WifiDFUSetFirmware message. Also converts values to other types if specified.
         * @function toObject
         * @memberof WifiDFUSetFirmware
         * @static
         * @param {WifiDFUSetFirmware} message WifiDFUSetFirmware
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WifiDFUSetFirmware.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sha256 = options.bytes === String ? "" : [];
            if (message.sha256 != null && message.hasOwnProperty("sha256"))
                object.sha256 = options.bytes === String ? $util.base64.encode(message.sha256, 0, message.sha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.sha256) : message.sha256;
            return object;
        };
    
        /**
         * Converts this WifiDFUSetFirmware to JSON.
         * @function toJSON
         * @memberof WifiDFUSetFirmware
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WifiDFUSetFirmware.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return WifiDFUSetFirmware;
    })();
    
    $root.WifiDFUDownloadTFTPRequest = (function() {
    
        /**
         * Properties of a WifiDFUDownloadTFTPRequest.
         * @exports IWifiDFUDownloadTFTPRequest
         * @interface IWifiDFUDownloadTFTPRequest
         * @property {string} host WifiDFUDownloadTFTPRequest host
         * @property {string} filename WifiDFUDownloadTFTPRequest filename
         * @property {Uint8Array} sha256 WifiDFUDownloadTFTPRequest sha256
         * @property {boolean} [useHTTP] WifiDFUDownloadTFTPRequest useHTTP
         */
    
        /**
         * Constructs a new WifiDFUDownloadTFTPRequest.
         * @exports WifiDFUDownloadTFTPRequest
         * @classdesc Represents a WifiDFUDownloadTFTPRequest.
         * @constructor
         * @param {IWifiDFUDownloadTFTPRequest=} [properties] Properties to set
         */
        function WifiDFUDownloadTFTPRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * WifiDFUDownloadTFTPRequest host.
         * @member {string}host
         * @memberof WifiDFUDownloadTFTPRequest
         * @instance
         */
        WifiDFUDownloadTFTPRequest.prototype.host = "";
    
        /**
         * WifiDFUDownloadTFTPRequest filename.
         * @member {string}filename
         * @memberof WifiDFUDownloadTFTPRequest
         * @instance
         */
        WifiDFUDownloadTFTPRequest.prototype.filename = "";
    
        /**
         * WifiDFUDownloadTFTPRequest sha256.
         * @member {Uint8Array}sha256
         * @memberof WifiDFUDownloadTFTPRequest
         * @instance
         */
        WifiDFUDownloadTFTPRequest.prototype.sha256 = $util.newBuffer([]);
    
        /**
         * WifiDFUDownloadTFTPRequest useHTTP.
         * @member {boolean}useHTTP
         * @memberof WifiDFUDownloadTFTPRequest
         * @instance
         */
        WifiDFUDownloadTFTPRequest.prototype.useHTTP = false;
    
        /**
         * Creates a new WifiDFUDownloadTFTPRequest instance using the specified properties.
         * @function create
         * @memberof WifiDFUDownloadTFTPRequest
         * @static
         * @param {IWifiDFUDownloadTFTPRequest=} [properties] Properties to set
         * @returns {WifiDFUDownloadTFTPRequest} WifiDFUDownloadTFTPRequest instance
         */
        WifiDFUDownloadTFTPRequest.create = function create(properties) {
            return new WifiDFUDownloadTFTPRequest(properties);
        };
    
        /**
         * Encodes the specified WifiDFUDownloadTFTPRequest message. Does not implicitly {@link WifiDFUDownloadTFTPRequest.verify|verify} messages.
         * @function encode
         * @memberof WifiDFUDownloadTFTPRequest
         * @static
         * @param {IWifiDFUDownloadTFTPRequest} message WifiDFUDownloadTFTPRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WifiDFUDownloadTFTPRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.filename);
            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.sha256);
            if (message.useHTTP != null && message.hasOwnProperty("useHTTP"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.useHTTP);
            return writer;
        };
    
        /**
         * Encodes the specified WifiDFUDownloadTFTPRequest message, length delimited. Does not implicitly {@link WifiDFUDownloadTFTPRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof WifiDFUDownloadTFTPRequest
         * @static
         * @param {IWifiDFUDownloadTFTPRequest} message WifiDFUDownloadTFTPRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WifiDFUDownloadTFTPRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a WifiDFUDownloadTFTPRequest message from the specified reader or buffer.
         * @function decode
         * @memberof WifiDFUDownloadTFTPRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {WifiDFUDownloadTFTPRequest} WifiDFUDownloadTFTPRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WifiDFUDownloadTFTPRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WifiDFUDownloadTFTPRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                case 2:
                    message.filename = reader.string();
                    break;
                case 3:
                    message.sha256 = reader.bytes();
                    break;
                case 4:
                    message.useHTTP = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("host"))
                throw $util.ProtocolError("missing required 'host'", { instance: message });
            if (!message.hasOwnProperty("filename"))
                throw $util.ProtocolError("missing required 'filename'", { instance: message });
            if (!message.hasOwnProperty("sha256"))
                throw $util.ProtocolError("missing required 'sha256'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a WifiDFUDownloadTFTPRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof WifiDFUDownloadTFTPRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {WifiDFUDownloadTFTPRequest} WifiDFUDownloadTFTPRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WifiDFUDownloadTFTPRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a WifiDFUDownloadTFTPRequest message.
         * @function verify
         * @memberof WifiDFUDownloadTFTPRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WifiDFUDownloadTFTPRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.host))
                return "host: string expected";
            if (!$util.isString(message.filename))
                return "filename: string expected";
            if (!(message.sha256 && typeof message.sha256.length === "number" || $util.isString(message.sha256)))
                return "sha256: buffer expected";
            if (message.useHTTP != null && message.hasOwnProperty("useHTTP"))
                if (typeof message.useHTTP !== "boolean")
                    return "useHTTP: boolean expected";
            return null;
        };
    
        /**
         * Creates a WifiDFUDownloadTFTPRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof WifiDFUDownloadTFTPRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {WifiDFUDownloadTFTPRequest} WifiDFUDownloadTFTPRequest
         */
        WifiDFUDownloadTFTPRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.WifiDFUDownloadTFTPRequest)
                return object;
            var message = new $root.WifiDFUDownloadTFTPRequest();
            if (object.host != null)
                message.host = String(object.host);
            if (object.filename != null)
                message.filename = String(object.filename);
            if (object.sha256 != null)
                if (typeof object.sha256 === "string")
                    $util.base64.decode(object.sha256, message.sha256 = $util.newBuffer($util.base64.length(object.sha256)), 0);
                else if (object.sha256.length)
                    message.sha256 = object.sha256;
            if (object.useHTTP != null)
                message.useHTTP = Boolean(object.useHTTP);
            return message;
        };
    
        /**
         * Creates a plain object from a WifiDFUDownloadTFTPRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof WifiDFUDownloadTFTPRequest
         * @static
         * @param {WifiDFUDownloadTFTPRequest} message WifiDFUDownloadTFTPRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WifiDFUDownloadTFTPRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.host = "";
                object.filename = "";
                object.sha256 = options.bytes === String ? "" : [];
                object.useHTTP = false;
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.filename != null && message.hasOwnProperty("filename"))
                object.filename = message.filename;
            if (message.sha256 != null && message.hasOwnProperty("sha256"))
                object.sha256 = options.bytes === String ? $util.base64.encode(message.sha256, 0, message.sha256.length) : options.bytes === Array ? Array.prototype.slice.call(message.sha256) : message.sha256;
            if (message.useHTTP != null && message.hasOwnProperty("useHTTP"))
                object.useHTTP = message.useHTTP;
            return object;
        };
    
        /**
         * Converts this WifiDFUDownloadTFTPRequest to JSON.
         * @function toJSON
         * @memberof WifiDFUDownloadTFTPRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WifiDFUDownloadTFTPRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return WifiDFUDownloadTFTPRequest;
    })();
    
    /**
     * WifiDFUDownloadTFTPStatus enum.
     * @exports WifiDFUDownloadTFTPStatus
     * @enum {string}
     * @property {number} API_ERROR=-32 API_ERROR value
     * @property {number} FAILED=0 FAILED value
     * @property {number} SUCCESS=1 SUCCESS value
     * @property {number} ONGOING=2 ONGOING value
     * @property {number} FAILED_TIMEOUT=3 FAILED_TIMEOUT value
     * @property {number} FAILED_ROUTING=4 FAILED_ROUTING value
     * @property {number} FAILED_SHASUM=5 FAILED_SHASUM value
     * @property {number} FAILED_SLOT_ACTIVE=6 FAILED_SLOT_ACTIVE value
     * @property {number} FAILED_SLOT_FACTORY=7 FAILED_SLOT_FACTORY value
     * @property {number} FAILED_SLOT_INVALID=8 FAILED_SLOT_INVALID value
     * @property {number} FAILED_BAD_IMAGE=9 FAILED_BAD_IMAGE value
     * @property {number} FAILED_BAD_ADDRESS=10 FAILED_BAD_ADDRESS value
     */
    $root.WifiDFUDownloadTFTPStatus = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-32] = "API_ERROR"] = -32;
        values[valuesById[0] = "FAILED"] = 0;
        values[valuesById[1] = "SUCCESS"] = 1;
        values[valuesById[2] = "ONGOING"] = 2;
        values[valuesById[3] = "FAILED_TIMEOUT"] = 3;
        values[valuesById[4] = "FAILED_ROUTING"] = 4;
        values[valuesById[5] = "FAILED_SHASUM"] = 5;
        values[valuesById[6] = "FAILED_SLOT_ACTIVE"] = 6;
        values[valuesById[7] = "FAILED_SLOT_FACTORY"] = 7;
        values[valuesById[8] = "FAILED_SLOT_INVALID"] = 8;
        values[valuesById[9] = "FAILED_BAD_IMAGE"] = 9;
        values[valuesById[10] = "FAILED_BAD_ADDRESS"] = 10;
        return values;
    })();
    
    $root.WifiDFUDownloadTFTPResponse = (function() {
    
        /**
         * Properties of a WifiDFUDownloadTFTPResponse.
         * @exports IWifiDFUDownloadTFTPResponse
         * @interface IWifiDFUDownloadTFTPResponse
         * @property {WifiDFUDownloadTFTPStatus} status WifiDFUDownloadTFTPResponse status
         * @property {number} [bytesRead] WifiDFUDownloadTFTPResponse bytesRead
         */
    
        /**
         * Constructs a new WifiDFUDownloadTFTPResponse.
         * @exports WifiDFUDownloadTFTPResponse
         * @classdesc Represents a WifiDFUDownloadTFTPResponse.
         * @constructor
         * @param {IWifiDFUDownloadTFTPResponse=} [properties] Properties to set
         */
        function WifiDFUDownloadTFTPResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * WifiDFUDownloadTFTPResponse status.
         * @member {WifiDFUDownloadTFTPStatus}status
         * @memberof WifiDFUDownloadTFTPResponse
         * @instance
         */
        WifiDFUDownloadTFTPResponse.prototype.status = -32;
    
        /**
         * WifiDFUDownloadTFTPResponse bytesRead.
         * @member {number}bytesRead
         * @memberof WifiDFUDownloadTFTPResponse
         * @instance
         */
        WifiDFUDownloadTFTPResponse.prototype.bytesRead = 0;
    
        /**
         * Creates a new WifiDFUDownloadTFTPResponse instance using the specified properties.
         * @function create
         * @memberof WifiDFUDownloadTFTPResponse
         * @static
         * @param {IWifiDFUDownloadTFTPResponse=} [properties] Properties to set
         * @returns {WifiDFUDownloadTFTPResponse} WifiDFUDownloadTFTPResponse instance
         */
        WifiDFUDownloadTFTPResponse.create = function create(properties) {
            return new WifiDFUDownloadTFTPResponse(properties);
        };
    
        /**
         * Encodes the specified WifiDFUDownloadTFTPResponse message. Does not implicitly {@link WifiDFUDownloadTFTPResponse.verify|verify} messages.
         * @function encode
         * @memberof WifiDFUDownloadTFTPResponse
         * @static
         * @param {IWifiDFUDownloadTFTPResponse} message WifiDFUDownloadTFTPResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WifiDFUDownloadTFTPResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.bytesRead != null && message.hasOwnProperty("bytesRead"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.bytesRead);
            return writer;
        };
    
        /**
         * Encodes the specified WifiDFUDownloadTFTPResponse message, length delimited. Does not implicitly {@link WifiDFUDownloadTFTPResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof WifiDFUDownloadTFTPResponse
         * @static
         * @param {IWifiDFUDownloadTFTPResponse} message WifiDFUDownloadTFTPResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WifiDFUDownloadTFTPResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a WifiDFUDownloadTFTPResponse message from the specified reader or buffer.
         * @function decode
         * @memberof WifiDFUDownloadTFTPResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {WifiDFUDownloadTFTPResponse} WifiDFUDownloadTFTPResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WifiDFUDownloadTFTPResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WifiDFUDownloadTFTPResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    message.bytesRead = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a WifiDFUDownloadTFTPResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof WifiDFUDownloadTFTPResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {WifiDFUDownloadTFTPResponse} WifiDFUDownloadTFTPResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WifiDFUDownloadTFTPResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a WifiDFUDownloadTFTPResponse message.
         * @function verify
         * @memberof WifiDFUDownloadTFTPResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WifiDFUDownloadTFTPResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.status) {
            default:
                return "status: enum value expected";
            case -32:
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
                break;
            }
            if (message.bytesRead != null && message.hasOwnProperty("bytesRead"))
                if (!$util.isInteger(message.bytesRead))
                    return "bytesRead: integer expected";
            return null;
        };
    
        /**
         * Creates a WifiDFUDownloadTFTPResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof WifiDFUDownloadTFTPResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {WifiDFUDownloadTFTPResponse} WifiDFUDownloadTFTPResponse
         */
        WifiDFUDownloadTFTPResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.WifiDFUDownloadTFTPResponse)
                return object;
            var message = new $root.WifiDFUDownloadTFTPResponse();
            switch (object.status) {
            case "API_ERROR":
            case -32:
                message.status = -32;
                break;
            case "FAILED":
            case 0:
                message.status = 0;
                break;
            case "SUCCESS":
            case 1:
                message.status = 1;
                break;
            case "ONGOING":
            case 2:
                message.status = 2;
                break;
            case "FAILED_TIMEOUT":
            case 3:
                message.status = 3;
                break;
            case "FAILED_ROUTING":
            case 4:
                message.status = 4;
                break;
            case "FAILED_SHASUM":
            case 5:
                message.status = 5;
                break;
            case "FAILED_SLOT_ACTIVE":
            case 6:
                message.status = 6;
                break;
            case "FAILED_SLOT_FACTORY":
            case 7:
                message.status = 7;
                break;
            case "FAILED_SLOT_INVALID":
            case 8:
                message.status = 8;
                break;
            case "FAILED_BAD_IMAGE":
            case 9:
                message.status = 9;
                break;
            case "FAILED_BAD_ADDRESS":
            case 10:
                message.status = 10;
                break;
            }
            if (object.bytesRead != null)
                message.bytesRead = object.bytesRead >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a WifiDFUDownloadTFTPResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof WifiDFUDownloadTFTPResponse
         * @static
         * @param {WifiDFUDownloadTFTPResponse} message WifiDFUDownloadTFTPResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WifiDFUDownloadTFTPResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.status = options.enums === String ? "API_ERROR" : -32;
                object.bytesRead = 0;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.WifiDFUDownloadTFTPStatus[message.status] : message.status;
            if (message.bytesRead != null && message.hasOwnProperty("bytesRead"))
                object.bytesRead = message.bytesRead;
            return object;
        };
    
        /**
         * Converts this WifiDFUDownloadTFTPResponse to JSON.
         * @function toJSON
         * @memberof WifiDFUDownloadTFTPResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WifiDFUDownloadTFTPResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return WifiDFUDownloadTFTPResponse;
    })();
    
    $root.DescribeFeedRequest = (function() {
    
        /**
         * Properties of a DescribeFeedRequest.
         * @exports IDescribeFeedRequest
         * @interface IDescribeFeedRequest
         * @property {number} feedId DescribeFeedRequest feedId
         */
    
        /**
         * Constructs a new DescribeFeedRequest.
         * @exports DescribeFeedRequest
         * @classdesc Represents a DescribeFeedRequest.
         * @constructor
         * @param {IDescribeFeedRequest=} [properties] Properties to set
         */
        function DescribeFeedRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * DescribeFeedRequest feedId.
         * @member {number}feedId
         * @memberof DescribeFeedRequest
         * @instance
         */
        DescribeFeedRequest.prototype.feedId = 0;
    
        /**
         * Creates a new DescribeFeedRequest instance using the specified properties.
         * @function create
         * @memberof DescribeFeedRequest
         * @static
         * @param {IDescribeFeedRequest=} [properties] Properties to set
         * @returns {DescribeFeedRequest} DescribeFeedRequest instance
         */
        DescribeFeedRequest.create = function create(properties) {
            return new DescribeFeedRequest(properties);
        };
    
        /**
         * Encodes the specified DescribeFeedRequest message. Does not implicitly {@link DescribeFeedRequest.verify|verify} messages.
         * @function encode
         * @memberof DescribeFeedRequest
         * @static
         * @param {IDescribeFeedRequest} message DescribeFeedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DescribeFeedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.feedId);
            return writer;
        };
    
        /**
         * Encodes the specified DescribeFeedRequest message, length delimited. Does not implicitly {@link DescribeFeedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DescribeFeedRequest
         * @static
         * @param {IDescribeFeedRequest} message DescribeFeedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DescribeFeedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a DescribeFeedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof DescribeFeedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DescribeFeedRequest} DescribeFeedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DescribeFeedRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DescribeFeedRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.feedId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("feedId"))
                throw $util.ProtocolError("missing required 'feedId'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a DescribeFeedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DescribeFeedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DescribeFeedRequest} DescribeFeedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DescribeFeedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a DescribeFeedRequest message.
         * @function verify
         * @memberof DescribeFeedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DescribeFeedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.feedId))
                return "feedId: integer expected";
            return null;
        };
    
        /**
         * Creates a DescribeFeedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DescribeFeedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DescribeFeedRequest} DescribeFeedRequest
         */
        DescribeFeedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.DescribeFeedRequest)
                return object;
            var message = new $root.DescribeFeedRequest();
            if (object.feedId != null)
                message.feedId = object.feedId >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a DescribeFeedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DescribeFeedRequest
         * @static
         * @param {DescribeFeedRequest} message DescribeFeedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DescribeFeedRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.feedId = 0;
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                object.feedId = message.feedId;
            return object;
        };
    
        /**
         * Converts this DescribeFeedRequest to JSON.
         * @function toJSON
         * @memberof DescribeFeedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DescribeFeedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return DescribeFeedRequest;
    })();
    
    $root.DescribeFeedReply = (function() {
    
        /**
         * Properties of a DescribeFeedReply.
         * @exports IDescribeFeedReply
         * @interface IDescribeFeedReply
         * @property {number} feedId DescribeFeedReply feedId
         * @property {ICirculatorProgram} [circulatorProgram] DescribeFeedReply circulatorProgram
         * @property {Result} [result] DescribeFeedReply result
         */
    
        /**
         * Constructs a new DescribeFeedReply.
         * @exports DescribeFeedReply
         * @classdesc Represents a DescribeFeedReply.
         * @constructor
         * @param {IDescribeFeedReply=} [properties] Properties to set
         */
        function DescribeFeedReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * DescribeFeedReply feedId.
         * @member {number}feedId
         * @memberof DescribeFeedReply
         * @instance
         */
        DescribeFeedReply.prototype.feedId = 0;
    
        /**
         * DescribeFeedReply circulatorProgram.
         * @member {(ICirculatorProgram|null|undefined)}circulatorProgram
         * @memberof DescribeFeedReply
         * @instance
         */
        DescribeFeedReply.prototype.circulatorProgram = null;
    
        /**
         * DescribeFeedReply result.
         * @member {Result}result
         * @memberof DescribeFeedReply
         * @instance
         */
        DescribeFeedReply.prototype.result = 0;
    
        /**
         * Creates a new DescribeFeedReply instance using the specified properties.
         * @function create
         * @memberof DescribeFeedReply
         * @static
         * @param {IDescribeFeedReply=} [properties] Properties to set
         * @returns {DescribeFeedReply} DescribeFeedReply instance
         */
        DescribeFeedReply.create = function create(properties) {
            return new DescribeFeedReply(properties);
        };
    
        /**
         * Encodes the specified DescribeFeedReply message. Does not implicitly {@link DescribeFeedReply.verify|verify} messages.
         * @function encode
         * @memberof DescribeFeedReply
         * @static
         * @param {IDescribeFeedReply} message DescribeFeedReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DescribeFeedReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.feedId);
            if (message.circulatorProgram != null && message.hasOwnProperty("circulatorProgram"))
                $root.CirculatorProgram.encode(message.circulatorProgram, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified DescribeFeedReply message, length delimited. Does not implicitly {@link DescribeFeedReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DescribeFeedReply
         * @static
         * @param {IDescribeFeedReply} message DescribeFeedReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DescribeFeedReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a DescribeFeedReply message from the specified reader or buffer.
         * @function decode
         * @memberof DescribeFeedReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DescribeFeedReply} DescribeFeedReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DescribeFeedReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DescribeFeedReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.feedId = reader.uint32();
                    break;
                case 2:
                    message.circulatorProgram = $root.CirculatorProgram.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("feedId"))
                throw $util.ProtocolError("missing required 'feedId'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a DescribeFeedReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DescribeFeedReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DescribeFeedReply} DescribeFeedReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DescribeFeedReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a DescribeFeedReply message.
         * @function verify
         * @memberof DescribeFeedReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DescribeFeedReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.feedId))
                return "feedId: integer expected";
            if (message.circulatorProgram != null && message.hasOwnProperty("circulatorProgram")) {
                var error = $root.CirculatorProgram.verify(message.circulatorProgram);
                if (error)
                    return "circulatorProgram." + error;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a DescribeFeedReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DescribeFeedReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DescribeFeedReply} DescribeFeedReply
         */
        DescribeFeedReply.fromObject = function fromObject(object) {
            if (object instanceof $root.DescribeFeedReply)
                return object;
            var message = new $root.DescribeFeedReply();
            if (object.feedId != null)
                message.feedId = object.feedId >>> 0;
            if (object.circulatorProgram != null) {
                if (typeof object.circulatorProgram !== "object")
                    throw TypeError(".DescribeFeedReply.circulatorProgram: object expected");
                message.circulatorProgram = $root.CirculatorProgram.fromObject(object.circulatorProgram);
            }
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a DescribeFeedReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DescribeFeedReply
         * @static
         * @param {DescribeFeedReply} message DescribeFeedReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DescribeFeedReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.feedId = 0;
                object.circulatorProgram = null;
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            }
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                object.feedId = message.feedId;
            if (message.circulatorProgram != null && message.hasOwnProperty("circulatorProgram"))
                object.circulatorProgram = $root.CirculatorProgram.toObject(message.circulatorProgram, options);
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this DescribeFeedReply to JSON.
         * @function toJSON
         * @memberof DescribeFeedReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DescribeFeedReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return DescribeFeedReply;
    })();
    
    $root.ListFeedsRequest = (function() {
    
        /**
         * Properties of a ListFeedsRequest.
         * @exports IListFeedsRequest
         * @interface IListFeedsRequest
         */
    
        /**
         * Constructs a new ListFeedsRequest.
         * @exports ListFeedsRequest
         * @classdesc Represents a ListFeedsRequest.
         * @constructor
         * @param {IListFeedsRequest=} [properties] Properties to set
         */
        function ListFeedsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new ListFeedsRequest instance using the specified properties.
         * @function create
         * @memberof ListFeedsRequest
         * @static
         * @param {IListFeedsRequest=} [properties] Properties to set
         * @returns {ListFeedsRequest} ListFeedsRequest instance
         */
        ListFeedsRequest.create = function create(properties) {
            return new ListFeedsRequest(properties);
        };
    
        /**
         * Encodes the specified ListFeedsRequest message. Does not implicitly {@link ListFeedsRequest.verify|verify} messages.
         * @function encode
         * @memberof ListFeedsRequest
         * @static
         * @param {IListFeedsRequest} message ListFeedsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListFeedsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified ListFeedsRequest message, length delimited. Does not implicitly {@link ListFeedsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ListFeedsRequest
         * @static
         * @param {IListFeedsRequest} message ListFeedsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListFeedsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ListFeedsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ListFeedsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ListFeedsRequest} ListFeedsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListFeedsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListFeedsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ListFeedsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ListFeedsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ListFeedsRequest} ListFeedsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListFeedsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ListFeedsRequest message.
         * @function verify
         * @memberof ListFeedsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListFeedsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a ListFeedsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ListFeedsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ListFeedsRequest} ListFeedsRequest
         */
        ListFeedsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ListFeedsRequest)
                return object;
            return new $root.ListFeedsRequest();
        };
    
        /**
         * Creates a plain object from a ListFeedsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ListFeedsRequest
         * @static
         * @param {ListFeedsRequest} message ListFeedsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListFeedsRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this ListFeedsRequest to JSON.
         * @function toJSON
         * @memberof ListFeedsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListFeedsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ListFeedsRequest;
    })();
    
    $root.ListFeedsReply = (function() {
    
        /**
         * Properties of a ListFeedsReply.
         * @exports IListFeedsReply
         * @interface IListFeedsReply
         * @property {number} feedId ListFeedsReply feedId
         * @property {FeedType} feedType ListFeedsReply feedType
         * @property {boolean} [active] ListFeedsReply active
         * @property {Result} [result] ListFeedsReply result
         */
    
        /**
         * Constructs a new ListFeedsReply.
         * @exports ListFeedsReply
         * @classdesc Represents a ListFeedsReply.
         * @constructor
         * @param {IListFeedsReply=} [properties] Properties to set
         */
        function ListFeedsReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ListFeedsReply feedId.
         * @member {number}feedId
         * @memberof ListFeedsReply
         * @instance
         */
        ListFeedsReply.prototype.feedId = 0;
    
        /**
         * ListFeedsReply feedType.
         * @member {FeedType}feedType
         * @memberof ListFeedsReply
         * @instance
         */
        ListFeedsReply.prototype.feedType = 1;
    
        /**
         * ListFeedsReply active.
         * @member {boolean}active
         * @memberof ListFeedsReply
         * @instance
         */
        ListFeedsReply.prototype.active = false;
    
        /**
         * ListFeedsReply result.
         * @member {Result}result
         * @memberof ListFeedsReply
         * @instance
         */
        ListFeedsReply.prototype.result = 0;
    
        /**
         * Creates a new ListFeedsReply instance using the specified properties.
         * @function create
         * @memberof ListFeedsReply
         * @static
         * @param {IListFeedsReply=} [properties] Properties to set
         * @returns {ListFeedsReply} ListFeedsReply instance
         */
        ListFeedsReply.create = function create(properties) {
            return new ListFeedsReply(properties);
        };
    
        /**
         * Encodes the specified ListFeedsReply message. Does not implicitly {@link ListFeedsReply.verify|verify} messages.
         * @function encode
         * @memberof ListFeedsReply
         * @static
         * @param {IListFeedsReply} message ListFeedsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListFeedsReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.feedId);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.feedType);
            if (message.active != null && message.hasOwnProperty("active"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.active);
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified ListFeedsReply message, length delimited. Does not implicitly {@link ListFeedsReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ListFeedsReply
         * @static
         * @param {IListFeedsReply} message ListFeedsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListFeedsReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ListFeedsReply message from the specified reader or buffer.
         * @function decode
         * @memberof ListFeedsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ListFeedsReply} ListFeedsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListFeedsReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ListFeedsReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.feedId = reader.uint32();
                    break;
                case 2:
                    message.feedType = reader.int32();
                    break;
                case 3:
                    message.active = reader.bool();
                    break;
                case 4:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("feedId"))
                throw $util.ProtocolError("missing required 'feedId'", { instance: message });
            if (!message.hasOwnProperty("feedType"))
                throw $util.ProtocolError("missing required 'feedType'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a ListFeedsReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ListFeedsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ListFeedsReply} ListFeedsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListFeedsReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ListFeedsReply message.
         * @function verify
         * @memberof ListFeedsReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListFeedsReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.feedId))
                return "feedId: integer expected";
            switch (message.feedType) {
            default:
                return "feedType: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
            if (message.active != null && message.hasOwnProperty("active"))
                if (typeof message.active !== "boolean")
                    return "active: boolean expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a ListFeedsReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ListFeedsReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ListFeedsReply} ListFeedsReply
         */
        ListFeedsReply.fromObject = function fromObject(object) {
            if (object instanceof $root.ListFeedsReply)
                return object;
            var message = new $root.ListFeedsReply();
            if (object.feedId != null)
                message.feedId = object.feedId >>> 0;
            switch (object.feedType) {
            case "COOK_DATA":
            case 1:
                message.feedType = 1;
                break;
            case "DEBUG":
            case 2:
                message.feedType = 2;
                break;
            case "NETWORK_BLUETOOTH":
            case 3:
                message.feedType = 3;
                break;
            case "NETWORK_WIFI":
            case 4:
                message.feedType = 4;
                break;
            }
            if (object.active != null)
                message.active = Boolean(object.active);
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a ListFeedsReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ListFeedsReply
         * @static
         * @param {ListFeedsReply} message ListFeedsReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListFeedsReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.feedId = 0;
                object.feedType = options.enums === String ? "COOK_DATA" : 1;
                object.active = false;
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            }
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                object.feedId = message.feedId;
            if (message.feedType != null && message.hasOwnProperty("feedType"))
                object.feedType = options.enums === String ? $root.FeedType[message.feedType] : message.feedType;
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this ListFeedsReply to JSON.
         * @function toJSON
         * @memberof ListFeedsReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListFeedsReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ListFeedsReply;
    })();
    
    /**
     * FeedType enum.
     * @exports FeedType
     * @enum {string}
     * @property {number} COOK_DATA=1 COOK_DATA value
     * @property {number} DEBUG=2 DEBUG value
     * @property {number} NETWORK_BLUETOOTH=3 NETWORK_BLUETOOTH value
     * @property {number} NETWORK_WIFI=4 NETWORK_WIFI value
     */
    $root.FeedType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "COOK_DATA"] = 1;
        values[valuesById[2] = "DEBUG"] = 2;
        values[valuesById[3] = "NETWORK_BLUETOOTH"] = 3;
        values[valuesById[4] = "NETWORK_WIFI"] = 4;
        return values;
    })();
    
    $root.BeginLiveFeed = (function() {
    
        /**
         * Properties of a BeginLiveFeed.
         * @exports IBeginLiveFeed
         * @interface IBeginLiveFeed
         * @property {FeedType} feedType BeginLiveFeed feedType
         */
    
        /**
         * Constructs a new BeginLiveFeed.
         * @exports BeginLiveFeed
         * @classdesc Represents a BeginLiveFeed.
         * @constructor
         * @param {IBeginLiveFeed=} [properties] Properties to set
         */
        function BeginLiveFeed(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * BeginLiveFeed feedType.
         * @member {FeedType}feedType
         * @memberof BeginLiveFeed
         * @instance
         */
        BeginLiveFeed.prototype.feedType = 1;
    
        /**
         * Creates a new BeginLiveFeed instance using the specified properties.
         * @function create
         * @memberof BeginLiveFeed
         * @static
         * @param {IBeginLiveFeed=} [properties] Properties to set
         * @returns {BeginLiveFeed} BeginLiveFeed instance
         */
        BeginLiveFeed.create = function create(properties) {
            return new BeginLiveFeed(properties);
        };
    
        /**
         * Encodes the specified BeginLiveFeed message. Does not implicitly {@link BeginLiveFeed.verify|verify} messages.
         * @function encode
         * @memberof BeginLiveFeed
         * @static
         * @param {IBeginLiveFeed} message BeginLiveFeed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginLiveFeed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.feedType);
            return writer;
        };
    
        /**
         * Encodes the specified BeginLiveFeed message, length delimited. Does not implicitly {@link BeginLiveFeed.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BeginLiveFeed
         * @static
         * @param {IBeginLiveFeed} message BeginLiveFeed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginLiveFeed.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a BeginLiveFeed message from the specified reader or buffer.
         * @function decode
         * @memberof BeginLiveFeed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BeginLiveFeed} BeginLiveFeed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginLiveFeed.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BeginLiveFeed();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.feedType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("feedType"))
                throw $util.ProtocolError("missing required 'feedType'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a BeginLiveFeed message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BeginLiveFeed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BeginLiveFeed} BeginLiveFeed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginLiveFeed.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a BeginLiveFeed message.
         * @function verify
         * @memberof BeginLiveFeed
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginLiveFeed.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.feedType) {
            default:
                return "feedType: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
            return null;
        };
    
        /**
         * Creates a BeginLiveFeed message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BeginLiveFeed
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BeginLiveFeed} BeginLiveFeed
         */
        BeginLiveFeed.fromObject = function fromObject(object) {
            if (object instanceof $root.BeginLiveFeed)
                return object;
            var message = new $root.BeginLiveFeed();
            switch (object.feedType) {
            case "COOK_DATA":
            case 1:
                message.feedType = 1;
                break;
            case "DEBUG":
            case 2:
                message.feedType = 2;
                break;
            case "NETWORK_BLUETOOTH":
            case 3:
                message.feedType = 3;
                break;
            case "NETWORK_WIFI":
            case 4:
                message.feedType = 4;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a BeginLiveFeed message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BeginLiveFeed
         * @static
         * @param {BeginLiveFeed} message BeginLiveFeed
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BeginLiveFeed.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.feedType = options.enums === String ? "COOK_DATA" : 1;
            if (message.feedType != null && message.hasOwnProperty("feedType"))
                object.feedType = options.enums === String ? $root.FeedType[message.feedType] : message.feedType;
            return object;
        };
    
        /**
         * Converts this BeginLiveFeed to JSON.
         * @function toJSON
         * @memberof BeginLiveFeed
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BeginLiveFeed.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return BeginLiveFeed;
    })();
    
    $root.BeginLiveFeedReply = (function() {
    
        /**
         * Properties of a BeginLiveFeedReply.
         * @exports IBeginLiveFeedReply
         * @interface IBeginLiveFeedReply
         * @property {Result} [result] BeginLiveFeedReply result
         */
    
        /**
         * Constructs a new BeginLiveFeedReply.
         * @exports BeginLiveFeedReply
         * @classdesc Represents a BeginLiveFeedReply.
         * @constructor
         * @param {IBeginLiveFeedReply=} [properties] Properties to set
         */
        function BeginLiveFeedReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * BeginLiveFeedReply result.
         * @member {Result}result
         * @memberof BeginLiveFeedReply
         * @instance
         */
        BeginLiveFeedReply.prototype.result = 0;
    
        /**
         * Creates a new BeginLiveFeedReply instance using the specified properties.
         * @function create
         * @memberof BeginLiveFeedReply
         * @static
         * @param {IBeginLiveFeedReply=} [properties] Properties to set
         * @returns {BeginLiveFeedReply} BeginLiveFeedReply instance
         */
        BeginLiveFeedReply.create = function create(properties) {
            return new BeginLiveFeedReply(properties);
        };
    
        /**
         * Encodes the specified BeginLiveFeedReply message. Does not implicitly {@link BeginLiveFeedReply.verify|verify} messages.
         * @function encode
         * @memberof BeginLiveFeedReply
         * @static
         * @param {IBeginLiveFeedReply} message BeginLiveFeedReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginLiveFeedReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified BeginLiveFeedReply message, length delimited. Does not implicitly {@link BeginLiveFeedReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BeginLiveFeedReply
         * @static
         * @param {IBeginLiveFeedReply} message BeginLiveFeedReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginLiveFeedReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a BeginLiveFeedReply message from the specified reader or buffer.
         * @function decode
         * @memberof BeginLiveFeedReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BeginLiveFeedReply} BeginLiveFeedReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginLiveFeedReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BeginLiveFeedReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a BeginLiveFeedReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BeginLiveFeedReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BeginLiveFeedReply} BeginLiveFeedReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginLiveFeedReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a BeginLiveFeedReply message.
         * @function verify
         * @memberof BeginLiveFeedReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginLiveFeedReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a BeginLiveFeedReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BeginLiveFeedReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BeginLiveFeedReply} BeginLiveFeedReply
         */
        BeginLiveFeedReply.fromObject = function fromObject(object) {
            if (object instanceof $root.BeginLiveFeedReply)
                return object;
            var message = new $root.BeginLiveFeedReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a BeginLiveFeedReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BeginLiveFeedReply
         * @static
         * @param {BeginLiveFeedReply} message BeginLiveFeedReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BeginLiveFeedReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this BeginLiveFeedReply to JSON.
         * @function toJSON
         * @memberof BeginLiveFeedReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BeginLiveFeedReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return BeginLiveFeedReply;
    })();
    
    $root.BeginLiveFeedError = (function() {
    
        /**
         * Properties of a BeginLiveFeedError.
         * @exports IBeginLiveFeedError
         * @interface IBeginLiveFeedError
         */
    
        /**
         * Constructs a new BeginLiveFeedError.
         * @exports BeginLiveFeedError
         * @classdesc Represents a BeginLiveFeedError.
         * @constructor
         * @param {IBeginLiveFeedError=} [properties] Properties to set
         */
        function BeginLiveFeedError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new BeginLiveFeedError instance using the specified properties.
         * @function create
         * @memberof BeginLiveFeedError
         * @static
         * @param {IBeginLiveFeedError=} [properties] Properties to set
         * @returns {BeginLiveFeedError} BeginLiveFeedError instance
         */
        BeginLiveFeedError.create = function create(properties) {
            return new BeginLiveFeedError(properties);
        };
    
        /**
         * Encodes the specified BeginLiveFeedError message. Does not implicitly {@link BeginLiveFeedError.verify|verify} messages.
         * @function encode
         * @memberof BeginLiveFeedError
         * @static
         * @param {IBeginLiveFeedError} message BeginLiveFeedError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginLiveFeedError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified BeginLiveFeedError message, length delimited. Does not implicitly {@link BeginLiveFeedError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BeginLiveFeedError
         * @static
         * @param {IBeginLiveFeedError} message BeginLiveFeedError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginLiveFeedError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a BeginLiveFeedError message from the specified reader or buffer.
         * @function decode
         * @memberof BeginLiveFeedError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BeginLiveFeedError} BeginLiveFeedError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginLiveFeedError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BeginLiveFeedError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a BeginLiveFeedError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BeginLiveFeedError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BeginLiveFeedError} BeginLiveFeedError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginLiveFeedError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a BeginLiveFeedError message.
         * @function verify
         * @memberof BeginLiveFeedError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginLiveFeedError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a BeginLiveFeedError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BeginLiveFeedError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BeginLiveFeedError} BeginLiveFeedError
         */
        BeginLiveFeedError.fromObject = function fromObject(object) {
            if (object instanceof $root.BeginLiveFeedError)
                return object;
            return new $root.BeginLiveFeedError();
        };
    
        /**
         * Creates a plain object from a BeginLiveFeedError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BeginLiveFeedError
         * @static
         * @param {BeginLiveFeedError} message BeginLiveFeedError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BeginLiveFeedError.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this BeginLiveFeedError to JSON.
         * @function toJSON
         * @memberof BeginLiveFeedError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BeginLiveFeedError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * LiveFeedErrorType enum.
         * @enum {string}
         * @property {number} NO_ACTIVE_FEED=1 NO_ACTIVE_FEED value
         */
        BeginLiveFeedError.LiveFeedErrorType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "NO_ACTIVE_FEED"] = 1;
            return values;
        })();
    
        return BeginLiveFeedError;
    })();
    
    $root.CirculatorDataPoint = (function() {
    
        /**
         * Properties of a CirculatorDataPoint.
         * @exports ICirculatorDataPoint
         * @interface ICirculatorDataPoint
         * @property {number} feedId CirculatorDataPoint feedId
         * @property {number} sequenceNumber CirculatorDataPoint sequenceNumber
         * @property {number} timestamp CirculatorDataPoint timestamp
         * @property {ErrorState} [errorState] CirculatorDataPoint errorState
         * @property {number} bathTemp CirculatorDataPoint bathTemp
         * @property {ProgramStep} [programStep] CirculatorDataPoint programStep
         * @property {number} [timeRemaining] CirculatorDataPoint timeRemaining
         * @property {number} [heaterTemp] CirculatorDataPoint heaterTemp
         * @property {number} [upperBoardTemp] CirculatorDataPoint upperBoardTemp
         * @property {number} [lowerBoardTemp] CirculatorDataPoint lowerBoardTemp
         * @property {number} [motorRPM] CirculatorDataPoint motorRPM
         * @property {number} [heaterPWM] CirculatorDataPoint heaterPWM
         * @property {number} [motorVoltage] CirculatorDataPoint motorVoltage
         * @property {number} [motorPWM] CirculatorDataPoint motorPWM
         * @property {number} [motorCurrent] CirculatorDataPoint motorCurrent
         * @property {number} [pressure] CirculatorDataPoint pressure
         * @property {number} [motorFaultFlag] CirculatorDataPoint motorFaultFlag
         * @property {number} [motorPeakCurrent] CirculatorDataPoint motorPeakCurrent
         */
    
        /**
         * Constructs a new CirculatorDataPoint.
         * @exports CirculatorDataPoint
         * @classdesc Represents a CirculatorDataPoint.
         * @constructor
         * @param {ICirculatorDataPoint=} [properties] Properties to set
         */
        function CirculatorDataPoint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CirculatorDataPoint feedId.
         * @member {number}feedId
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.feedId = 0;
    
        /**
         * CirculatorDataPoint sequenceNumber.
         * @member {number}sequenceNumber
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.sequenceNumber = 0;
    
        /**
         * CirculatorDataPoint timestamp.
         * @member {number}timestamp
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.timestamp = 0;
    
        /**
         * CirculatorDataPoint errorState.
         * @member {ErrorState}errorState
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.errorState = 0;
    
        /**
         * CirculatorDataPoint bathTemp.
         * @member {number}bathTemp
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.bathTemp = 0;
    
        /**
         * CirculatorDataPoint programStep.
         * @member {ProgramStep}programStep
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.programStep = 0;
    
        /**
         * CirculatorDataPoint timeRemaining.
         * @member {number}timeRemaining
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.timeRemaining = 0;
    
        /**
         * CirculatorDataPoint heaterTemp.
         * @member {number}heaterTemp
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.heaterTemp = 0;
    
        /**
         * CirculatorDataPoint upperBoardTemp.
         * @member {number}upperBoardTemp
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.upperBoardTemp = 0;
    
        /**
         * CirculatorDataPoint lowerBoardTemp.
         * @member {number}lowerBoardTemp
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.lowerBoardTemp = 0;
    
        /**
         * CirculatorDataPoint motorRPM.
         * @member {number}motorRPM
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.motorRPM = 0;
    
        /**
         * CirculatorDataPoint heaterPWM.
         * @member {number}heaterPWM
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.heaterPWM = 0;
    
        /**
         * CirculatorDataPoint motorVoltage.
         * @member {number}motorVoltage
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.motorVoltage = 0;
    
        /**
         * CirculatorDataPoint motorPWM.
         * @member {number}motorPWM
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.motorPWM = 0;
    
        /**
         * CirculatorDataPoint motorCurrent.
         * @member {number}motorCurrent
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.motorCurrent = 0;
    
        /**
         * CirculatorDataPoint pressure.
         * @member {number}pressure
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.pressure = 0;
    
        /**
         * CirculatorDataPoint motorFaultFlag.
         * @member {number}motorFaultFlag
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.motorFaultFlag = 0;
    
        /**
         * CirculatorDataPoint motorPeakCurrent.
         * @member {number}motorPeakCurrent
         * @memberof CirculatorDataPoint
         * @instance
         */
        CirculatorDataPoint.prototype.motorPeakCurrent = 0;
    
        /**
         * Creates a new CirculatorDataPoint instance using the specified properties.
         * @function create
         * @memberof CirculatorDataPoint
         * @static
         * @param {ICirculatorDataPoint=} [properties] Properties to set
         * @returns {CirculatorDataPoint} CirculatorDataPoint instance
         */
        CirculatorDataPoint.create = function create(properties) {
            return new CirculatorDataPoint(properties);
        };
    
        /**
         * Encodes the specified CirculatorDataPoint message. Does not implicitly {@link CirculatorDataPoint.verify|verify} messages.
         * @function encode
         * @memberof CirculatorDataPoint
         * @static
         * @param {ICirculatorDataPoint} message CirculatorDataPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CirculatorDataPoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.feedId);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sequenceNumber);
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timestamp);
            if (message.errorState != null && message.hasOwnProperty("errorState"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.errorState);
            writer.uint32(/* id 10, wireType 5 =*/85).float(message.bathTemp);
            if (message.programStep != null && message.hasOwnProperty("programStep"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.programStep);
            if (message.timeRemaining != null && message.hasOwnProperty("timeRemaining"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.timeRemaining);
            if (message.heaterTemp != null && message.hasOwnProperty("heaterTemp"))
                writer.uint32(/* id 50, wireType 5 =*/405).float(message.heaterTemp);
            if (message.upperBoardTemp != null && message.hasOwnProperty("upperBoardTemp"))
                writer.uint32(/* id 52, wireType 5 =*/421).float(message.upperBoardTemp);
            if (message.lowerBoardTemp != null && message.hasOwnProperty("lowerBoardTemp"))
                writer.uint32(/* id 53, wireType 5 =*/429).float(message.lowerBoardTemp);
            if (message.motorRPM != null && message.hasOwnProperty("motorRPM"))
                writer.uint32(/* id 54, wireType 0 =*/432).int32(message.motorRPM);
            if (message.heaterPWM != null && message.hasOwnProperty("heaterPWM"))
                writer.uint32(/* id 55, wireType 5 =*/445).float(message.heaterPWM);
            if (message.motorVoltage != null && message.hasOwnProperty("motorVoltage"))
                writer.uint32(/* id 56, wireType 5 =*/453).float(message.motorVoltage);
            if (message.motorPWM != null && message.hasOwnProperty("motorPWM"))
                writer.uint32(/* id 57, wireType 5 =*/461).float(message.motorPWM);
            if (message.motorCurrent != null && message.hasOwnProperty("motorCurrent"))
                writer.uint32(/* id 58, wireType 5 =*/469).float(message.motorCurrent);
            if (message.pressure != null && message.hasOwnProperty("pressure"))
                writer.uint32(/* id 61, wireType 5 =*/493).float(message.pressure);
            if (message.motorFaultFlag != null && message.hasOwnProperty("motorFaultFlag"))
                writer.uint32(/* id 63, wireType 0 =*/504).uint32(message.motorFaultFlag);
            if (message.motorPeakCurrent != null && message.hasOwnProperty("motorPeakCurrent"))
                writer.uint32(/* id 64, wireType 5 =*/517).float(message.motorPeakCurrent);
            return writer;
        };
    
        /**
         * Encodes the specified CirculatorDataPoint message, length delimited. Does not implicitly {@link CirculatorDataPoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CirculatorDataPoint
         * @static
         * @param {ICirculatorDataPoint} message CirculatorDataPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CirculatorDataPoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CirculatorDataPoint message from the specified reader or buffer.
         * @function decode
         * @memberof CirculatorDataPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CirculatorDataPoint} CirculatorDataPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CirculatorDataPoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CirculatorDataPoint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.feedId = reader.uint32();
                    break;
                case 2:
                    message.sequenceNumber = reader.uint32();
                    break;
                case 3:
                    message.timestamp = reader.uint32();
                    break;
                case 4:
                    message.errorState = reader.int32();
                    break;
                case 10:
                    message.bathTemp = reader.float();
                    break;
                case 11:
                    message.programStep = reader.int32();
                    break;
                case 12:
                    message.timeRemaining = reader.uint32();
                    break;
                case 50:
                    message.heaterTemp = reader.float();
                    break;
                case 52:
                    message.upperBoardTemp = reader.float();
                    break;
                case 53:
                    message.lowerBoardTemp = reader.float();
                    break;
                case 54:
                    message.motorRPM = reader.int32();
                    break;
                case 55:
                    message.heaterPWM = reader.float();
                    break;
                case 56:
                    message.motorVoltage = reader.float();
                    break;
                case 57:
                    message.motorPWM = reader.float();
                    break;
                case 58:
                    message.motorCurrent = reader.float();
                    break;
                case 61:
                    message.pressure = reader.float();
                    break;
                case 63:
                    message.motorFaultFlag = reader.uint32();
                    break;
                case 64:
                    message.motorPeakCurrent = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("feedId"))
                throw $util.ProtocolError("missing required 'feedId'", { instance: message });
            if (!message.hasOwnProperty("sequenceNumber"))
                throw $util.ProtocolError("missing required 'sequenceNumber'", { instance: message });
            if (!message.hasOwnProperty("timestamp"))
                throw $util.ProtocolError("missing required 'timestamp'", { instance: message });
            if (!message.hasOwnProperty("bathTemp"))
                throw $util.ProtocolError("missing required 'bathTemp'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CirculatorDataPoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CirculatorDataPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CirculatorDataPoint} CirculatorDataPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CirculatorDataPoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CirculatorDataPoint message.
         * @function verify
         * @memberof CirculatorDataPoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CirculatorDataPoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.feedId))
                return "feedId: integer expected";
            if (!$util.isInteger(message.sequenceNumber))
                return "sequenceNumber: integer expected";
            if (!$util.isInteger(message.timestamp))
                return "timestamp: integer expected";
            if (message.errorState != null && message.hasOwnProperty("errorState"))
                switch (message.errorState) {
                default:
                    return "errorState: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (typeof message.bathTemp !== "number")
                return "bathTemp: number expected";
            if (message.programStep != null && message.hasOwnProperty("programStep"))
                switch (message.programStep) {
                default:
                    return "programStep: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.timeRemaining != null && message.hasOwnProperty("timeRemaining"))
                if (!$util.isInteger(message.timeRemaining))
                    return "timeRemaining: integer expected";
            if (message.heaterTemp != null && message.hasOwnProperty("heaterTemp"))
                if (typeof message.heaterTemp !== "number")
                    return "heaterTemp: number expected";
            if (message.upperBoardTemp != null && message.hasOwnProperty("upperBoardTemp"))
                if (typeof message.upperBoardTemp !== "number")
                    return "upperBoardTemp: number expected";
            if (message.lowerBoardTemp != null && message.hasOwnProperty("lowerBoardTemp"))
                if (typeof message.lowerBoardTemp !== "number")
                    return "lowerBoardTemp: number expected";
            if (message.motorRPM != null && message.hasOwnProperty("motorRPM"))
                if (!$util.isInteger(message.motorRPM))
                    return "motorRPM: integer expected";
            if (message.heaterPWM != null && message.hasOwnProperty("heaterPWM"))
                if (typeof message.heaterPWM !== "number")
                    return "heaterPWM: number expected";
            if (message.motorVoltage != null && message.hasOwnProperty("motorVoltage"))
                if (typeof message.motorVoltage !== "number")
                    return "motorVoltage: number expected";
            if (message.motorPWM != null && message.hasOwnProperty("motorPWM"))
                if (typeof message.motorPWM !== "number")
                    return "motorPWM: number expected";
            if (message.motorCurrent != null && message.hasOwnProperty("motorCurrent"))
                if (typeof message.motorCurrent !== "number")
                    return "motorCurrent: number expected";
            if (message.pressure != null && message.hasOwnProperty("pressure"))
                if (typeof message.pressure !== "number")
                    return "pressure: number expected";
            if (message.motorFaultFlag != null && message.hasOwnProperty("motorFaultFlag"))
                if (!$util.isInteger(message.motorFaultFlag))
                    return "motorFaultFlag: integer expected";
            if (message.motorPeakCurrent != null && message.hasOwnProperty("motorPeakCurrent"))
                if (typeof message.motorPeakCurrent !== "number")
                    return "motorPeakCurrent: number expected";
            return null;
        };
    
        /**
         * Creates a CirculatorDataPoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CirculatorDataPoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CirculatorDataPoint} CirculatorDataPoint
         */
        CirculatorDataPoint.fromObject = function fromObject(object) {
            if (object instanceof $root.CirculatorDataPoint)
                return object;
            var message = new $root.CirculatorDataPoint();
            if (object.feedId != null)
                message.feedId = object.feedId >>> 0;
            if (object.sequenceNumber != null)
                message.sequenceNumber = object.sequenceNumber >>> 0;
            if (object.timestamp != null)
                message.timestamp = object.timestamp >>> 0;
            switch (object.errorState) {
            case "NO_ERROR":
            case 0:
                message.errorState = 0;
                break;
            case "SOFT_ERROR":
            case 1:
                message.errorState = 1;
                break;
            case "HARD_ERROR":
            case 2:
                message.errorState = 2;
                break;
            }
            if (object.bathTemp != null)
                message.bathTemp = Number(object.bathTemp);
            switch (object.programStep) {
            case "UNKNOWN":
            case 0:
                message.programStep = 0;
                break;
            case "PRE_HEAT":
            case 1:
                message.programStep = 1;
                break;
            case "WAIT_FOR_FOOD":
            case 2:
                message.programStep = 2;
                break;
            case "COOK":
            case 3:
                message.programStep = 3;
                break;
            case "WAIT_FOR_REMOVE_FOOD":
            case 4:
                message.programStep = 4;
                break;
            case "ERROR":
            case 5:
                message.programStep = 5;
                break;
            }
            if (object.timeRemaining != null)
                message.timeRemaining = object.timeRemaining >>> 0;
            if (object.heaterTemp != null)
                message.heaterTemp = Number(object.heaterTemp);
            if (object.upperBoardTemp != null)
                message.upperBoardTemp = Number(object.upperBoardTemp);
            if (object.lowerBoardTemp != null)
                message.lowerBoardTemp = Number(object.lowerBoardTemp);
            if (object.motorRPM != null)
                message.motorRPM = object.motorRPM | 0;
            if (object.heaterPWM != null)
                message.heaterPWM = Number(object.heaterPWM);
            if (object.motorVoltage != null)
                message.motorVoltage = Number(object.motorVoltage);
            if (object.motorPWM != null)
                message.motorPWM = Number(object.motorPWM);
            if (object.motorCurrent != null)
                message.motorCurrent = Number(object.motorCurrent);
            if (object.pressure != null)
                message.pressure = Number(object.pressure);
            if (object.motorFaultFlag != null)
                message.motorFaultFlag = object.motorFaultFlag >>> 0;
            if (object.motorPeakCurrent != null)
                message.motorPeakCurrent = Number(object.motorPeakCurrent);
            return message;
        };
    
        /**
         * Creates a plain object from a CirculatorDataPoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CirculatorDataPoint
         * @static
         * @param {CirculatorDataPoint} message CirculatorDataPoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CirculatorDataPoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.feedId = 0;
                object.sequenceNumber = 0;
                object.timestamp = 0;
                object.errorState = options.enums === String ? "NO_ERROR" : 0;
                object.bathTemp = 0;
                object.programStep = options.enums === String ? "UNKNOWN" : 0;
                object.timeRemaining = 0;
                object.heaterTemp = 0;
                object.upperBoardTemp = 0;
                object.lowerBoardTemp = 0;
                object.motorRPM = 0;
                object.heaterPWM = 0;
                object.motorVoltage = 0;
                object.motorPWM = 0;
                object.motorCurrent = 0;
                object.pressure = 0;
                object.motorFaultFlag = 0;
                object.motorPeakCurrent = 0;
            }
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                object.feedId = message.feedId;
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                object.sequenceNumber = message.sequenceNumber;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            if (message.errorState != null && message.hasOwnProperty("errorState"))
                object.errorState = options.enums === String ? $root.ErrorState[message.errorState] : message.errorState;
            if (message.bathTemp != null && message.hasOwnProperty("bathTemp"))
                object.bathTemp = options.json && !isFinite(message.bathTemp) ? String(message.bathTemp) : message.bathTemp;
            if (message.programStep != null && message.hasOwnProperty("programStep"))
                object.programStep = options.enums === String ? $root.ProgramStep[message.programStep] : message.programStep;
            if (message.timeRemaining != null && message.hasOwnProperty("timeRemaining"))
                object.timeRemaining = message.timeRemaining;
            if (message.heaterTemp != null && message.hasOwnProperty("heaterTemp"))
                object.heaterTemp = options.json && !isFinite(message.heaterTemp) ? String(message.heaterTemp) : message.heaterTemp;
            if (message.upperBoardTemp != null && message.hasOwnProperty("upperBoardTemp"))
                object.upperBoardTemp = options.json && !isFinite(message.upperBoardTemp) ? String(message.upperBoardTemp) : message.upperBoardTemp;
            if (message.lowerBoardTemp != null && message.hasOwnProperty("lowerBoardTemp"))
                object.lowerBoardTemp = options.json && !isFinite(message.lowerBoardTemp) ? String(message.lowerBoardTemp) : message.lowerBoardTemp;
            if (message.motorRPM != null && message.hasOwnProperty("motorRPM"))
                object.motorRPM = message.motorRPM;
            if (message.heaterPWM != null && message.hasOwnProperty("heaterPWM"))
                object.heaterPWM = options.json && !isFinite(message.heaterPWM) ? String(message.heaterPWM) : message.heaterPWM;
            if (message.motorVoltage != null && message.hasOwnProperty("motorVoltage"))
                object.motorVoltage = options.json && !isFinite(message.motorVoltage) ? String(message.motorVoltage) : message.motorVoltage;
            if (message.motorPWM != null && message.hasOwnProperty("motorPWM"))
                object.motorPWM = options.json && !isFinite(message.motorPWM) ? String(message.motorPWM) : message.motorPWM;
            if (message.motorCurrent != null && message.hasOwnProperty("motorCurrent"))
                object.motorCurrent = options.json && !isFinite(message.motorCurrent) ? String(message.motorCurrent) : message.motorCurrent;
            if (message.pressure != null && message.hasOwnProperty("pressure"))
                object.pressure = options.json && !isFinite(message.pressure) ? String(message.pressure) : message.pressure;
            if (message.motorFaultFlag != null && message.hasOwnProperty("motorFaultFlag"))
                object.motorFaultFlag = message.motorFaultFlag;
            if (message.motorPeakCurrent != null && message.hasOwnProperty("motorPeakCurrent"))
                object.motorPeakCurrent = options.json && !isFinite(message.motorPeakCurrent) ? String(message.motorPeakCurrent) : message.motorPeakCurrent;
            return object;
        };
    
        /**
         * Converts this CirculatorDataPoint to JSON.
         * @function toJSON
         * @memberof CirculatorDataPoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CirculatorDataPoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CirculatorDataPoint;
    })();
    
    /**
     * LogLevel enum.
     * @exports LogLevel
     * @enum {string}
     * @property {number} LOG_DEBUG=0 LOG_DEBUG value
     * @property {number} LOG_INFO=1 LOG_INFO value
     * @property {number} LOG_WARNING=2 LOG_WARNING value
     * @property {number} LOG_ERROR=3 LOG_ERROR value
     * @property {number} LOG_FATAL=4 LOG_FATAL value
     */
    $root.LogLevel = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LOG_DEBUG"] = 0;
        values[valuesById[1] = "LOG_INFO"] = 1;
        values[valuesById[2] = "LOG_WARNING"] = 2;
        values[valuesById[3] = "LOG_ERROR"] = 3;
        values[valuesById[4] = "LOG_FATAL"] = 4;
        return values;
    })();
    
    $root.DebugMessage = (function() {
    
        /**
         * Properties of a DebugMessage.
         * @exports IDebugMessage
         * @interface IDebugMessage
         * @property {number} feedId DebugMessage feedId
         * @property {number} sequenceNumber DebugMessage sequenceNumber
         * @property {number} timestamp DebugMessage timestamp
         * @property {LogLevel} logLevel DebugMessage logLevel
         * @property {string} [source] DebugMessage source
         * @property {string} [event] DebugMessage event
         * @property {string} [message] DebugMessage message
         */
    
        /**
         * Constructs a new DebugMessage.
         * @exports DebugMessage
         * @classdesc Represents a DebugMessage.
         * @constructor
         * @param {IDebugMessage=} [properties] Properties to set
         */
        function DebugMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * DebugMessage feedId.
         * @member {number}feedId
         * @memberof DebugMessage
         * @instance
         */
        DebugMessage.prototype.feedId = 0;
    
        /**
         * DebugMessage sequenceNumber.
         * @member {number}sequenceNumber
         * @memberof DebugMessage
         * @instance
         */
        DebugMessage.prototype.sequenceNumber = 0;
    
        /**
         * DebugMessage timestamp.
         * @member {number}timestamp
         * @memberof DebugMessage
         * @instance
         */
        DebugMessage.prototype.timestamp = 0;
    
        /**
         * DebugMessage logLevel.
         * @member {LogLevel}logLevel
         * @memberof DebugMessage
         * @instance
         */
        DebugMessage.prototype.logLevel = 0;
    
        /**
         * DebugMessage source.
         * @member {string}source
         * @memberof DebugMessage
         * @instance
         */
        DebugMessage.prototype.source = "";
    
        /**
         * DebugMessage event.
         * @member {string}event
         * @memberof DebugMessage
         * @instance
         */
        DebugMessage.prototype.event = "";
    
        /**
         * DebugMessage message.
         * @member {string}message
         * @memberof DebugMessage
         * @instance
         */
        DebugMessage.prototype.message = "";
    
        /**
         * Creates a new DebugMessage instance using the specified properties.
         * @function create
         * @memberof DebugMessage
         * @static
         * @param {IDebugMessage=} [properties] Properties to set
         * @returns {DebugMessage} DebugMessage instance
         */
        DebugMessage.create = function create(properties) {
            return new DebugMessage(properties);
        };
    
        /**
         * Encodes the specified DebugMessage message. Does not implicitly {@link DebugMessage.verify|verify} messages.
         * @function encode
         * @memberof DebugMessage
         * @static
         * @param {IDebugMessage} message DebugMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.feedId);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sequenceNumber);
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timestamp);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.logLevel);
            if (message.source != null && message.hasOwnProperty("source"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.source);
            if (message.event != null && message.hasOwnProperty("event"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.event);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.message);
            return writer;
        };
    
        /**
         * Encodes the specified DebugMessage message, length delimited. Does not implicitly {@link DebugMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DebugMessage
         * @static
         * @param {IDebugMessage} message DebugMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a DebugMessage message from the specified reader or buffer.
         * @function decode
         * @memberof DebugMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DebugMessage} DebugMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DebugMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.feedId = reader.uint32();
                    break;
                case 2:
                    message.sequenceNumber = reader.uint32();
                    break;
                case 3:
                    message.timestamp = reader.uint32();
                    break;
                case 4:
                    message.logLevel = reader.int32();
                    break;
                case 5:
                    message.source = reader.string();
                    break;
                case 6:
                    message.event = reader.string();
                    break;
                case 10:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("feedId"))
                throw $util.ProtocolError("missing required 'feedId'", { instance: message });
            if (!message.hasOwnProperty("sequenceNumber"))
                throw $util.ProtocolError("missing required 'sequenceNumber'", { instance: message });
            if (!message.hasOwnProperty("timestamp"))
                throw $util.ProtocolError("missing required 'timestamp'", { instance: message });
            if (!message.hasOwnProperty("logLevel"))
                throw $util.ProtocolError("missing required 'logLevel'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a DebugMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DebugMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DebugMessage} DebugMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a DebugMessage message.
         * @function verify
         * @memberof DebugMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.feedId))
                return "feedId: integer expected";
            if (!$util.isInteger(message.sequenceNumber))
                return "sequenceNumber: integer expected";
            if (!$util.isInteger(message.timestamp))
                return "timestamp: integer expected";
            switch (message.logLevel) {
            default:
                return "logLevel: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
                break;
            }
            if (message.source != null && message.hasOwnProperty("source"))
                if (!$util.isString(message.source))
                    return "source: string expected";
            if (message.event != null && message.hasOwnProperty("event"))
                if (!$util.isString(message.event))
                    return "event: string expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };
    
        /**
         * Creates a DebugMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DebugMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DebugMessage} DebugMessage
         */
        DebugMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.DebugMessage)
                return object;
            var message = new $root.DebugMessage();
            if (object.feedId != null)
                message.feedId = object.feedId >>> 0;
            if (object.sequenceNumber != null)
                message.sequenceNumber = object.sequenceNumber >>> 0;
            if (object.timestamp != null)
                message.timestamp = object.timestamp >>> 0;
            switch (object.logLevel) {
            case "LOG_DEBUG":
            case 0:
                message.logLevel = 0;
                break;
            case "LOG_INFO":
            case 1:
                message.logLevel = 1;
                break;
            case "LOG_WARNING":
            case 2:
                message.logLevel = 2;
                break;
            case "LOG_ERROR":
            case 3:
                message.logLevel = 3;
                break;
            case "LOG_FATAL":
            case 4:
                message.logLevel = 4;
                break;
            }
            if (object.source != null)
                message.source = String(object.source);
            if (object.event != null)
                message.event = String(object.event);
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };
    
        /**
         * Creates a plain object from a DebugMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DebugMessage
         * @static
         * @param {DebugMessage} message DebugMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.feedId = 0;
                object.sequenceNumber = 0;
                object.timestamp = 0;
                object.logLevel = options.enums === String ? "LOG_DEBUG" : 0;
                object.source = "";
                object.event = "";
                object.message = "";
            }
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                object.feedId = message.feedId;
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                object.sequenceNumber = message.sequenceNumber;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            if (message.logLevel != null && message.hasOwnProperty("logLevel"))
                object.logLevel = options.enums === String ? $root.LogLevel[message.logLevel] : message.logLevel;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = message.source;
            if (message.event != null && message.hasOwnProperty("event"))
                object.event = message.event;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };
    
        /**
         * Converts this DebugMessage to JSON.
         * @function toJSON
         * @memberof DebugMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return DebugMessage;
    })();
    
    $root.RetransmitFeedRequest = (function() {
    
        /**
         * Properties of a RetransmitFeedRequest.
         * @exports IRetransmitFeedRequest
         * @interface IRetransmitFeedRequest
         * @property {number} feedId RetransmitFeedRequest feedId
         * @property {number} seqStart RetransmitFeedRequest seqStart
         * @property {number} seqEnd RetransmitFeedRequest seqEnd
         */
    
        /**
         * Constructs a new RetransmitFeedRequest.
         * @exports RetransmitFeedRequest
         * @classdesc Represents a RetransmitFeedRequest.
         * @constructor
         * @param {IRetransmitFeedRequest=} [properties] Properties to set
         */
        function RetransmitFeedRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * RetransmitFeedRequest feedId.
         * @member {number}feedId
         * @memberof RetransmitFeedRequest
         * @instance
         */
        RetransmitFeedRequest.prototype.feedId = 0;
    
        /**
         * RetransmitFeedRequest seqStart.
         * @member {number}seqStart
         * @memberof RetransmitFeedRequest
         * @instance
         */
        RetransmitFeedRequest.prototype.seqStart = 0;
    
        /**
         * RetransmitFeedRequest seqEnd.
         * @member {number}seqEnd
         * @memberof RetransmitFeedRequest
         * @instance
         */
        RetransmitFeedRequest.prototype.seqEnd = 0;
    
        /**
         * Creates a new RetransmitFeedRequest instance using the specified properties.
         * @function create
         * @memberof RetransmitFeedRequest
         * @static
         * @param {IRetransmitFeedRequest=} [properties] Properties to set
         * @returns {RetransmitFeedRequest} RetransmitFeedRequest instance
         */
        RetransmitFeedRequest.create = function create(properties) {
            return new RetransmitFeedRequest(properties);
        };
    
        /**
         * Encodes the specified RetransmitFeedRequest message. Does not implicitly {@link RetransmitFeedRequest.verify|verify} messages.
         * @function encode
         * @memberof RetransmitFeedRequest
         * @static
         * @param {IRetransmitFeedRequest} message RetransmitFeedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RetransmitFeedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.feedId);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.seqStart);
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.seqEnd);
            return writer;
        };
    
        /**
         * Encodes the specified RetransmitFeedRequest message, length delimited. Does not implicitly {@link RetransmitFeedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RetransmitFeedRequest
         * @static
         * @param {IRetransmitFeedRequest} message RetransmitFeedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RetransmitFeedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RetransmitFeedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof RetransmitFeedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RetransmitFeedRequest} RetransmitFeedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RetransmitFeedRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RetransmitFeedRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.feedId = reader.uint32();
                    break;
                case 2:
                    message.seqStart = reader.uint32();
                    break;
                case 3:
                    message.seqEnd = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("feedId"))
                throw $util.ProtocolError("missing required 'feedId'", { instance: message });
            if (!message.hasOwnProperty("seqStart"))
                throw $util.ProtocolError("missing required 'seqStart'", { instance: message });
            if (!message.hasOwnProperty("seqEnd"))
                throw $util.ProtocolError("missing required 'seqEnd'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a RetransmitFeedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RetransmitFeedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RetransmitFeedRequest} RetransmitFeedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RetransmitFeedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RetransmitFeedRequest message.
         * @function verify
         * @memberof RetransmitFeedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RetransmitFeedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.feedId))
                return "feedId: integer expected";
            if (!$util.isInteger(message.seqStart))
                return "seqStart: integer expected";
            if (!$util.isInteger(message.seqEnd))
                return "seqEnd: integer expected";
            return null;
        };
    
        /**
         * Creates a RetransmitFeedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RetransmitFeedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RetransmitFeedRequest} RetransmitFeedRequest
         */
        RetransmitFeedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.RetransmitFeedRequest)
                return object;
            var message = new $root.RetransmitFeedRequest();
            if (object.feedId != null)
                message.feedId = object.feedId >>> 0;
            if (object.seqStart != null)
                message.seqStart = object.seqStart >>> 0;
            if (object.seqEnd != null)
                message.seqEnd = object.seqEnd >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a RetransmitFeedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RetransmitFeedRequest
         * @static
         * @param {RetransmitFeedRequest} message RetransmitFeedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RetransmitFeedRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.feedId = 0;
                object.seqStart = 0;
                object.seqEnd = 0;
            }
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                object.feedId = message.feedId;
            if (message.seqStart != null && message.hasOwnProperty("seqStart"))
                object.seqStart = message.seqStart;
            if (message.seqEnd != null && message.hasOwnProperty("seqEnd"))
                object.seqEnd = message.seqEnd;
            return object;
        };
    
        /**
         * Converts this RetransmitFeedRequest to JSON.
         * @function toJSON
         * @memberof RetransmitFeedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RetransmitFeedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return RetransmitFeedRequest;
    })();
    
    $root.RetransmitFeedReply = (function() {
    
        /**
         * Properties of a RetransmitFeedReply.
         * @exports IRetransmitFeedReply
         * @interface IRetransmitFeedReply
         * @property {Result} [result] RetransmitFeedReply result
         */
    
        /**
         * Constructs a new RetransmitFeedReply.
         * @exports RetransmitFeedReply
         * @classdesc Represents a RetransmitFeedReply.
         * @constructor
         * @param {IRetransmitFeedReply=} [properties] Properties to set
         */
        function RetransmitFeedReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * RetransmitFeedReply result.
         * @member {Result}result
         * @memberof RetransmitFeedReply
         * @instance
         */
        RetransmitFeedReply.prototype.result = 0;
    
        /**
         * Creates a new RetransmitFeedReply instance using the specified properties.
         * @function create
         * @memberof RetransmitFeedReply
         * @static
         * @param {IRetransmitFeedReply=} [properties] Properties to set
         * @returns {RetransmitFeedReply} RetransmitFeedReply instance
         */
        RetransmitFeedReply.create = function create(properties) {
            return new RetransmitFeedReply(properties);
        };
    
        /**
         * Encodes the specified RetransmitFeedReply message. Does not implicitly {@link RetransmitFeedReply.verify|verify} messages.
         * @function encode
         * @memberof RetransmitFeedReply
         * @static
         * @param {IRetransmitFeedReply} message RetransmitFeedReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RetransmitFeedReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified RetransmitFeedReply message, length delimited. Does not implicitly {@link RetransmitFeedReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RetransmitFeedReply
         * @static
         * @param {IRetransmitFeedReply} message RetransmitFeedReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RetransmitFeedReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RetransmitFeedReply message from the specified reader or buffer.
         * @function decode
         * @memberof RetransmitFeedReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RetransmitFeedReply} RetransmitFeedReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RetransmitFeedReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RetransmitFeedReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a RetransmitFeedReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RetransmitFeedReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RetransmitFeedReply} RetransmitFeedReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RetransmitFeedReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RetransmitFeedReply message.
         * @function verify
         * @memberof RetransmitFeedReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RetransmitFeedReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a RetransmitFeedReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RetransmitFeedReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RetransmitFeedReply} RetransmitFeedReply
         */
        RetransmitFeedReply.fromObject = function fromObject(object) {
            if (object instanceof $root.RetransmitFeedReply)
                return object;
            var message = new $root.RetransmitFeedReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a RetransmitFeedReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RetransmitFeedReply
         * @static
         * @param {RetransmitFeedReply} message RetransmitFeedReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RetransmitFeedReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this RetransmitFeedReply to JSON.
         * @function toJSON
         * @memberof RetransmitFeedReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RetransmitFeedReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return RetransmitFeedReply;
    })();
    
    $root.StreamFeedReply = (function() {
    
        /**
         * Properties of a StreamFeedReply.
         * @exports IStreamFeedReply
         * @interface IStreamFeedReply
         * @property {number} feedId StreamFeedReply feedId
         * @property {number} seq StreamFeedReply seq
         * @property {number} [setPoint] StreamFeedReply setPoint
         * @property {number} [bathTemp] StreamFeedReply bathTemp
         */
    
        /**
         * Constructs a new StreamFeedReply.
         * @exports StreamFeedReply
         * @classdesc Represents a StreamFeedReply.
         * @constructor
         * @param {IStreamFeedReply=} [properties] Properties to set
         */
        function StreamFeedReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * StreamFeedReply feedId.
         * @member {number}feedId
         * @memberof StreamFeedReply
         * @instance
         */
        StreamFeedReply.prototype.feedId = 0;
    
        /**
         * StreamFeedReply seq.
         * @member {number}seq
         * @memberof StreamFeedReply
         * @instance
         */
        StreamFeedReply.prototype.seq = 0;
    
        /**
         * StreamFeedReply setPoint.
         * @member {number}setPoint
         * @memberof StreamFeedReply
         * @instance
         */
        StreamFeedReply.prototype.setPoint = 0;
    
        /**
         * StreamFeedReply bathTemp.
         * @member {number}bathTemp
         * @memberof StreamFeedReply
         * @instance
         */
        StreamFeedReply.prototype.bathTemp = 0;
    
        /**
         * Creates a new StreamFeedReply instance using the specified properties.
         * @function create
         * @memberof StreamFeedReply
         * @static
         * @param {IStreamFeedReply=} [properties] Properties to set
         * @returns {StreamFeedReply} StreamFeedReply instance
         */
        StreamFeedReply.create = function create(properties) {
            return new StreamFeedReply(properties);
        };
    
        /**
         * Encodes the specified StreamFeedReply message. Does not implicitly {@link StreamFeedReply.verify|verify} messages.
         * @function encode
         * @memberof StreamFeedReply
         * @static
         * @param {IStreamFeedReply} message StreamFeedReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamFeedReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.feedId);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.seq);
            if (message.setPoint != null && message.hasOwnProperty("setPoint"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.setPoint);
            if (message.bathTemp != null && message.hasOwnProperty("bathTemp"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.bathTemp);
            return writer;
        };
    
        /**
         * Encodes the specified StreamFeedReply message, length delimited. Does not implicitly {@link StreamFeedReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof StreamFeedReply
         * @static
         * @param {IStreamFeedReply} message StreamFeedReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamFeedReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a StreamFeedReply message from the specified reader or buffer.
         * @function decode
         * @memberof StreamFeedReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {StreamFeedReply} StreamFeedReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamFeedReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StreamFeedReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.feedId = reader.uint32();
                    break;
                case 2:
                    message.seq = reader.uint32();
                    break;
                case 3:
                    message.setPoint = reader.float();
                    break;
                case 4:
                    message.bathTemp = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("feedId"))
                throw $util.ProtocolError("missing required 'feedId'", { instance: message });
            if (!message.hasOwnProperty("seq"))
                throw $util.ProtocolError("missing required 'seq'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a StreamFeedReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof StreamFeedReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {StreamFeedReply} StreamFeedReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamFeedReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a StreamFeedReply message.
         * @function verify
         * @memberof StreamFeedReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StreamFeedReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.feedId))
                return "feedId: integer expected";
            if (!$util.isInteger(message.seq))
                return "seq: integer expected";
            if (message.setPoint != null && message.hasOwnProperty("setPoint"))
                if (typeof message.setPoint !== "number")
                    return "setPoint: number expected";
            if (message.bathTemp != null && message.hasOwnProperty("bathTemp"))
                if (typeof message.bathTemp !== "number")
                    return "bathTemp: number expected";
            return null;
        };
    
        /**
         * Creates a StreamFeedReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof StreamFeedReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {StreamFeedReply} StreamFeedReply
         */
        StreamFeedReply.fromObject = function fromObject(object) {
            if (object instanceof $root.StreamFeedReply)
                return object;
            var message = new $root.StreamFeedReply();
            if (object.feedId != null)
                message.feedId = object.feedId >>> 0;
            if (object.seq != null)
                message.seq = object.seq >>> 0;
            if (object.setPoint != null)
                message.setPoint = Number(object.setPoint);
            if (object.bathTemp != null)
                message.bathTemp = Number(object.bathTemp);
            return message;
        };
    
        /**
         * Creates a plain object from a StreamFeedReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof StreamFeedReply
         * @static
         * @param {StreamFeedReply} message StreamFeedReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StreamFeedReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.feedId = 0;
                object.seq = 0;
                object.setPoint = 0;
                object.bathTemp = 0;
            }
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                object.feedId = message.feedId;
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            if (message.setPoint != null && message.hasOwnProperty("setPoint"))
                object.setPoint = options.json && !isFinite(message.setPoint) ? String(message.setPoint) : message.setPoint;
            if (message.bathTemp != null && message.hasOwnProperty("bathTemp"))
                object.bathTemp = options.json && !isFinite(message.bathTemp) ? String(message.bathTemp) : message.bathTemp;
            return object;
        };
    
        /**
         * Converts this StreamFeedReply to JSON.
         * @function toJSON
         * @memberof StreamFeedReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StreamFeedReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return StreamFeedReply;
    })();
    
    /**
     * BootModeType enum.
     * @exports BootModeType
     * @enum {string}
     * @property {number} SOFTDEVICE_BOOT_MODE=1 SOFTDEVICE_BOOT_MODE value
     * @property {number} BOOTLOADER_BOOT_MODE=2 BOOTLOADER_BOOT_MODE value
     * @property {number} APPLICATION_BOOT_MODE=3 APPLICATION_BOOT_MODE value
     */
    $root.BootModeType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "SOFTDEVICE_BOOT_MODE"] = 1;
        values[valuesById[2] = "BOOTLOADER_BOOT_MODE"] = 2;
        values[valuesById[3] = "APPLICATION_BOOT_MODE"] = 3;
        return values;
    })();
    
    $root.EnterBootModeRequest = (function() {
    
        /**
         * Properties of an EnterBootModeRequest.
         * @exports IEnterBootModeRequest
         * @interface IEnterBootModeRequest
         * @property {BootModeType} [bootModeType] EnterBootModeRequest bootModeType
         */
    
        /**
         * Constructs a new EnterBootModeRequest.
         * @exports EnterBootModeRequest
         * @classdesc Represents an EnterBootModeRequest.
         * @constructor
         * @param {IEnterBootModeRequest=} [properties] Properties to set
         */
        function EnterBootModeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * EnterBootModeRequest bootModeType.
         * @member {BootModeType}bootModeType
         * @memberof EnterBootModeRequest
         * @instance
         */
        EnterBootModeRequest.prototype.bootModeType = 1;
    
        /**
         * Creates a new EnterBootModeRequest instance using the specified properties.
         * @function create
         * @memberof EnterBootModeRequest
         * @static
         * @param {IEnterBootModeRequest=} [properties] Properties to set
         * @returns {EnterBootModeRequest} EnterBootModeRequest instance
         */
        EnterBootModeRequest.create = function create(properties) {
            return new EnterBootModeRequest(properties);
        };
    
        /**
         * Encodes the specified EnterBootModeRequest message. Does not implicitly {@link EnterBootModeRequest.verify|verify} messages.
         * @function encode
         * @memberof EnterBootModeRequest
         * @static
         * @param {IEnterBootModeRequest} message EnterBootModeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterBootModeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bootModeType != null && message.hasOwnProperty("bootModeType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bootModeType);
            return writer;
        };
    
        /**
         * Encodes the specified EnterBootModeRequest message, length delimited. Does not implicitly {@link EnterBootModeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof EnterBootModeRequest
         * @static
         * @param {IEnterBootModeRequest} message EnterBootModeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterBootModeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an EnterBootModeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof EnterBootModeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {EnterBootModeRequest} EnterBootModeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterBootModeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EnterBootModeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bootModeType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes an EnterBootModeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof EnterBootModeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {EnterBootModeRequest} EnterBootModeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterBootModeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an EnterBootModeRequest message.
         * @function verify
         * @memberof EnterBootModeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterBootModeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bootModeType != null && message.hasOwnProperty("bootModeType"))
                switch (message.bootModeType) {
                default:
                    return "bootModeType: enum value expected";
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };
    
        /**
         * Creates an EnterBootModeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof EnterBootModeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {EnterBootModeRequest} EnterBootModeRequest
         */
        EnterBootModeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.EnterBootModeRequest)
                return object;
            var message = new $root.EnterBootModeRequest();
            switch (object.bootModeType) {
            case "SOFTDEVICE_BOOT_MODE":
            case 1:
                message.bootModeType = 1;
                break;
            case "BOOTLOADER_BOOT_MODE":
            case 2:
                message.bootModeType = 2;
                break;
            case "APPLICATION_BOOT_MODE":
            case 3:
                message.bootModeType = 3;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from an EnterBootModeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof EnterBootModeRequest
         * @static
         * @param {EnterBootModeRequest} message EnterBootModeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterBootModeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.bootModeType = options.enums === String ? "SOFTDEVICE_BOOT_MODE" : 1;
            if (message.bootModeType != null && message.hasOwnProperty("bootModeType"))
                object.bootModeType = options.enums === String ? $root.BootModeType[message.bootModeType] : message.bootModeType;
            return object;
        };
    
        /**
         * Converts this EnterBootModeRequest to JSON.
         * @function toJSON
         * @memberof EnterBootModeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterBootModeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return EnterBootModeRequest;
    })();
    
    $root.EnterBootModeReply = (function() {
    
        /**
         * Properties of an EnterBootModeReply.
         * @exports IEnterBootModeReply
         * @interface IEnterBootModeReply
         * @property {Result} [result] EnterBootModeReply result
         */
    
        /**
         * Constructs a new EnterBootModeReply.
         * @exports EnterBootModeReply
         * @classdesc Represents an EnterBootModeReply.
         * @constructor
         * @param {IEnterBootModeReply=} [properties] Properties to set
         */
        function EnterBootModeReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * EnterBootModeReply result.
         * @member {Result}result
         * @memberof EnterBootModeReply
         * @instance
         */
        EnterBootModeReply.prototype.result = 0;
    
        /**
         * Creates a new EnterBootModeReply instance using the specified properties.
         * @function create
         * @memberof EnterBootModeReply
         * @static
         * @param {IEnterBootModeReply=} [properties] Properties to set
         * @returns {EnterBootModeReply} EnterBootModeReply instance
         */
        EnterBootModeReply.create = function create(properties) {
            return new EnterBootModeReply(properties);
        };
    
        /**
         * Encodes the specified EnterBootModeReply message. Does not implicitly {@link EnterBootModeReply.verify|verify} messages.
         * @function encode
         * @memberof EnterBootModeReply
         * @static
         * @param {IEnterBootModeReply} message EnterBootModeReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterBootModeReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified EnterBootModeReply message, length delimited. Does not implicitly {@link EnterBootModeReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof EnterBootModeReply
         * @static
         * @param {IEnterBootModeReply} message EnterBootModeReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterBootModeReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an EnterBootModeReply message from the specified reader or buffer.
         * @function decode
         * @memberof EnterBootModeReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {EnterBootModeReply} EnterBootModeReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterBootModeReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EnterBootModeReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes an EnterBootModeReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof EnterBootModeReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {EnterBootModeReply} EnterBootModeReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterBootModeReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an EnterBootModeReply message.
         * @function verify
         * @memberof EnterBootModeReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterBootModeReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates an EnterBootModeReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof EnterBootModeReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {EnterBootModeReply} EnterBootModeReply
         */
        EnterBootModeReply.fromObject = function fromObject(object) {
            if (object instanceof $root.EnterBootModeReply)
                return object;
            var message = new $root.EnterBootModeReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from an EnterBootModeReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof EnterBootModeReply
         * @static
         * @param {EnterBootModeReply} message EnterBootModeReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterBootModeReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this EnterBootModeReply to JSON.
         * @function toJSON
         * @memberof EnterBootModeReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterBootModeReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return EnterBootModeReply;
    })();
    
    /**
     * FileType enum.
     * @exports FileType
     * @enum {string}
     * @property {number} APPLICATION_FIRMWARE=1 APPLICATION_FIRMWARE value
     * @property {number} SOFTDEVICE_FIRMWARE=2 SOFTDEVICE_FIRMWARE value
     * @property {number} WIFI_FIRMWARE=3 WIFI_FIRMWARE value
     * @property {number} CERTIFICATE_FIRMWARE=4 CERTIFICATE_FIRMWARE value
     * @property {number} BOOTLOADER_FIRMWARE=5 BOOTLOADER_FIRMWARE value
     */
    $root.FileType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "APPLICATION_FIRMWARE"] = 1;
        values[valuesById[2] = "SOFTDEVICE_FIRMWARE"] = 2;
        values[valuesById[3] = "WIFI_FIRMWARE"] = 3;
        values[valuesById[4] = "CERTIFICATE_FIRMWARE"] = 4;
        values[valuesById[5] = "BOOTLOADER_FIRMWARE"] = 5;
        return values;
    })();
    
    $root.StartFileTransferRequest = (function() {
    
        /**
         * Properties of a StartFileTransferRequest.
         * @exports IStartFileTransferRequest
         * @interface IStartFileTransferRequest
         * @property {FileType} fileType StartFileTransferRequest fileType
         * @property {number} blockCount StartFileTransferRequest blockCount
         * @property {number} byteCount StartFileTransferRequest byteCount
         * @property {number} checksum StartFileTransferRequest checksum
         * @property {string} [version] StartFileTransferRequest version
         */
    
        /**
         * Constructs a new StartFileTransferRequest.
         * @exports StartFileTransferRequest
         * @classdesc Represents a StartFileTransferRequest.
         * @constructor
         * @param {IStartFileTransferRequest=} [properties] Properties to set
         */
        function StartFileTransferRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * StartFileTransferRequest fileType.
         * @member {FileType}fileType
         * @memberof StartFileTransferRequest
         * @instance
         */
        StartFileTransferRequest.prototype.fileType = 1;
    
        /**
         * StartFileTransferRequest blockCount.
         * @member {number}blockCount
         * @memberof StartFileTransferRequest
         * @instance
         */
        StartFileTransferRequest.prototype.blockCount = 0;
    
        /**
         * StartFileTransferRequest byteCount.
         * @member {number}byteCount
         * @memberof StartFileTransferRequest
         * @instance
         */
        StartFileTransferRequest.prototype.byteCount = 0;
    
        /**
         * StartFileTransferRequest checksum.
         * @member {number}checksum
         * @memberof StartFileTransferRequest
         * @instance
         */
        StartFileTransferRequest.prototype.checksum = 0;
    
        /**
         * StartFileTransferRequest version.
         * @member {string}version
         * @memberof StartFileTransferRequest
         * @instance
         */
        StartFileTransferRequest.prototype.version = "";
    
        /**
         * Creates a new StartFileTransferRequest instance using the specified properties.
         * @function create
         * @memberof StartFileTransferRequest
         * @static
         * @param {IStartFileTransferRequest=} [properties] Properties to set
         * @returns {StartFileTransferRequest} StartFileTransferRequest instance
         */
        StartFileTransferRequest.create = function create(properties) {
            return new StartFileTransferRequest(properties);
        };
    
        /**
         * Encodes the specified StartFileTransferRequest message. Does not implicitly {@link StartFileTransferRequest.verify|verify} messages.
         * @function encode
         * @memberof StartFileTransferRequest
         * @static
         * @param {IStartFileTransferRequest} message StartFileTransferRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartFileTransferRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fileType);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockCount);
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.byteCount);
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.checksum);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.version);
            return writer;
        };
    
        /**
         * Encodes the specified StartFileTransferRequest message, length delimited. Does not implicitly {@link StartFileTransferRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof StartFileTransferRequest
         * @static
         * @param {IStartFileTransferRequest} message StartFileTransferRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartFileTransferRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a StartFileTransferRequest message from the specified reader or buffer.
         * @function decode
         * @memberof StartFileTransferRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {StartFileTransferRequest} StartFileTransferRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartFileTransferRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartFileTransferRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fileType = reader.int32();
                    break;
                case 2:
                    message.blockCount = reader.uint32();
                    break;
                case 3:
                    message.byteCount = reader.uint32();
                    break;
                case 4:
                    message.checksum = reader.uint32();
                    break;
                case 5:
                    message.version = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("fileType"))
                throw $util.ProtocolError("missing required 'fileType'", { instance: message });
            if (!message.hasOwnProperty("blockCount"))
                throw $util.ProtocolError("missing required 'blockCount'", { instance: message });
            if (!message.hasOwnProperty("byteCount"))
                throw $util.ProtocolError("missing required 'byteCount'", { instance: message });
            if (!message.hasOwnProperty("checksum"))
                throw $util.ProtocolError("missing required 'checksum'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a StartFileTransferRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof StartFileTransferRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {StartFileTransferRequest} StartFileTransferRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartFileTransferRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a StartFileTransferRequest message.
         * @function verify
         * @memberof StartFileTransferRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartFileTransferRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.fileType) {
            default:
                return "fileType: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
            if (!$util.isInteger(message.blockCount))
                return "blockCount: integer expected";
            if (!$util.isInteger(message.byteCount))
                return "byteCount: integer expected";
            if (!$util.isInteger(message.checksum))
                return "checksum: integer expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            return null;
        };
    
        /**
         * Creates a StartFileTransferRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof StartFileTransferRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {StartFileTransferRequest} StartFileTransferRequest
         */
        StartFileTransferRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.StartFileTransferRequest)
                return object;
            var message = new $root.StartFileTransferRequest();
            switch (object.fileType) {
            case "APPLICATION_FIRMWARE":
            case 1:
                message.fileType = 1;
                break;
            case "SOFTDEVICE_FIRMWARE":
            case 2:
                message.fileType = 2;
                break;
            case "WIFI_FIRMWARE":
            case 3:
                message.fileType = 3;
                break;
            case "CERTIFICATE_FIRMWARE":
            case 4:
                message.fileType = 4;
                break;
            case "BOOTLOADER_FIRMWARE":
            case 5:
                message.fileType = 5;
                break;
            }
            if (object.blockCount != null)
                message.blockCount = object.blockCount >>> 0;
            if (object.byteCount != null)
                message.byteCount = object.byteCount >>> 0;
            if (object.checksum != null)
                message.checksum = object.checksum >>> 0;
            if (object.version != null)
                message.version = String(object.version);
            return message;
        };
    
        /**
         * Creates a plain object from a StartFileTransferRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof StartFileTransferRequest
         * @static
         * @param {StartFileTransferRequest} message StartFileTransferRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartFileTransferRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fileType = options.enums === String ? "APPLICATION_FIRMWARE" : 1;
                object.blockCount = 0;
                object.byteCount = 0;
                object.checksum = 0;
                object.version = "";
            }
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                object.fileType = options.enums === String ? $root.FileType[message.fileType] : message.fileType;
            if (message.blockCount != null && message.hasOwnProperty("blockCount"))
                object.blockCount = message.blockCount;
            if (message.byteCount != null && message.hasOwnProperty("byteCount"))
                object.byteCount = message.byteCount;
            if (message.checksum != null && message.hasOwnProperty("checksum"))
                object.checksum = message.checksum;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };
    
        /**
         * Converts this StartFileTransferRequest to JSON.
         * @function toJSON
         * @memberof StartFileTransferRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartFileTransferRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return StartFileTransferRequest;
    })();
    
    $root.StartFileTransferReply = (function() {
    
        /**
         * Properties of a StartFileTransferReply.
         * @exports IStartFileTransferReply
         * @interface IStartFileTransferReply
         * @property {Result} result StartFileTransferReply result
         */
    
        /**
         * Constructs a new StartFileTransferReply.
         * @exports StartFileTransferReply
         * @classdesc Represents a StartFileTransferReply.
         * @constructor
         * @param {IStartFileTransferReply=} [properties] Properties to set
         */
        function StartFileTransferReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * StartFileTransferReply result.
         * @member {Result}result
         * @memberof StartFileTransferReply
         * @instance
         */
        StartFileTransferReply.prototype.result = 0;
    
        /**
         * Creates a new StartFileTransferReply instance using the specified properties.
         * @function create
         * @memberof StartFileTransferReply
         * @static
         * @param {IStartFileTransferReply=} [properties] Properties to set
         * @returns {StartFileTransferReply} StartFileTransferReply instance
         */
        StartFileTransferReply.create = function create(properties) {
            return new StartFileTransferReply(properties);
        };
    
        /**
         * Encodes the specified StartFileTransferReply message. Does not implicitly {@link StartFileTransferReply.verify|verify} messages.
         * @function encode
         * @memberof StartFileTransferReply
         * @static
         * @param {IStartFileTransferReply} message StartFileTransferReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartFileTransferReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified StartFileTransferReply message, length delimited. Does not implicitly {@link StartFileTransferReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof StartFileTransferReply
         * @static
         * @param {IStartFileTransferReply} message StartFileTransferReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartFileTransferReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a StartFileTransferReply message from the specified reader or buffer.
         * @function decode
         * @memberof StartFileTransferReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {StartFileTransferReply} StartFileTransferReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartFileTransferReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartFileTransferReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a StartFileTransferReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof StartFileTransferReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {StartFileTransferReply} StartFileTransferReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartFileTransferReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a StartFileTransferReply message.
         * @function verify
         * @memberof StartFileTransferReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartFileTransferReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.result) {
            default:
                return "result: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                break;
            }
            return null;
        };
    
        /**
         * Creates a StartFileTransferReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof StartFileTransferReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {StartFileTransferReply} StartFileTransferReply
         */
        StartFileTransferReply.fromObject = function fromObject(object) {
            if (object instanceof $root.StartFileTransferReply)
                return object;
            var message = new $root.StartFileTransferReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a StartFileTransferReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof StartFileTransferReply
         * @static
         * @param {StartFileTransferReply} message StartFileTransferReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartFileTransferReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this StartFileTransferReply to JSON.
         * @function toJSON
         * @memberof StartFileTransferReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartFileTransferReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return StartFileTransferReply;
    })();
    
    $root.StartFileReceiveRequest = (function() {
    
        /**
         * Properties of a StartFileReceiveRequest.
         * @exports IStartFileReceiveRequest
         * @interface IStartFileReceiveRequest
         * @property {FileType} fileType StartFileReceiveRequest fileType
         */
    
        /**
         * Constructs a new StartFileReceiveRequest.
         * @exports StartFileReceiveRequest
         * @classdesc Represents a StartFileReceiveRequest.
         * @constructor
         * @param {IStartFileReceiveRequest=} [properties] Properties to set
         */
        function StartFileReceiveRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * StartFileReceiveRequest fileType.
         * @member {FileType}fileType
         * @memberof StartFileReceiveRequest
         * @instance
         */
        StartFileReceiveRequest.prototype.fileType = 1;
    
        /**
         * Creates a new StartFileReceiveRequest instance using the specified properties.
         * @function create
         * @memberof StartFileReceiveRequest
         * @static
         * @param {IStartFileReceiveRequest=} [properties] Properties to set
         * @returns {StartFileReceiveRequest} StartFileReceiveRequest instance
         */
        StartFileReceiveRequest.create = function create(properties) {
            return new StartFileReceiveRequest(properties);
        };
    
        /**
         * Encodes the specified StartFileReceiveRequest message. Does not implicitly {@link StartFileReceiveRequest.verify|verify} messages.
         * @function encode
         * @memberof StartFileReceiveRequest
         * @static
         * @param {IStartFileReceiveRequest} message StartFileReceiveRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartFileReceiveRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fileType);
            return writer;
        };
    
        /**
         * Encodes the specified StartFileReceiveRequest message, length delimited. Does not implicitly {@link StartFileReceiveRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof StartFileReceiveRequest
         * @static
         * @param {IStartFileReceiveRequest} message StartFileReceiveRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartFileReceiveRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a StartFileReceiveRequest message from the specified reader or buffer.
         * @function decode
         * @memberof StartFileReceiveRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {StartFileReceiveRequest} StartFileReceiveRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartFileReceiveRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartFileReceiveRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fileType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("fileType"))
                throw $util.ProtocolError("missing required 'fileType'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a StartFileReceiveRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof StartFileReceiveRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {StartFileReceiveRequest} StartFileReceiveRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartFileReceiveRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a StartFileReceiveRequest message.
         * @function verify
         * @memberof StartFileReceiveRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartFileReceiveRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.fileType) {
            default:
                return "fileType: enum value expected";
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
            return null;
        };
    
        /**
         * Creates a StartFileReceiveRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof StartFileReceiveRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {StartFileReceiveRequest} StartFileReceiveRequest
         */
        StartFileReceiveRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.StartFileReceiveRequest)
                return object;
            var message = new $root.StartFileReceiveRequest();
            switch (object.fileType) {
            case "APPLICATION_FIRMWARE":
            case 1:
                message.fileType = 1;
                break;
            case "SOFTDEVICE_FIRMWARE":
            case 2:
                message.fileType = 2;
                break;
            case "WIFI_FIRMWARE":
            case 3:
                message.fileType = 3;
                break;
            case "CERTIFICATE_FIRMWARE":
            case 4:
                message.fileType = 4;
                break;
            case "BOOTLOADER_FIRMWARE":
            case 5:
                message.fileType = 5;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a StartFileReceiveRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof StartFileReceiveRequest
         * @static
         * @param {StartFileReceiveRequest} message StartFileReceiveRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartFileReceiveRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.fileType = options.enums === String ? "APPLICATION_FIRMWARE" : 1;
            if (message.fileType != null && message.hasOwnProperty("fileType"))
                object.fileType = options.enums === String ? $root.FileType[message.fileType] : message.fileType;
            return object;
        };
    
        /**
         * Converts this StartFileReceiveRequest to JSON.
         * @function toJSON
         * @memberof StartFileReceiveRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartFileReceiveRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return StartFileReceiveRequest;
    })();
    
    $root.StartFileReceiveReply = (function() {
    
        /**
         * Properties of a StartFileReceiveReply.
         * @exports IStartFileReceiveReply
         * @interface IStartFileReceiveReply
         * @property {Result} result StartFileReceiveReply result
         * @property {number} blockCount StartFileReceiveReply blockCount
         * @property {number} byteCount StartFileReceiveReply byteCount
         * @property {number} checksum StartFileReceiveReply checksum
         */
    
        /**
         * Constructs a new StartFileReceiveReply.
         * @exports StartFileReceiveReply
         * @classdesc Represents a StartFileReceiveReply.
         * @constructor
         * @param {IStartFileReceiveReply=} [properties] Properties to set
         */
        function StartFileReceiveReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * StartFileReceiveReply result.
         * @member {Result}result
         * @memberof StartFileReceiveReply
         * @instance
         */
        StartFileReceiveReply.prototype.result = 0;
    
        /**
         * StartFileReceiveReply blockCount.
         * @member {number}blockCount
         * @memberof StartFileReceiveReply
         * @instance
         */
        StartFileReceiveReply.prototype.blockCount = 0;
    
        /**
         * StartFileReceiveReply byteCount.
         * @member {number}byteCount
         * @memberof StartFileReceiveReply
         * @instance
         */
        StartFileReceiveReply.prototype.byteCount = 0;
    
        /**
         * StartFileReceiveReply checksum.
         * @member {number}checksum
         * @memberof StartFileReceiveReply
         * @instance
         */
        StartFileReceiveReply.prototype.checksum = 0;
    
        /**
         * Creates a new StartFileReceiveReply instance using the specified properties.
         * @function create
         * @memberof StartFileReceiveReply
         * @static
         * @param {IStartFileReceiveReply=} [properties] Properties to set
         * @returns {StartFileReceiveReply} StartFileReceiveReply instance
         */
        StartFileReceiveReply.create = function create(properties) {
            return new StartFileReceiveReply(properties);
        };
    
        /**
         * Encodes the specified StartFileReceiveReply message. Does not implicitly {@link StartFileReceiveReply.verify|verify} messages.
         * @function encode
         * @memberof StartFileReceiveReply
         * @static
         * @param {IStartFileReceiveReply} message StartFileReceiveReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartFileReceiveReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockCount);
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.byteCount);
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.checksum);
            return writer;
        };
    
        /**
         * Encodes the specified StartFileReceiveReply message, length delimited. Does not implicitly {@link StartFileReceiveReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof StartFileReceiveReply
         * @static
         * @param {IStartFileReceiveReply} message StartFileReceiveReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartFileReceiveReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a StartFileReceiveReply message from the specified reader or buffer.
         * @function decode
         * @memberof StartFileReceiveReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {StartFileReceiveReply} StartFileReceiveReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartFileReceiveReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartFileReceiveReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.blockCount = reader.uint32();
                    break;
                case 3:
                    message.byteCount = reader.uint32();
                    break;
                case 4:
                    message.checksum = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            if (!message.hasOwnProperty("blockCount"))
                throw $util.ProtocolError("missing required 'blockCount'", { instance: message });
            if (!message.hasOwnProperty("byteCount"))
                throw $util.ProtocolError("missing required 'byteCount'", { instance: message });
            if (!message.hasOwnProperty("checksum"))
                throw $util.ProtocolError("missing required 'checksum'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a StartFileReceiveReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof StartFileReceiveReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {StartFileReceiveReply} StartFileReceiveReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartFileReceiveReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a StartFileReceiveReply message.
         * @function verify
         * @memberof StartFileReceiveReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartFileReceiveReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.result) {
            default:
                return "result: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                break;
            }
            if (!$util.isInteger(message.blockCount))
                return "blockCount: integer expected";
            if (!$util.isInteger(message.byteCount))
                return "byteCount: integer expected";
            if (!$util.isInteger(message.checksum))
                return "checksum: integer expected";
            return null;
        };
    
        /**
         * Creates a StartFileReceiveReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof StartFileReceiveReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {StartFileReceiveReply} StartFileReceiveReply
         */
        StartFileReceiveReply.fromObject = function fromObject(object) {
            if (object instanceof $root.StartFileReceiveReply)
                return object;
            var message = new $root.StartFileReceiveReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            if (object.blockCount != null)
                message.blockCount = object.blockCount >>> 0;
            if (object.byteCount != null)
                message.byteCount = object.byteCount >>> 0;
            if (object.checksum != null)
                message.checksum = object.checksum >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a StartFileReceiveReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof StartFileReceiveReply
         * @static
         * @param {StartFileReceiveReply} message StartFileReceiveReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartFileReceiveReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
                object.blockCount = 0;
                object.byteCount = 0;
                object.checksum = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            if (message.blockCount != null && message.hasOwnProperty("blockCount"))
                object.blockCount = message.blockCount;
            if (message.byteCount != null && message.hasOwnProperty("byteCount"))
                object.byteCount = message.byteCount;
            if (message.checksum != null && message.hasOwnProperty("checksum"))
                object.checksum = message.checksum;
            return object;
        };
    
        /**
         * Converts this StartFileReceiveReply to JSON.
         * @function toJSON
         * @memberof StartFileReceiveReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartFileReceiveReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return StartFileReceiveReply;
    })();
    
    $root.TransferFileBlockRequest = (function() {
    
        /**
         * Properties of a TransferFileBlockRequest.
         * @exports ITransferFileBlockRequest
         * @interface ITransferFileBlockRequest
         * @property {number} blockIdx TransferFileBlockRequest blockIdx
         * @property {Uint8Array} block TransferFileBlockRequest block
         */
    
        /**
         * Constructs a new TransferFileBlockRequest.
         * @exports TransferFileBlockRequest
         * @classdesc Represents a TransferFileBlockRequest.
         * @constructor
         * @param {ITransferFileBlockRequest=} [properties] Properties to set
         */
        function TransferFileBlockRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * TransferFileBlockRequest blockIdx.
         * @member {number}blockIdx
         * @memberof TransferFileBlockRequest
         * @instance
         */
        TransferFileBlockRequest.prototype.blockIdx = 0;
    
        /**
         * TransferFileBlockRequest block.
         * @member {Uint8Array}block
         * @memberof TransferFileBlockRequest
         * @instance
         */
        TransferFileBlockRequest.prototype.block = $util.newBuffer([]);
    
        /**
         * Creates a new TransferFileBlockRequest instance using the specified properties.
         * @function create
         * @memberof TransferFileBlockRequest
         * @static
         * @param {ITransferFileBlockRequest=} [properties] Properties to set
         * @returns {TransferFileBlockRequest} TransferFileBlockRequest instance
         */
        TransferFileBlockRequest.create = function create(properties) {
            return new TransferFileBlockRequest(properties);
        };
    
        /**
         * Encodes the specified TransferFileBlockRequest message. Does not implicitly {@link TransferFileBlockRequest.verify|verify} messages.
         * @function encode
         * @memberof TransferFileBlockRequest
         * @static
         * @param {ITransferFileBlockRequest} message TransferFileBlockRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferFileBlockRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.blockIdx);
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.block);
            return writer;
        };
    
        /**
         * Encodes the specified TransferFileBlockRequest message, length delimited. Does not implicitly {@link TransferFileBlockRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof TransferFileBlockRequest
         * @static
         * @param {ITransferFileBlockRequest} message TransferFileBlockRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferFileBlockRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a TransferFileBlockRequest message from the specified reader or buffer.
         * @function decode
         * @memberof TransferFileBlockRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {TransferFileBlockRequest} TransferFileBlockRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferFileBlockRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TransferFileBlockRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockIdx = reader.uint32();
                    break;
                case 2:
                    message.block = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("blockIdx"))
                throw $util.ProtocolError("missing required 'blockIdx'", { instance: message });
            if (!message.hasOwnProperty("block"))
                throw $util.ProtocolError("missing required 'block'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a TransferFileBlockRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof TransferFileBlockRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {TransferFileBlockRequest} TransferFileBlockRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferFileBlockRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a TransferFileBlockRequest message.
         * @function verify
         * @memberof TransferFileBlockRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransferFileBlockRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.blockIdx))
                return "blockIdx: integer expected";
            if (!(message.block && typeof message.block.length === "number" || $util.isString(message.block)))
                return "block: buffer expected";
            return null;
        };
    
        /**
         * Creates a TransferFileBlockRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof TransferFileBlockRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {TransferFileBlockRequest} TransferFileBlockRequest
         */
        TransferFileBlockRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.TransferFileBlockRequest)
                return object;
            var message = new $root.TransferFileBlockRequest();
            if (object.blockIdx != null)
                message.blockIdx = object.blockIdx >>> 0;
            if (object.block != null)
                if (typeof object.block === "string")
                    $util.base64.decode(object.block, message.block = $util.newBuffer($util.base64.length(object.block)), 0);
                else if (object.block.length)
                    message.block = object.block;
            return message;
        };
    
        /**
         * Creates a plain object from a TransferFileBlockRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof TransferFileBlockRequest
         * @static
         * @param {TransferFileBlockRequest} message TransferFileBlockRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransferFileBlockRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.blockIdx = 0;
                object.block = options.bytes === String ? "" : [];
            }
            if (message.blockIdx != null && message.hasOwnProperty("blockIdx"))
                object.blockIdx = message.blockIdx;
            if (message.block != null && message.hasOwnProperty("block"))
                object.block = options.bytes === String ? $util.base64.encode(message.block, 0, message.block.length) : options.bytes === Array ? Array.prototype.slice.call(message.block) : message.block;
            return object;
        };
    
        /**
         * Converts this TransferFileBlockRequest to JSON.
         * @function toJSON
         * @memberof TransferFileBlockRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransferFileBlockRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return TransferFileBlockRequest;
    })();
    
    $root.TransferFileBlockReply = (function() {
    
        /**
         * Properties of a TransferFileBlockReply.
         * @exports ITransferFileBlockReply
         * @interface ITransferFileBlockReply
         * @property {Result} result TransferFileBlockReply result
         * @property {number} blockIdx TransferFileBlockReply blockIdx
         */
    
        /**
         * Constructs a new TransferFileBlockReply.
         * @exports TransferFileBlockReply
         * @classdesc Represents a TransferFileBlockReply.
         * @constructor
         * @param {ITransferFileBlockReply=} [properties] Properties to set
         */
        function TransferFileBlockReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * TransferFileBlockReply result.
         * @member {Result}result
         * @memberof TransferFileBlockReply
         * @instance
         */
        TransferFileBlockReply.prototype.result = 0;
    
        /**
         * TransferFileBlockReply blockIdx.
         * @member {number}blockIdx
         * @memberof TransferFileBlockReply
         * @instance
         */
        TransferFileBlockReply.prototype.blockIdx = 0;
    
        /**
         * Creates a new TransferFileBlockReply instance using the specified properties.
         * @function create
         * @memberof TransferFileBlockReply
         * @static
         * @param {ITransferFileBlockReply=} [properties] Properties to set
         * @returns {TransferFileBlockReply} TransferFileBlockReply instance
         */
        TransferFileBlockReply.create = function create(properties) {
            return new TransferFileBlockReply(properties);
        };
    
        /**
         * Encodes the specified TransferFileBlockReply message. Does not implicitly {@link TransferFileBlockReply.verify|verify} messages.
         * @function encode
         * @memberof TransferFileBlockReply
         * @static
         * @param {ITransferFileBlockReply} message TransferFileBlockReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferFileBlockReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.blockIdx);
            return writer;
        };
    
        /**
         * Encodes the specified TransferFileBlockReply message, length delimited. Does not implicitly {@link TransferFileBlockReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof TransferFileBlockReply
         * @static
         * @param {ITransferFileBlockReply} message TransferFileBlockReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferFileBlockReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a TransferFileBlockReply message from the specified reader or buffer.
         * @function decode
         * @memberof TransferFileBlockReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {TransferFileBlockReply} TransferFileBlockReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferFileBlockReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TransferFileBlockReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.blockIdx = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            if (!message.hasOwnProperty("blockIdx"))
                throw $util.ProtocolError("missing required 'blockIdx'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a TransferFileBlockReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof TransferFileBlockReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {TransferFileBlockReply} TransferFileBlockReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferFileBlockReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a TransferFileBlockReply message.
         * @function verify
         * @memberof TransferFileBlockReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransferFileBlockReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.result) {
            default:
                return "result: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                break;
            }
            if (!$util.isInteger(message.blockIdx))
                return "blockIdx: integer expected";
            return null;
        };
    
        /**
         * Creates a TransferFileBlockReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof TransferFileBlockReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {TransferFileBlockReply} TransferFileBlockReply
         */
        TransferFileBlockReply.fromObject = function fromObject(object) {
            if (object instanceof $root.TransferFileBlockReply)
                return object;
            var message = new $root.TransferFileBlockReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            if (object.blockIdx != null)
                message.blockIdx = object.blockIdx >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a TransferFileBlockReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof TransferFileBlockReply
         * @static
         * @param {TransferFileBlockReply} message TransferFileBlockReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransferFileBlockReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
                object.blockIdx = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            if (message.blockIdx != null && message.hasOwnProperty("blockIdx"))
                object.blockIdx = message.blockIdx;
            return object;
        };
    
        /**
         * Converts this TransferFileBlockReply to JSON.
         * @function toJSON
         * @memberof TransferFileBlockReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransferFileBlockReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return TransferFileBlockReply;
    })();
    
    $root.TransferFileComplete = (function() {
    
        /**
         * Properties of a TransferFileComplete.
         * @exports ITransferFileComplete
         * @interface ITransferFileComplete
         * @property {Result} result TransferFileComplete result
         */
    
        /**
         * Constructs a new TransferFileComplete.
         * @exports TransferFileComplete
         * @classdesc Represents a TransferFileComplete.
         * @constructor
         * @param {ITransferFileComplete=} [properties] Properties to set
         */
        function TransferFileComplete(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * TransferFileComplete result.
         * @member {Result}result
         * @memberof TransferFileComplete
         * @instance
         */
        TransferFileComplete.prototype.result = 0;
    
        /**
         * Creates a new TransferFileComplete instance using the specified properties.
         * @function create
         * @memberof TransferFileComplete
         * @static
         * @param {ITransferFileComplete=} [properties] Properties to set
         * @returns {TransferFileComplete} TransferFileComplete instance
         */
        TransferFileComplete.create = function create(properties) {
            return new TransferFileComplete(properties);
        };
    
        /**
         * Encodes the specified TransferFileComplete message. Does not implicitly {@link TransferFileComplete.verify|verify} messages.
         * @function encode
         * @memberof TransferFileComplete
         * @static
         * @param {ITransferFileComplete} message TransferFileComplete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferFileComplete.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified TransferFileComplete message, length delimited. Does not implicitly {@link TransferFileComplete.verify|verify} messages.
         * @function encodeDelimited
         * @memberof TransferFileComplete
         * @static
         * @param {ITransferFileComplete} message TransferFileComplete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferFileComplete.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a TransferFileComplete message from the specified reader or buffer.
         * @function decode
         * @memberof TransferFileComplete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {TransferFileComplete} TransferFileComplete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferFileComplete.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TransferFileComplete();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a TransferFileComplete message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof TransferFileComplete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {TransferFileComplete} TransferFileComplete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferFileComplete.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a TransferFileComplete message.
         * @function verify
         * @memberof TransferFileComplete
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransferFileComplete.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.result) {
            default:
                return "result: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                break;
            }
            return null;
        };
    
        /**
         * Creates a TransferFileComplete message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof TransferFileComplete
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {TransferFileComplete} TransferFileComplete
         */
        TransferFileComplete.fromObject = function fromObject(object) {
            if (object instanceof $root.TransferFileComplete)
                return object;
            var message = new $root.TransferFileComplete();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a TransferFileComplete message. Also converts values to other types if specified.
         * @function toObject
         * @memberof TransferFileComplete
         * @static
         * @param {TransferFileComplete} message TransferFileComplete
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransferFileComplete.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this TransferFileComplete to JSON.
         * @function toJSON
         * @memberof TransferFileComplete
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransferFileComplete.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return TransferFileComplete;
    })();
    
    $root.StartKeyExchangeRequest = (function() {
    
        /**
         * Properties of a StartKeyExchangeRequest.
         * @exports IStartKeyExchangeRequest
         * @interface IStartKeyExchangeRequest
         */
    
        /**
         * Constructs a new StartKeyExchangeRequest.
         * @exports StartKeyExchangeRequest
         * @classdesc Represents a StartKeyExchangeRequest.
         * @constructor
         * @param {IStartKeyExchangeRequest=} [properties] Properties to set
         */
        function StartKeyExchangeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new StartKeyExchangeRequest instance using the specified properties.
         * @function create
         * @memberof StartKeyExchangeRequest
         * @static
         * @param {IStartKeyExchangeRequest=} [properties] Properties to set
         * @returns {StartKeyExchangeRequest} StartKeyExchangeRequest instance
         */
        StartKeyExchangeRequest.create = function create(properties) {
            return new StartKeyExchangeRequest(properties);
        };
    
        /**
         * Encodes the specified StartKeyExchangeRequest message. Does not implicitly {@link StartKeyExchangeRequest.verify|verify} messages.
         * @function encode
         * @memberof StartKeyExchangeRequest
         * @static
         * @param {IStartKeyExchangeRequest} message StartKeyExchangeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartKeyExchangeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified StartKeyExchangeRequest message, length delimited. Does not implicitly {@link StartKeyExchangeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof StartKeyExchangeRequest
         * @static
         * @param {IStartKeyExchangeRequest} message StartKeyExchangeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartKeyExchangeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a StartKeyExchangeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof StartKeyExchangeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {StartKeyExchangeRequest} StartKeyExchangeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartKeyExchangeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartKeyExchangeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a StartKeyExchangeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof StartKeyExchangeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {StartKeyExchangeRequest} StartKeyExchangeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartKeyExchangeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a StartKeyExchangeRequest message.
         * @function verify
         * @memberof StartKeyExchangeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartKeyExchangeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a StartKeyExchangeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof StartKeyExchangeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {StartKeyExchangeRequest} StartKeyExchangeRequest
         */
        StartKeyExchangeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.StartKeyExchangeRequest)
                return object;
            return new $root.StartKeyExchangeRequest();
        };
    
        /**
         * Creates a plain object from a StartKeyExchangeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof StartKeyExchangeRequest
         * @static
         * @param {StartKeyExchangeRequest} message StartKeyExchangeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartKeyExchangeRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this StartKeyExchangeRequest to JSON.
         * @function toJSON
         * @memberof StartKeyExchangeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartKeyExchangeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return StartKeyExchangeRequest;
    })();
    
    $root.StartKeyExchangeReply = (function() {
    
        /**
         * Properties of a StartKeyExchangeReply.
         * @exports IStartKeyExchangeReply
         * @interface IStartKeyExchangeReply
         * @property {Uint8Array} secretKey StartKeyExchangeReply secretKey
         * @property {Result} [result] StartKeyExchangeReply result
         */
    
        /**
         * Constructs a new StartKeyExchangeReply.
         * @exports StartKeyExchangeReply
         * @classdesc Represents a StartKeyExchangeReply.
         * @constructor
         * @param {IStartKeyExchangeReply=} [properties] Properties to set
         */
        function StartKeyExchangeReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * StartKeyExchangeReply secretKey.
         * @member {Uint8Array}secretKey
         * @memberof StartKeyExchangeReply
         * @instance
         */
        StartKeyExchangeReply.prototype.secretKey = $util.newBuffer([]);
    
        /**
         * StartKeyExchangeReply result.
         * @member {Result}result
         * @memberof StartKeyExchangeReply
         * @instance
         */
        StartKeyExchangeReply.prototype.result = 0;
    
        /**
         * Creates a new StartKeyExchangeReply instance using the specified properties.
         * @function create
         * @memberof StartKeyExchangeReply
         * @static
         * @param {IStartKeyExchangeReply=} [properties] Properties to set
         * @returns {StartKeyExchangeReply} StartKeyExchangeReply instance
         */
        StartKeyExchangeReply.create = function create(properties) {
            return new StartKeyExchangeReply(properties);
        };
    
        /**
         * Encodes the specified StartKeyExchangeReply message. Does not implicitly {@link StartKeyExchangeReply.verify|verify} messages.
         * @function encode
         * @memberof StartKeyExchangeReply
         * @static
         * @param {IStartKeyExchangeReply} message StartKeyExchangeReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartKeyExchangeReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.secretKey);
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified StartKeyExchangeReply message, length delimited. Does not implicitly {@link StartKeyExchangeReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof StartKeyExchangeReply
         * @static
         * @param {IStartKeyExchangeReply} message StartKeyExchangeReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartKeyExchangeReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a StartKeyExchangeReply message from the specified reader or buffer.
         * @function decode
         * @memberof StartKeyExchangeReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {StartKeyExchangeReply} StartKeyExchangeReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartKeyExchangeReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StartKeyExchangeReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.secretKey = reader.bytes();
                    break;
                case 2:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("secretKey"))
                throw $util.ProtocolError("missing required 'secretKey'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a StartKeyExchangeReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof StartKeyExchangeReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {StartKeyExchangeReply} StartKeyExchangeReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartKeyExchangeReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a StartKeyExchangeReply message.
         * @function verify
         * @memberof StartKeyExchangeReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartKeyExchangeReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!(message.secretKey && typeof message.secretKey.length === "number" || $util.isString(message.secretKey)))
                return "secretKey: buffer expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a StartKeyExchangeReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof StartKeyExchangeReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {StartKeyExchangeReply} StartKeyExchangeReply
         */
        StartKeyExchangeReply.fromObject = function fromObject(object) {
            if (object instanceof $root.StartKeyExchangeReply)
                return object;
            var message = new $root.StartKeyExchangeReply();
            if (object.secretKey != null)
                if (typeof object.secretKey === "string")
                    $util.base64.decode(object.secretKey, message.secretKey = $util.newBuffer($util.base64.length(object.secretKey)), 0);
                else if (object.secretKey.length)
                    message.secretKey = object.secretKey;
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a StartKeyExchangeReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof StartKeyExchangeReply
         * @static
         * @param {StartKeyExchangeReply} message StartKeyExchangeReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartKeyExchangeReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.secretKey = options.bytes === String ? "" : [];
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            }
            if (message.secretKey != null && message.hasOwnProperty("secretKey"))
                object.secretKey = options.bytes === String ? $util.base64.encode(message.secretKey, 0, message.secretKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.secretKey) : message.secretKey;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this StartKeyExchangeReply to JSON.
         * @function toJSON
         * @memberof StartKeyExchangeReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartKeyExchangeReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return StartKeyExchangeReply;
    })();
    
    $root.CancelKeyExchangeRequest = (function() {
    
        /**
         * Properties of a CancelKeyExchangeRequest.
         * @exports ICancelKeyExchangeRequest
         * @interface ICancelKeyExchangeRequest
         */
    
        /**
         * Constructs a new CancelKeyExchangeRequest.
         * @exports CancelKeyExchangeRequest
         * @classdesc Represents a CancelKeyExchangeRequest.
         * @constructor
         * @param {ICancelKeyExchangeRequest=} [properties] Properties to set
         */
        function CancelKeyExchangeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new CancelKeyExchangeRequest instance using the specified properties.
         * @function create
         * @memberof CancelKeyExchangeRequest
         * @static
         * @param {ICancelKeyExchangeRequest=} [properties] Properties to set
         * @returns {CancelKeyExchangeRequest} CancelKeyExchangeRequest instance
         */
        CancelKeyExchangeRequest.create = function create(properties) {
            return new CancelKeyExchangeRequest(properties);
        };
    
        /**
         * Encodes the specified CancelKeyExchangeRequest message. Does not implicitly {@link CancelKeyExchangeRequest.verify|verify} messages.
         * @function encode
         * @memberof CancelKeyExchangeRequest
         * @static
         * @param {ICancelKeyExchangeRequest} message CancelKeyExchangeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelKeyExchangeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified CancelKeyExchangeRequest message, length delimited. Does not implicitly {@link CancelKeyExchangeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CancelKeyExchangeRequest
         * @static
         * @param {ICancelKeyExchangeRequest} message CancelKeyExchangeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelKeyExchangeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CancelKeyExchangeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof CancelKeyExchangeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CancelKeyExchangeRequest} CancelKeyExchangeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelKeyExchangeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CancelKeyExchangeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CancelKeyExchangeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CancelKeyExchangeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CancelKeyExchangeRequest} CancelKeyExchangeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelKeyExchangeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CancelKeyExchangeRequest message.
         * @function verify
         * @memberof CancelKeyExchangeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelKeyExchangeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a CancelKeyExchangeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CancelKeyExchangeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CancelKeyExchangeRequest} CancelKeyExchangeRequest
         */
        CancelKeyExchangeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.CancelKeyExchangeRequest)
                return object;
            return new $root.CancelKeyExchangeRequest();
        };
    
        /**
         * Creates a plain object from a CancelKeyExchangeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CancelKeyExchangeRequest
         * @static
         * @param {CancelKeyExchangeRequest} message CancelKeyExchangeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CancelKeyExchangeRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this CancelKeyExchangeRequest to JSON.
         * @function toJSON
         * @memberof CancelKeyExchangeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CancelKeyExchangeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CancelKeyExchangeRequest;
    })();
    
    $root.CancelKeyExchangeReply = (function() {
    
        /**
         * Properties of a CancelKeyExchangeReply.
         * @exports ICancelKeyExchangeReply
         * @interface ICancelKeyExchangeReply
         * @property {Result} result CancelKeyExchangeReply result
         */
    
        /**
         * Constructs a new CancelKeyExchangeReply.
         * @exports CancelKeyExchangeReply
         * @classdesc Represents a CancelKeyExchangeReply.
         * @constructor
         * @param {ICancelKeyExchangeReply=} [properties] Properties to set
         */
        function CancelKeyExchangeReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * CancelKeyExchangeReply result.
         * @member {Result}result
         * @memberof CancelKeyExchangeReply
         * @instance
         */
        CancelKeyExchangeReply.prototype.result = 0;
    
        /**
         * Creates a new CancelKeyExchangeReply instance using the specified properties.
         * @function create
         * @memberof CancelKeyExchangeReply
         * @static
         * @param {ICancelKeyExchangeReply=} [properties] Properties to set
         * @returns {CancelKeyExchangeReply} CancelKeyExchangeReply instance
         */
        CancelKeyExchangeReply.create = function create(properties) {
            return new CancelKeyExchangeReply(properties);
        };
    
        /**
         * Encodes the specified CancelKeyExchangeReply message. Does not implicitly {@link CancelKeyExchangeReply.verify|verify} messages.
         * @function encode
         * @memberof CancelKeyExchangeReply
         * @static
         * @param {ICancelKeyExchangeReply} message CancelKeyExchangeReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelKeyExchangeReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified CancelKeyExchangeReply message, length delimited. Does not implicitly {@link CancelKeyExchangeReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CancelKeyExchangeReply
         * @static
         * @param {ICancelKeyExchangeReply} message CancelKeyExchangeReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelKeyExchangeReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CancelKeyExchangeReply message from the specified reader or buffer.
         * @function decode
         * @memberof CancelKeyExchangeReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CancelKeyExchangeReply} CancelKeyExchangeReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelKeyExchangeReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CancelKeyExchangeReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CancelKeyExchangeReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CancelKeyExchangeReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CancelKeyExchangeReply} CancelKeyExchangeReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelKeyExchangeReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CancelKeyExchangeReply message.
         * @function verify
         * @memberof CancelKeyExchangeReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelKeyExchangeReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.result) {
            default:
                return "result: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                break;
            }
            return null;
        };
    
        /**
         * Creates a CancelKeyExchangeReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CancelKeyExchangeReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CancelKeyExchangeReply} CancelKeyExchangeReply
         */
        CancelKeyExchangeReply.fromObject = function fromObject(object) {
            if (object instanceof $root.CancelKeyExchangeReply)
                return object;
            var message = new $root.CancelKeyExchangeReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CancelKeyExchangeReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CancelKeyExchangeReply
         * @static
         * @param {CancelKeyExchangeReply} message CancelKeyExchangeReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CancelKeyExchangeReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this CancelKeyExchangeReply to JSON.
         * @function toJSON
         * @memberof CancelKeyExchangeReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CancelKeyExchangeReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return CancelKeyExchangeReply;
    })();
    
    $root.SubmitKeyRequest = (function() {
    
        /**
         * Properties of a SubmitKeyRequest.
         * @exports ISubmitKeyRequest
         * @interface ISubmitKeyRequest
         * @property {Uint8Array} secretKey SubmitKeyRequest secretKey
         */
    
        /**
         * Constructs a new SubmitKeyRequest.
         * @exports SubmitKeyRequest
         * @classdesc Represents a SubmitKeyRequest.
         * @constructor
         * @param {ISubmitKeyRequest=} [properties] Properties to set
         */
        function SubmitKeyRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * SubmitKeyRequest secretKey.
         * @member {Uint8Array}secretKey
         * @memberof SubmitKeyRequest
         * @instance
         */
        SubmitKeyRequest.prototype.secretKey = $util.newBuffer([]);
    
        /**
         * Creates a new SubmitKeyRequest instance using the specified properties.
         * @function create
         * @memberof SubmitKeyRequest
         * @static
         * @param {ISubmitKeyRequest=} [properties] Properties to set
         * @returns {SubmitKeyRequest} SubmitKeyRequest instance
         */
        SubmitKeyRequest.create = function create(properties) {
            return new SubmitKeyRequest(properties);
        };
    
        /**
         * Encodes the specified SubmitKeyRequest message. Does not implicitly {@link SubmitKeyRequest.verify|verify} messages.
         * @function encode
         * @memberof SubmitKeyRequest
         * @static
         * @param {ISubmitKeyRequest} message SubmitKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubmitKeyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.secretKey);
            return writer;
        };
    
        /**
         * Encodes the specified SubmitKeyRequest message, length delimited. Does not implicitly {@link SubmitKeyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SubmitKeyRequest
         * @static
         * @param {ISubmitKeyRequest} message SubmitKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubmitKeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SubmitKeyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof SubmitKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SubmitKeyRequest} SubmitKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubmitKeyRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SubmitKeyRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.secretKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("secretKey"))
                throw $util.ProtocolError("missing required 'secretKey'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SubmitKeyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SubmitKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SubmitKeyRequest} SubmitKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubmitKeyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SubmitKeyRequest message.
         * @function verify
         * @memberof SubmitKeyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubmitKeyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!(message.secretKey && typeof message.secretKey.length === "number" || $util.isString(message.secretKey)))
                return "secretKey: buffer expected";
            return null;
        };
    
        /**
         * Creates a SubmitKeyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SubmitKeyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SubmitKeyRequest} SubmitKeyRequest
         */
        SubmitKeyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.SubmitKeyRequest)
                return object;
            var message = new $root.SubmitKeyRequest();
            if (object.secretKey != null)
                if (typeof object.secretKey === "string")
                    $util.base64.decode(object.secretKey, message.secretKey = $util.newBuffer($util.base64.length(object.secretKey)), 0);
                else if (object.secretKey.length)
                    message.secretKey = object.secretKey;
            return message;
        };
    
        /**
         * Creates a plain object from a SubmitKeyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SubmitKeyRequest
         * @static
         * @param {SubmitKeyRequest} message SubmitKeyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubmitKeyRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.secretKey = options.bytes === String ? "" : [];
            if (message.secretKey != null && message.hasOwnProperty("secretKey"))
                object.secretKey = options.bytes === String ? $util.base64.encode(message.secretKey, 0, message.secretKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.secretKey) : message.secretKey;
            return object;
        };
    
        /**
         * Converts this SubmitKeyRequest to JSON.
         * @function toJSON
         * @memberof SubmitKeyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubmitKeyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SubmitKeyRequest;
    })();
    
    $root.SubmitKeyReply = (function() {
    
        /**
         * Properties of a SubmitKeyReply.
         * @exports ISubmitKeyReply
         * @interface ISubmitKeyReply
         * @property {Result} [result] SubmitKeyReply result
         */
    
        /**
         * Constructs a new SubmitKeyReply.
         * @exports SubmitKeyReply
         * @classdesc Represents a SubmitKeyReply.
         * @constructor
         * @param {ISubmitKeyReply=} [properties] Properties to set
         */
        function SubmitKeyReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * SubmitKeyReply result.
         * @member {Result}result
         * @memberof SubmitKeyReply
         * @instance
         */
        SubmitKeyReply.prototype.result = 0;
    
        /**
         * Creates a new SubmitKeyReply instance using the specified properties.
         * @function create
         * @memberof SubmitKeyReply
         * @static
         * @param {ISubmitKeyReply=} [properties] Properties to set
         * @returns {SubmitKeyReply} SubmitKeyReply instance
         */
        SubmitKeyReply.create = function create(properties) {
            return new SubmitKeyReply(properties);
        };
    
        /**
         * Encodes the specified SubmitKeyReply message. Does not implicitly {@link SubmitKeyReply.verify|verify} messages.
         * @function encode
         * @memberof SubmitKeyReply
         * @static
         * @param {ISubmitKeyReply} message SubmitKeyReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubmitKeyReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified SubmitKeyReply message, length delimited. Does not implicitly {@link SubmitKeyReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SubmitKeyReply
         * @static
         * @param {ISubmitKeyReply} message SubmitKeyReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubmitKeyReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SubmitKeyReply message from the specified reader or buffer.
         * @function decode
         * @memberof SubmitKeyReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SubmitKeyReply} SubmitKeyReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubmitKeyReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SubmitKeyReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a SubmitKeyReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SubmitKeyReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SubmitKeyReply} SubmitKeyReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubmitKeyReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SubmitKeyReply message.
         * @function verify
         * @memberof SubmitKeyReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubmitKeyReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a SubmitKeyReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SubmitKeyReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SubmitKeyReply} SubmitKeyReply
         */
        SubmitKeyReply.fromObject = function fromObject(object) {
            if (object instanceof $root.SubmitKeyReply)
                return object;
            var message = new $root.SubmitKeyReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a SubmitKeyReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SubmitKeyReply
         * @static
         * @param {SubmitKeyReply} message SubmitKeyReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubmitKeyReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this SubmitKeyReply to JSON.
         * @function toJSON
         * @memberof SubmitKeyReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubmitKeyReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SubmitKeyReply;
    })();
    
    $root.PredictionUpdate = (function() {
    
        /**
         * Properties of a PredictionUpdate.
         * @exports IPredictionUpdate
         * @interface IPredictionUpdate
         * @property {ProgramStep} programStep PredictionUpdate programStep
         * @property {number} finishTimestamp PredictionUpdate finishTimestamp
         * @property {number} [feedId] PredictionUpdate feedId
         * @property {number} [sequenceNumber] PredictionUpdate sequenceNumber
         */
    
        /**
         * Constructs a new PredictionUpdate.
         * @exports PredictionUpdate
         * @classdesc Represents a PredictionUpdate.
         * @constructor
         * @param {IPredictionUpdate=} [properties] Properties to set
         */
        function PredictionUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PredictionUpdate programStep.
         * @member {ProgramStep}programStep
         * @memberof PredictionUpdate
         * @instance
         */
        PredictionUpdate.prototype.programStep = 0;
    
        /**
         * PredictionUpdate finishTimestamp.
         * @member {number}finishTimestamp
         * @memberof PredictionUpdate
         * @instance
         */
        PredictionUpdate.prototype.finishTimestamp = 0;
    
        /**
         * PredictionUpdate feedId.
         * @member {number}feedId
         * @memberof PredictionUpdate
         * @instance
         */
        PredictionUpdate.prototype.feedId = 0;
    
        /**
         * PredictionUpdate sequenceNumber.
         * @member {number}sequenceNumber
         * @memberof PredictionUpdate
         * @instance
         */
        PredictionUpdate.prototype.sequenceNumber = 0;
    
        /**
         * Creates a new PredictionUpdate instance using the specified properties.
         * @function create
         * @memberof PredictionUpdate
         * @static
         * @param {IPredictionUpdate=} [properties] Properties to set
         * @returns {PredictionUpdate} PredictionUpdate instance
         */
        PredictionUpdate.create = function create(properties) {
            return new PredictionUpdate(properties);
        };
    
        /**
         * Encodes the specified PredictionUpdate message. Does not implicitly {@link PredictionUpdate.verify|verify} messages.
         * @function encode
         * @memberof PredictionUpdate
         * @static
         * @param {IPredictionUpdate} message PredictionUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PredictionUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.programStep);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.finishTimestamp);
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.feedId);
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.sequenceNumber);
            return writer;
        };
    
        /**
         * Encodes the specified PredictionUpdate message, length delimited. Does not implicitly {@link PredictionUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PredictionUpdate
         * @static
         * @param {IPredictionUpdate} message PredictionUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PredictionUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PredictionUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof PredictionUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PredictionUpdate} PredictionUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PredictionUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PredictionUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.programStep = reader.int32();
                    break;
                case 2:
                    message.finishTimestamp = reader.uint32();
                    break;
                case 3:
                    message.feedId = reader.uint32();
                    break;
                case 4:
                    message.sequenceNumber = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("programStep"))
                throw $util.ProtocolError("missing required 'programStep'", { instance: message });
            if (!message.hasOwnProperty("finishTimestamp"))
                throw $util.ProtocolError("missing required 'finishTimestamp'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a PredictionUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PredictionUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PredictionUpdate} PredictionUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PredictionUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PredictionUpdate message.
         * @function verify
         * @memberof PredictionUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PredictionUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.programStep) {
            default:
                return "programStep: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
            if (!$util.isInteger(message.finishTimestamp))
                return "finishTimestamp: integer expected";
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                if (!$util.isInteger(message.feedId))
                    return "feedId: integer expected";
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                if (!$util.isInteger(message.sequenceNumber))
                    return "sequenceNumber: integer expected";
            return null;
        };
    
        /**
         * Creates a PredictionUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PredictionUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PredictionUpdate} PredictionUpdate
         */
        PredictionUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.PredictionUpdate)
                return object;
            var message = new $root.PredictionUpdate();
            switch (object.programStep) {
            case "UNKNOWN":
            case 0:
                message.programStep = 0;
                break;
            case "PRE_HEAT":
            case 1:
                message.programStep = 1;
                break;
            case "WAIT_FOR_FOOD":
            case 2:
                message.programStep = 2;
                break;
            case "COOK":
            case 3:
                message.programStep = 3;
                break;
            case "WAIT_FOR_REMOVE_FOOD":
            case 4:
                message.programStep = 4;
                break;
            case "ERROR":
            case 5:
                message.programStep = 5;
                break;
            }
            if (object.finishTimestamp != null)
                message.finishTimestamp = object.finishTimestamp >>> 0;
            if (object.feedId != null)
                message.feedId = object.feedId >>> 0;
            if (object.sequenceNumber != null)
                message.sequenceNumber = object.sequenceNumber >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PredictionUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PredictionUpdate
         * @static
         * @param {PredictionUpdate} message PredictionUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PredictionUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.programStep = options.enums === String ? "UNKNOWN" : 0;
                object.finishTimestamp = 0;
                object.feedId = 0;
                object.sequenceNumber = 0;
            }
            if (message.programStep != null && message.hasOwnProperty("programStep"))
                object.programStep = options.enums === String ? $root.ProgramStep[message.programStep] : message.programStep;
            if (message.finishTimestamp != null && message.hasOwnProperty("finishTimestamp"))
                object.finishTimestamp = message.finishTimestamp;
            if (message.feedId != null && message.hasOwnProperty("feedId"))
                object.feedId = message.feedId;
            if (message.sequenceNumber != null && message.hasOwnProperty("sequenceNumber"))
                object.sequenceNumber = message.sequenceNumber;
            return object;
        };
    
        /**
         * Converts this PredictionUpdate to JSON.
         * @function toJSON
         * @memberof PredictionUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PredictionUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PredictionUpdate;
    })();
    
    $root.SubmitBearerAuthTokenRequest = (function() {
    
        /**
         * Properties of a SubmitBearerAuthTokenRequest.
         * @exports ISubmitBearerAuthTokenRequest
         * @interface ISubmitBearerAuthTokenRequest
         * @property {string} token SubmitBearerAuthTokenRequest token
         */
    
        /**
         * Constructs a new SubmitBearerAuthTokenRequest.
         * @exports SubmitBearerAuthTokenRequest
         * @classdesc Represents a SubmitBearerAuthTokenRequest.
         * @constructor
         * @param {ISubmitBearerAuthTokenRequest=} [properties] Properties to set
         */
        function SubmitBearerAuthTokenRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * SubmitBearerAuthTokenRequest token.
         * @member {string}token
         * @memberof SubmitBearerAuthTokenRequest
         * @instance
         */
        SubmitBearerAuthTokenRequest.prototype.token = "";
    
        /**
         * Creates a new SubmitBearerAuthTokenRequest instance using the specified properties.
         * @function create
         * @memberof SubmitBearerAuthTokenRequest
         * @static
         * @param {ISubmitBearerAuthTokenRequest=} [properties] Properties to set
         * @returns {SubmitBearerAuthTokenRequest} SubmitBearerAuthTokenRequest instance
         */
        SubmitBearerAuthTokenRequest.create = function create(properties) {
            return new SubmitBearerAuthTokenRequest(properties);
        };
    
        /**
         * Encodes the specified SubmitBearerAuthTokenRequest message. Does not implicitly {@link SubmitBearerAuthTokenRequest.verify|verify} messages.
         * @function encode
         * @memberof SubmitBearerAuthTokenRequest
         * @static
         * @param {ISubmitBearerAuthTokenRequest} message SubmitBearerAuthTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubmitBearerAuthTokenRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);
            return writer;
        };
    
        /**
         * Encodes the specified SubmitBearerAuthTokenRequest message, length delimited. Does not implicitly {@link SubmitBearerAuthTokenRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SubmitBearerAuthTokenRequest
         * @static
         * @param {ISubmitBearerAuthTokenRequest} message SubmitBearerAuthTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubmitBearerAuthTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SubmitBearerAuthTokenRequest message from the specified reader or buffer.
         * @function decode
         * @memberof SubmitBearerAuthTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SubmitBearerAuthTokenRequest} SubmitBearerAuthTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubmitBearerAuthTokenRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SubmitBearerAuthTokenRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("token"))
                throw $util.ProtocolError("missing required 'token'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SubmitBearerAuthTokenRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SubmitBearerAuthTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SubmitBearerAuthTokenRequest} SubmitBearerAuthTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubmitBearerAuthTokenRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SubmitBearerAuthTokenRequest message.
         * @function verify
         * @memberof SubmitBearerAuthTokenRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubmitBearerAuthTokenRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.token))
                return "token: string expected";
            return null;
        };
    
        /**
         * Creates a SubmitBearerAuthTokenRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SubmitBearerAuthTokenRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SubmitBearerAuthTokenRequest} SubmitBearerAuthTokenRequest
         */
        SubmitBearerAuthTokenRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.SubmitBearerAuthTokenRequest)
                return object;
            var message = new $root.SubmitBearerAuthTokenRequest();
            if (object.token != null)
                message.token = String(object.token);
            return message;
        };
    
        /**
         * Creates a plain object from a SubmitBearerAuthTokenRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SubmitBearerAuthTokenRequest
         * @static
         * @param {SubmitBearerAuthTokenRequest} message SubmitBearerAuthTokenRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubmitBearerAuthTokenRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.token = "";
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = message.token;
            return object;
        };
    
        /**
         * Converts this SubmitBearerAuthTokenRequest to JSON.
         * @function toJSON
         * @memberof SubmitBearerAuthTokenRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubmitBearerAuthTokenRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SubmitBearerAuthTokenRequest;
    })();
    
    $root.SubmitBearerAuthTokenReply = (function() {
    
        /**
         * Properties of a SubmitBearerAuthTokenReply.
         * @exports ISubmitBearerAuthTokenReply
         * @interface ISubmitBearerAuthTokenReply
         * @property {Result} [result] SubmitBearerAuthTokenReply result
         */
    
        /**
         * Constructs a new SubmitBearerAuthTokenReply.
         * @exports SubmitBearerAuthTokenReply
         * @classdesc Represents a SubmitBearerAuthTokenReply.
         * @constructor
         * @param {ISubmitBearerAuthTokenReply=} [properties] Properties to set
         */
        function SubmitBearerAuthTokenReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * SubmitBearerAuthTokenReply result.
         * @member {Result}result
         * @memberof SubmitBearerAuthTokenReply
         * @instance
         */
        SubmitBearerAuthTokenReply.prototype.result = 0;
    
        /**
         * Creates a new SubmitBearerAuthTokenReply instance using the specified properties.
         * @function create
         * @memberof SubmitBearerAuthTokenReply
         * @static
         * @param {ISubmitBearerAuthTokenReply=} [properties] Properties to set
         * @returns {SubmitBearerAuthTokenReply} SubmitBearerAuthTokenReply instance
         */
        SubmitBearerAuthTokenReply.create = function create(properties) {
            return new SubmitBearerAuthTokenReply(properties);
        };
    
        /**
         * Encodes the specified SubmitBearerAuthTokenReply message. Does not implicitly {@link SubmitBearerAuthTokenReply.verify|verify} messages.
         * @function encode
         * @memberof SubmitBearerAuthTokenReply
         * @static
         * @param {ISubmitBearerAuthTokenReply} message SubmitBearerAuthTokenReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubmitBearerAuthTokenReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified SubmitBearerAuthTokenReply message, length delimited. Does not implicitly {@link SubmitBearerAuthTokenReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SubmitBearerAuthTokenReply
         * @static
         * @param {ISubmitBearerAuthTokenReply} message SubmitBearerAuthTokenReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubmitBearerAuthTokenReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SubmitBearerAuthTokenReply message from the specified reader or buffer.
         * @function decode
         * @memberof SubmitBearerAuthTokenReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SubmitBearerAuthTokenReply} SubmitBearerAuthTokenReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubmitBearerAuthTokenReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SubmitBearerAuthTokenReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a SubmitBearerAuthTokenReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SubmitBearerAuthTokenReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SubmitBearerAuthTokenReply} SubmitBearerAuthTokenReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubmitBearerAuthTokenReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SubmitBearerAuthTokenReply message.
         * @function verify
         * @memberof SubmitBearerAuthTokenReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubmitBearerAuthTokenReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a SubmitBearerAuthTokenReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SubmitBearerAuthTokenReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SubmitBearerAuthTokenReply} SubmitBearerAuthTokenReply
         */
        SubmitBearerAuthTokenReply.fromObject = function fromObject(object) {
            if (object instanceof $root.SubmitBearerAuthTokenReply)
                return object;
            var message = new $root.SubmitBearerAuthTokenReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a SubmitBearerAuthTokenReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SubmitBearerAuthTokenReply
         * @static
         * @param {SubmitBearerAuthTokenReply} message SubmitBearerAuthTokenReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubmitBearerAuthTokenReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this SubmitBearerAuthTokenReply to JSON.
         * @function toJSON
         * @memberof SubmitBearerAuthTokenReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubmitBearerAuthTokenReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SubmitBearerAuthTokenReply;
    })();
    
    $root.FactoryResetRequest = (function() {
    
        /**
         * Properties of a FactoryResetRequest.
         * @exports IFactoryResetRequest
         * @interface IFactoryResetRequest
         * @property {boolean} restart FactoryResetRequest restart
         */
    
        /**
         * Constructs a new FactoryResetRequest.
         * @exports FactoryResetRequest
         * @classdesc Represents a FactoryResetRequest.
         * @constructor
         * @param {IFactoryResetRequest=} [properties] Properties to set
         */
        function FactoryResetRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * FactoryResetRequest restart.
         * @member {boolean}restart
         * @memberof FactoryResetRequest
         * @instance
         */
        FactoryResetRequest.prototype.restart = false;
    
        /**
         * Creates a new FactoryResetRequest instance using the specified properties.
         * @function create
         * @memberof FactoryResetRequest
         * @static
         * @param {IFactoryResetRequest=} [properties] Properties to set
         * @returns {FactoryResetRequest} FactoryResetRequest instance
         */
        FactoryResetRequest.create = function create(properties) {
            return new FactoryResetRequest(properties);
        };
    
        /**
         * Encodes the specified FactoryResetRequest message. Does not implicitly {@link FactoryResetRequest.verify|verify} messages.
         * @function encode
         * @memberof FactoryResetRequest
         * @static
         * @param {IFactoryResetRequest} message FactoryResetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FactoryResetRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.restart);
            return writer;
        };
    
        /**
         * Encodes the specified FactoryResetRequest message, length delimited. Does not implicitly {@link FactoryResetRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof FactoryResetRequest
         * @static
         * @param {IFactoryResetRequest} message FactoryResetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FactoryResetRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a FactoryResetRequest message from the specified reader or buffer.
         * @function decode
         * @memberof FactoryResetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FactoryResetRequest} FactoryResetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FactoryResetRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FactoryResetRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.restart = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("restart"))
                throw $util.ProtocolError("missing required 'restart'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a FactoryResetRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FactoryResetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FactoryResetRequest} FactoryResetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FactoryResetRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a FactoryResetRequest message.
         * @function verify
         * @memberof FactoryResetRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FactoryResetRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.restart !== "boolean")
                return "restart: boolean expected";
            return null;
        };
    
        /**
         * Creates a FactoryResetRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof FactoryResetRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {FactoryResetRequest} FactoryResetRequest
         */
        FactoryResetRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.FactoryResetRequest)
                return object;
            var message = new $root.FactoryResetRequest();
            if (object.restart != null)
                message.restart = Boolean(object.restart);
            return message;
        };
    
        /**
         * Creates a plain object from a FactoryResetRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof FactoryResetRequest
         * @static
         * @param {FactoryResetRequest} message FactoryResetRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FactoryResetRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.restart = false;
            if (message.restart != null && message.hasOwnProperty("restart"))
                object.restart = message.restart;
            return object;
        };
    
        /**
         * Converts this FactoryResetRequest to JSON.
         * @function toJSON
         * @memberof FactoryResetRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FactoryResetRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return FactoryResetRequest;
    })();
    
    $root.FactoryResetReply = (function() {
    
        /**
         * Properties of a FactoryResetReply.
         * @exports IFactoryResetReply
         * @interface IFactoryResetReply
         * @property {Result} [result] FactoryResetReply result
         */
    
        /**
         * Constructs a new FactoryResetReply.
         * @exports FactoryResetReply
         * @classdesc Represents a FactoryResetReply.
         * @constructor
         * @param {IFactoryResetReply=} [properties] Properties to set
         */
        function FactoryResetReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * FactoryResetReply result.
         * @member {Result}result
         * @memberof FactoryResetReply
         * @instance
         */
        FactoryResetReply.prototype.result = 0;
    
        /**
         * Creates a new FactoryResetReply instance using the specified properties.
         * @function create
         * @memberof FactoryResetReply
         * @static
         * @param {IFactoryResetReply=} [properties] Properties to set
         * @returns {FactoryResetReply} FactoryResetReply instance
         */
        FactoryResetReply.create = function create(properties) {
            return new FactoryResetReply(properties);
        };
    
        /**
         * Encodes the specified FactoryResetReply message. Does not implicitly {@link FactoryResetReply.verify|verify} messages.
         * @function encode
         * @memberof FactoryResetReply
         * @static
         * @param {IFactoryResetReply} message FactoryResetReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FactoryResetReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified FactoryResetReply message, length delimited. Does not implicitly {@link FactoryResetReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof FactoryResetReply
         * @static
         * @param {IFactoryResetReply} message FactoryResetReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FactoryResetReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a FactoryResetReply message from the specified reader or buffer.
         * @function decode
         * @memberof FactoryResetReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {FactoryResetReply} FactoryResetReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FactoryResetReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FactoryResetReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a FactoryResetReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof FactoryResetReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {FactoryResetReply} FactoryResetReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FactoryResetReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a FactoryResetReply message.
         * @function verify
         * @memberof FactoryResetReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FactoryResetReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a FactoryResetReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof FactoryResetReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {FactoryResetReply} FactoryResetReply
         */
        FactoryResetReply.fromObject = function fromObject(object) {
            if (object instanceof $root.FactoryResetReply)
                return object;
            var message = new $root.FactoryResetReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a FactoryResetReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof FactoryResetReply
         * @static
         * @param {FactoryResetReply} message FactoryResetReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FactoryResetReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this FactoryResetReply to JSON.
         * @function toJSON
         * @memberof FactoryResetReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FactoryResetReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return FactoryResetReply;
    })();
    
    $root.DeviceRestartRequest = (function() {
    
        /**
         * Properties of a DeviceRestartRequest.
         * @exports IDeviceRestartRequest
         * @interface IDeviceRestartRequest
         */
    
        /**
         * Constructs a new DeviceRestartRequest.
         * @exports DeviceRestartRequest
         * @classdesc Represents a DeviceRestartRequest.
         * @constructor
         * @param {IDeviceRestartRequest=} [properties] Properties to set
         */
        function DeviceRestartRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new DeviceRestartRequest instance using the specified properties.
         * @function create
         * @memberof DeviceRestartRequest
         * @static
         * @param {IDeviceRestartRequest=} [properties] Properties to set
         * @returns {DeviceRestartRequest} DeviceRestartRequest instance
         */
        DeviceRestartRequest.create = function create(properties) {
            return new DeviceRestartRequest(properties);
        };
    
        /**
         * Encodes the specified DeviceRestartRequest message. Does not implicitly {@link DeviceRestartRequest.verify|verify} messages.
         * @function encode
         * @memberof DeviceRestartRequest
         * @static
         * @param {IDeviceRestartRequest} message DeviceRestartRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRestartRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified DeviceRestartRequest message, length delimited. Does not implicitly {@link DeviceRestartRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DeviceRestartRequest
         * @static
         * @param {IDeviceRestartRequest} message DeviceRestartRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRestartRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a DeviceRestartRequest message from the specified reader or buffer.
         * @function decode
         * @memberof DeviceRestartRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DeviceRestartRequest} DeviceRestartRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRestartRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeviceRestartRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a DeviceRestartRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DeviceRestartRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DeviceRestartRequest} DeviceRestartRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRestartRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a DeviceRestartRequest message.
         * @function verify
         * @memberof DeviceRestartRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceRestartRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a DeviceRestartRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DeviceRestartRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DeviceRestartRequest} DeviceRestartRequest
         */
        DeviceRestartRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.DeviceRestartRequest)
                return object;
            return new $root.DeviceRestartRequest();
        };
    
        /**
         * Creates a plain object from a DeviceRestartRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DeviceRestartRequest
         * @static
         * @param {DeviceRestartRequest} message DeviceRestartRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceRestartRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this DeviceRestartRequest to JSON.
         * @function toJSON
         * @memberof DeviceRestartRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceRestartRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return DeviceRestartRequest;
    })();
    
    $root.DeviceRestartReply = (function() {
    
        /**
         * Properties of a DeviceRestartReply.
         * @exports IDeviceRestartReply
         * @interface IDeviceRestartReply
         * @property {Result} [result] DeviceRestartReply result
         */
    
        /**
         * Constructs a new DeviceRestartReply.
         * @exports DeviceRestartReply
         * @classdesc Represents a DeviceRestartReply.
         * @constructor
         * @param {IDeviceRestartReply=} [properties] Properties to set
         */
        function DeviceRestartReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * DeviceRestartReply result.
         * @member {Result}result
         * @memberof DeviceRestartReply
         * @instance
         */
        DeviceRestartReply.prototype.result = 0;
    
        /**
         * Creates a new DeviceRestartReply instance using the specified properties.
         * @function create
         * @memberof DeviceRestartReply
         * @static
         * @param {IDeviceRestartReply=} [properties] Properties to set
         * @returns {DeviceRestartReply} DeviceRestartReply instance
         */
        DeviceRestartReply.create = function create(properties) {
            return new DeviceRestartReply(properties);
        };
    
        /**
         * Encodes the specified DeviceRestartReply message. Does not implicitly {@link DeviceRestartReply.verify|verify} messages.
         * @function encode
         * @memberof DeviceRestartReply
         * @static
         * @param {IDeviceRestartReply} message DeviceRestartReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRestartReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified DeviceRestartReply message, length delimited. Does not implicitly {@link DeviceRestartReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof DeviceRestartReply
         * @static
         * @param {IDeviceRestartReply} message DeviceRestartReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRestartReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a DeviceRestartReply message from the specified reader or buffer.
         * @function decode
         * @memberof DeviceRestartReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {DeviceRestartReply} DeviceRestartReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRestartReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeviceRestartReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a DeviceRestartReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof DeviceRestartReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {DeviceRestartReply} DeviceRestartReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRestartReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a DeviceRestartReply message.
         * @function verify
         * @memberof DeviceRestartReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceRestartReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a DeviceRestartReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof DeviceRestartReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {DeviceRestartReply} DeviceRestartReply
         */
        DeviceRestartReply.fromObject = function fromObject(object) {
            if (object instanceof $root.DeviceRestartReply)
                return object;
            var message = new $root.DeviceRestartReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a DeviceRestartReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof DeviceRestartReply
         * @static
         * @param {DeviceRestartReply} message DeviceRestartReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceRestartReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this DeviceRestartReply to JSON.
         * @function toJSON
         * @memberof DeviceRestartReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceRestartReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return DeviceRestartReply;
    })();
    
    $root.TestResetRequest = (function() {
    
        /**
         * Properties of a TestResetRequest.
         * @exports ITestResetRequest
         * @interface ITestResetRequest
         */
    
        /**
         * Constructs a new TestResetRequest.
         * @exports TestResetRequest
         * @classdesc Represents a TestResetRequest.
         * @constructor
         * @param {ITestResetRequest=} [properties] Properties to set
         */
        function TestResetRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new TestResetRequest instance using the specified properties.
         * @function create
         * @memberof TestResetRequest
         * @static
         * @param {ITestResetRequest=} [properties] Properties to set
         * @returns {TestResetRequest} TestResetRequest instance
         */
        TestResetRequest.create = function create(properties) {
            return new TestResetRequest(properties);
        };
    
        /**
         * Encodes the specified TestResetRequest message. Does not implicitly {@link TestResetRequest.verify|verify} messages.
         * @function encode
         * @memberof TestResetRequest
         * @static
         * @param {ITestResetRequest} message TestResetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestResetRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified TestResetRequest message, length delimited. Does not implicitly {@link TestResetRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof TestResetRequest
         * @static
         * @param {ITestResetRequest} message TestResetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestResetRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a TestResetRequest message from the specified reader or buffer.
         * @function decode
         * @memberof TestResetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {TestResetRequest} TestResetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestResetRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestResetRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a TestResetRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof TestResetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {TestResetRequest} TestResetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestResetRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a TestResetRequest message.
         * @function verify
         * @memberof TestResetRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TestResetRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a TestResetRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof TestResetRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {TestResetRequest} TestResetRequest
         */
        TestResetRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.TestResetRequest)
                return object;
            return new $root.TestResetRequest();
        };
    
        /**
         * Creates a plain object from a TestResetRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof TestResetRequest
         * @static
         * @param {TestResetRequest} message TestResetRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TestResetRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this TestResetRequest to JSON.
         * @function toJSON
         * @memberof TestResetRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TestResetRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return TestResetRequest;
    })();
    
    $root.TestResetReply = (function() {
    
        /**
         * Properties of a TestResetReply.
         * @exports ITestResetReply
         * @interface ITestResetReply
         * @property {Result} [result] TestResetReply result
         */
    
        /**
         * Constructs a new TestResetReply.
         * @exports TestResetReply
         * @classdesc Represents a TestResetReply.
         * @constructor
         * @param {ITestResetReply=} [properties] Properties to set
         */
        function TestResetReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * TestResetReply result.
         * @member {Result}result
         * @memberof TestResetReply
         * @instance
         */
        TestResetReply.prototype.result = 0;
    
        /**
         * Creates a new TestResetReply instance using the specified properties.
         * @function create
         * @memberof TestResetReply
         * @static
         * @param {ITestResetReply=} [properties] Properties to set
         * @returns {TestResetReply} TestResetReply instance
         */
        TestResetReply.create = function create(properties) {
            return new TestResetReply(properties);
        };
    
        /**
         * Encodes the specified TestResetReply message. Does not implicitly {@link TestResetReply.verify|verify} messages.
         * @function encode
         * @memberof TestResetReply
         * @static
         * @param {ITestResetReply} message TestResetReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestResetReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified TestResetReply message, length delimited. Does not implicitly {@link TestResetReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof TestResetReply
         * @static
         * @param {ITestResetReply} message TestResetReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestResetReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a TestResetReply message from the specified reader or buffer.
         * @function decode
         * @memberof TestResetReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {TestResetReply} TestResetReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestResetReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TestResetReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a TestResetReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof TestResetReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {TestResetReply} TestResetReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestResetReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a TestResetReply message.
         * @function verify
         * @memberof TestResetReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TestResetReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a TestResetReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof TestResetReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {TestResetReply} TestResetReply
         */
        TestResetReply.fromObject = function fromObject(object) {
            if (object instanceof $root.TestResetReply)
                return object;
            var message = new $root.TestResetReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a TestResetReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof TestResetReply
         * @static
         * @param {TestResetReply} message TestResetReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TestResetReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this TestResetReply to JSON.
         * @function toJSON
         * @memberof TestResetReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TestResetReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return TestResetReply;
    })();
    
    $root.ForgetDevicePairingRequest = (function() {
    
        /**
         * Properties of a ForgetDevicePairingRequest.
         * @exports IForgetDevicePairingRequest
         * @interface IForgetDevicePairingRequest
         */
    
        /**
         * Constructs a new ForgetDevicePairingRequest.
         * @exports ForgetDevicePairingRequest
         * @classdesc Represents a ForgetDevicePairingRequest.
         * @constructor
         * @param {IForgetDevicePairingRequest=} [properties] Properties to set
         */
        function ForgetDevicePairingRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new ForgetDevicePairingRequest instance using the specified properties.
         * @function create
         * @memberof ForgetDevicePairingRequest
         * @static
         * @param {IForgetDevicePairingRequest=} [properties] Properties to set
         * @returns {ForgetDevicePairingRequest} ForgetDevicePairingRequest instance
         */
        ForgetDevicePairingRequest.create = function create(properties) {
            return new ForgetDevicePairingRequest(properties);
        };
    
        /**
         * Encodes the specified ForgetDevicePairingRequest message. Does not implicitly {@link ForgetDevicePairingRequest.verify|verify} messages.
         * @function encode
         * @memberof ForgetDevicePairingRequest
         * @static
         * @param {IForgetDevicePairingRequest} message ForgetDevicePairingRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForgetDevicePairingRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified ForgetDevicePairingRequest message, length delimited. Does not implicitly {@link ForgetDevicePairingRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ForgetDevicePairingRequest
         * @static
         * @param {IForgetDevicePairingRequest} message ForgetDevicePairingRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForgetDevicePairingRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ForgetDevicePairingRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ForgetDevicePairingRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ForgetDevicePairingRequest} ForgetDevicePairingRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForgetDevicePairingRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ForgetDevicePairingRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ForgetDevicePairingRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ForgetDevicePairingRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ForgetDevicePairingRequest} ForgetDevicePairingRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForgetDevicePairingRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ForgetDevicePairingRequest message.
         * @function verify
         * @memberof ForgetDevicePairingRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ForgetDevicePairingRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a ForgetDevicePairingRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ForgetDevicePairingRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ForgetDevicePairingRequest} ForgetDevicePairingRequest
         */
        ForgetDevicePairingRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ForgetDevicePairingRequest)
                return object;
            return new $root.ForgetDevicePairingRequest();
        };
    
        /**
         * Creates a plain object from a ForgetDevicePairingRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ForgetDevicePairingRequest
         * @static
         * @param {ForgetDevicePairingRequest} message ForgetDevicePairingRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ForgetDevicePairingRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this ForgetDevicePairingRequest to JSON.
         * @function toJSON
         * @memberof ForgetDevicePairingRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ForgetDevicePairingRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ForgetDevicePairingRequest;
    })();
    
    $root.ForgetDevicePairingReply = (function() {
    
        /**
         * Properties of a ForgetDevicePairingReply.
         * @exports IForgetDevicePairingReply
         * @interface IForgetDevicePairingReply
         * @property {Result} [result] ForgetDevicePairingReply result
         */
    
        /**
         * Constructs a new ForgetDevicePairingReply.
         * @exports ForgetDevicePairingReply
         * @classdesc Represents a ForgetDevicePairingReply.
         * @constructor
         * @param {IForgetDevicePairingReply=} [properties] Properties to set
         */
        function ForgetDevicePairingReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ForgetDevicePairingReply result.
         * @member {Result}result
         * @memberof ForgetDevicePairingReply
         * @instance
         */
        ForgetDevicePairingReply.prototype.result = 0;
    
        /**
         * Creates a new ForgetDevicePairingReply instance using the specified properties.
         * @function create
         * @memberof ForgetDevicePairingReply
         * @static
         * @param {IForgetDevicePairingReply=} [properties] Properties to set
         * @returns {ForgetDevicePairingReply} ForgetDevicePairingReply instance
         */
        ForgetDevicePairingReply.create = function create(properties) {
            return new ForgetDevicePairingReply(properties);
        };
    
        /**
         * Encodes the specified ForgetDevicePairingReply message. Does not implicitly {@link ForgetDevicePairingReply.verify|verify} messages.
         * @function encode
         * @memberof ForgetDevicePairingReply
         * @static
         * @param {IForgetDevicePairingReply} message ForgetDevicePairingReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForgetDevicePairingReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified ForgetDevicePairingReply message, length delimited. Does not implicitly {@link ForgetDevicePairingReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ForgetDevicePairingReply
         * @static
         * @param {IForgetDevicePairingReply} message ForgetDevicePairingReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForgetDevicePairingReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ForgetDevicePairingReply message from the specified reader or buffer.
         * @function decode
         * @memberof ForgetDevicePairingReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ForgetDevicePairingReply} ForgetDevicePairingReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForgetDevicePairingReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ForgetDevicePairingReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ForgetDevicePairingReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ForgetDevicePairingReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ForgetDevicePairingReply} ForgetDevicePairingReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForgetDevicePairingReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ForgetDevicePairingReply message.
         * @function verify
         * @memberof ForgetDevicePairingReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ForgetDevicePairingReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a ForgetDevicePairingReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ForgetDevicePairingReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ForgetDevicePairingReply} ForgetDevicePairingReply
         */
        ForgetDevicePairingReply.fromObject = function fromObject(object) {
            if (object instanceof $root.ForgetDevicePairingReply)
                return object;
            var message = new $root.ForgetDevicePairingReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a ForgetDevicePairingReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ForgetDevicePairingReply
         * @static
         * @param {ForgetDevicePairingReply} message ForgetDevicePairingReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ForgetDevicePairingReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this ForgetDevicePairingReply to JSON.
         * @function toJSON
         * @memberof ForgetDevicePairingReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ForgetDevicePairingReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ForgetDevicePairingReply;
    })();
    
    $root.SetSimulatorRequest = (function() {
    
        /**
         * Properties of a SetSimulatorRequest.
         * @exports ISetSimulatorRequest
         * @interface ISetSimulatorRequest
         * @property {boolean} simulatorOn SetSimulatorRequest simulatorOn
         */
    
        /**
         * Constructs a new SetSimulatorRequest.
         * @exports SetSimulatorRequest
         * @classdesc Represents a SetSimulatorRequest.
         * @constructor
         * @param {ISetSimulatorRequest=} [properties] Properties to set
         */
        function SetSimulatorRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * SetSimulatorRequest simulatorOn.
         * @member {boolean}simulatorOn
         * @memberof SetSimulatorRequest
         * @instance
         */
        SetSimulatorRequest.prototype.simulatorOn = false;
    
        /**
         * Creates a new SetSimulatorRequest instance using the specified properties.
         * @function create
         * @memberof SetSimulatorRequest
         * @static
         * @param {ISetSimulatorRequest=} [properties] Properties to set
         * @returns {SetSimulatorRequest} SetSimulatorRequest instance
         */
        SetSimulatorRequest.create = function create(properties) {
            return new SetSimulatorRequest(properties);
        };
    
        /**
         * Encodes the specified SetSimulatorRequest message. Does not implicitly {@link SetSimulatorRequest.verify|verify} messages.
         * @function encode
         * @memberof SetSimulatorRequest
         * @static
         * @param {ISetSimulatorRequest} message SetSimulatorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSimulatorRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.simulatorOn);
            return writer;
        };
    
        /**
         * Encodes the specified SetSimulatorRequest message, length delimited. Does not implicitly {@link SetSimulatorRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SetSimulatorRequest
         * @static
         * @param {ISetSimulatorRequest} message SetSimulatorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSimulatorRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SetSimulatorRequest message from the specified reader or buffer.
         * @function decode
         * @memberof SetSimulatorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SetSimulatorRequest} SetSimulatorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSimulatorRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetSimulatorRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.simulatorOn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("simulatorOn"))
                throw $util.ProtocolError("missing required 'simulatorOn'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SetSimulatorRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SetSimulatorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SetSimulatorRequest} SetSimulatorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSimulatorRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SetSimulatorRequest message.
         * @function verify
         * @memberof SetSimulatorRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetSimulatorRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.simulatorOn !== "boolean")
                return "simulatorOn: boolean expected";
            return null;
        };
    
        /**
         * Creates a SetSimulatorRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SetSimulatorRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SetSimulatorRequest} SetSimulatorRequest
         */
        SetSimulatorRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.SetSimulatorRequest)
                return object;
            var message = new $root.SetSimulatorRequest();
            if (object.simulatorOn != null)
                message.simulatorOn = Boolean(object.simulatorOn);
            return message;
        };
    
        /**
         * Creates a plain object from a SetSimulatorRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SetSimulatorRequest
         * @static
         * @param {SetSimulatorRequest} message SetSimulatorRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetSimulatorRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.simulatorOn = false;
            if (message.simulatorOn != null && message.hasOwnProperty("simulatorOn"))
                object.simulatorOn = message.simulatorOn;
            return object;
        };
    
        /**
         * Converts this SetSimulatorRequest to JSON.
         * @function toJSON
         * @memberof SetSimulatorRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetSimulatorRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SetSimulatorRequest;
    })();
    
    $root.SetSimulatorReply = (function() {
    
        /**
         * Properties of a SetSimulatorReply.
         * @exports ISetSimulatorReply
         * @interface ISetSimulatorReply
         * @property {Result} [result] SetSimulatorReply result
         */
    
        /**
         * Constructs a new SetSimulatorReply.
         * @exports SetSimulatorReply
         * @classdesc Represents a SetSimulatorReply.
         * @constructor
         * @param {ISetSimulatorReply=} [properties] Properties to set
         */
        function SetSimulatorReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * SetSimulatorReply result.
         * @member {Result}result
         * @memberof SetSimulatorReply
         * @instance
         */
        SetSimulatorReply.prototype.result = 0;
    
        /**
         * Creates a new SetSimulatorReply instance using the specified properties.
         * @function create
         * @memberof SetSimulatorReply
         * @static
         * @param {ISetSimulatorReply=} [properties] Properties to set
         * @returns {SetSimulatorReply} SetSimulatorReply instance
         */
        SetSimulatorReply.create = function create(properties) {
            return new SetSimulatorReply(properties);
        };
    
        /**
         * Encodes the specified SetSimulatorReply message. Does not implicitly {@link SetSimulatorReply.verify|verify} messages.
         * @function encode
         * @memberof SetSimulatorReply
         * @static
         * @param {ISetSimulatorReply} message SetSimulatorReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSimulatorReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified SetSimulatorReply message, length delimited. Does not implicitly {@link SetSimulatorReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SetSimulatorReply
         * @static
         * @param {ISetSimulatorReply} message SetSimulatorReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetSimulatorReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SetSimulatorReply message from the specified reader or buffer.
         * @function decode
         * @memberof SetSimulatorReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SetSimulatorReply} SetSimulatorReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSimulatorReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetSimulatorReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a SetSimulatorReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SetSimulatorReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SetSimulatorReply} SetSimulatorReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetSimulatorReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SetSimulatorReply message.
         * @function verify
         * @memberof SetSimulatorReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetSimulatorReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                    break;
                }
            return null;
        };
    
        /**
         * Creates a SetSimulatorReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SetSimulatorReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SetSimulatorReply} SetSimulatorReply
         */
        SetSimulatorReply.fromObject = function fromObject(object) {
            if (object instanceof $root.SetSimulatorReply)
                return object;
            var message = new $root.SetSimulatorReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a SetSimulatorReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SetSimulatorReply
         * @static
         * @param {SetSimulatorReply} message SetSimulatorReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetSimulatorReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this SetSimulatorReply to JSON.
         * @function toJSON
         * @memberof SetSimulatorReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetSimulatorReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SetSimulatorReply;
    })();
    
    $root.GetSimulatorRequest = (function() {
    
        /**
         * Properties of a GetSimulatorRequest.
         * @exports IGetSimulatorRequest
         * @interface IGetSimulatorRequest
         */
    
        /**
         * Constructs a new GetSimulatorRequest.
         * @exports GetSimulatorRequest
         * @classdesc Represents a GetSimulatorRequest.
         * @constructor
         * @param {IGetSimulatorRequest=} [properties] Properties to set
         */
        function GetSimulatorRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new GetSimulatorRequest instance using the specified properties.
         * @function create
         * @memberof GetSimulatorRequest
         * @static
         * @param {IGetSimulatorRequest=} [properties] Properties to set
         * @returns {GetSimulatorRequest} GetSimulatorRequest instance
         */
        GetSimulatorRequest.create = function create(properties) {
            return new GetSimulatorRequest(properties);
        };
    
        /**
         * Encodes the specified GetSimulatorRequest message. Does not implicitly {@link GetSimulatorRequest.verify|verify} messages.
         * @function encode
         * @memberof GetSimulatorRequest
         * @static
         * @param {IGetSimulatorRequest} message GetSimulatorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSimulatorRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified GetSimulatorRequest message, length delimited. Does not implicitly {@link GetSimulatorRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetSimulatorRequest
         * @static
         * @param {IGetSimulatorRequest} message GetSimulatorRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSimulatorRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a GetSimulatorRequest message from the specified reader or buffer.
         * @function decode
         * @memberof GetSimulatorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetSimulatorRequest} GetSimulatorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSimulatorRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetSimulatorRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a GetSimulatorRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetSimulatorRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetSimulatorRequest} GetSimulatorRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSimulatorRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a GetSimulatorRequest message.
         * @function verify
         * @memberof GetSimulatorRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSimulatorRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a GetSimulatorRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetSimulatorRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetSimulatorRequest} GetSimulatorRequest
         */
        GetSimulatorRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.GetSimulatorRequest)
                return object;
            return new $root.GetSimulatorRequest();
        };
    
        /**
         * Creates a plain object from a GetSimulatorRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetSimulatorRequest
         * @static
         * @param {GetSimulatorRequest} message GetSimulatorRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSimulatorRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this GetSimulatorRequest to JSON.
         * @function toJSON
         * @memberof GetSimulatorRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSimulatorRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return GetSimulatorRequest;
    })();
    
    $root.GetSimulatorReply = (function() {
    
        /**
         * Properties of a GetSimulatorReply.
         * @exports IGetSimulatorReply
         * @interface IGetSimulatorReply
         * @property {boolean} simulatorOn GetSimulatorReply simulatorOn
         */
    
        /**
         * Constructs a new GetSimulatorReply.
         * @exports GetSimulatorReply
         * @classdesc Represents a GetSimulatorReply.
         * @constructor
         * @param {IGetSimulatorReply=} [properties] Properties to set
         */
        function GetSimulatorReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * GetSimulatorReply simulatorOn.
         * @member {boolean}simulatorOn
         * @memberof GetSimulatorReply
         * @instance
         */
        GetSimulatorReply.prototype.simulatorOn = false;
    
        /**
         * Creates a new GetSimulatorReply instance using the specified properties.
         * @function create
         * @memberof GetSimulatorReply
         * @static
         * @param {IGetSimulatorReply=} [properties] Properties to set
         * @returns {GetSimulatorReply} GetSimulatorReply instance
         */
        GetSimulatorReply.create = function create(properties) {
            return new GetSimulatorReply(properties);
        };
    
        /**
         * Encodes the specified GetSimulatorReply message. Does not implicitly {@link GetSimulatorReply.verify|verify} messages.
         * @function encode
         * @memberof GetSimulatorReply
         * @static
         * @param {IGetSimulatorReply} message GetSimulatorReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSimulatorReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.simulatorOn);
            return writer;
        };
    
        /**
         * Encodes the specified GetSimulatorReply message, length delimited. Does not implicitly {@link GetSimulatorReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetSimulatorReply
         * @static
         * @param {IGetSimulatorReply} message GetSimulatorReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetSimulatorReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a GetSimulatorReply message from the specified reader or buffer.
         * @function decode
         * @memberof GetSimulatorReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetSimulatorReply} GetSimulatorReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSimulatorReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetSimulatorReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.simulatorOn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("simulatorOn"))
                throw $util.ProtocolError("missing required 'simulatorOn'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a GetSimulatorReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetSimulatorReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetSimulatorReply} GetSimulatorReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetSimulatorReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a GetSimulatorReply message.
         * @function verify
         * @memberof GetSimulatorReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetSimulatorReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.simulatorOn !== "boolean")
                return "simulatorOn: boolean expected";
            return null;
        };
    
        /**
         * Creates a GetSimulatorReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetSimulatorReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetSimulatorReply} GetSimulatorReply
         */
        GetSimulatorReply.fromObject = function fromObject(object) {
            if (object instanceof $root.GetSimulatorReply)
                return object;
            var message = new $root.GetSimulatorReply();
            if (object.simulatorOn != null)
                message.simulatorOn = Boolean(object.simulatorOn);
            return message;
        };
    
        /**
         * Creates a plain object from a GetSimulatorReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetSimulatorReply
         * @static
         * @param {GetSimulatorReply} message GetSimulatorReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetSimulatorReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.simulatorOn = false;
            if (message.simulatorOn != null && message.hasOwnProperty("simulatorOn"))
                object.simulatorOn = message.simulatorOn;
            return object;
        };
    
        /**
         * Converts this GetSimulatorReply to JSON.
         * @function toJSON
         * @memberof GetSimulatorReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetSimulatorReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return GetSimulatorReply;
    })();
    
    $root.SetHardwareCoeffsRequest = (function() {
    
        /**
         * Properties of a SetHardwareCoeffsRequest.
         * @exports ISetHardwareCoeffsRequest
         * @interface ISetHardwareCoeffsRequest
         * @property {number} tempAdcBias SetHardwareCoeffsRequest tempAdcBias
         * @property {number} tempAdcScale SetHardwareCoeffsRequest tempAdcScale
         * @property {number} tempRef SetHardwareCoeffsRequest tempRef
         * @property {number} tempCoeffA SetHardwareCoeffsRequest tempCoeffA
         * @property {number} tempCoeffB SetHardwareCoeffsRequest tempCoeffB
         * @property {number} tempCoeffC SetHardwareCoeffsRequest tempCoeffC
         */
    
        /**
         * Constructs a new SetHardwareCoeffsRequest.
         * @exports SetHardwareCoeffsRequest
         * @classdesc Represents a SetHardwareCoeffsRequest.
         * @constructor
         * @param {ISetHardwareCoeffsRequest=} [properties] Properties to set
         */
        function SetHardwareCoeffsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * SetHardwareCoeffsRequest tempAdcBias.
         * @member {number}tempAdcBias
         * @memberof SetHardwareCoeffsRequest
         * @instance
         */
        SetHardwareCoeffsRequest.prototype.tempAdcBias = 0;
    
        /**
         * SetHardwareCoeffsRequest tempAdcScale.
         * @member {number}tempAdcScale
         * @memberof SetHardwareCoeffsRequest
         * @instance
         */
        SetHardwareCoeffsRequest.prototype.tempAdcScale = 0;
    
        /**
         * SetHardwareCoeffsRequest tempRef.
         * @member {number}tempRef
         * @memberof SetHardwareCoeffsRequest
         * @instance
         */
        SetHardwareCoeffsRequest.prototype.tempRef = 0;
    
        /**
         * SetHardwareCoeffsRequest tempCoeffA.
         * @member {number}tempCoeffA
         * @memberof SetHardwareCoeffsRequest
         * @instance
         */
        SetHardwareCoeffsRequest.prototype.tempCoeffA = 0;
    
        /**
         * SetHardwareCoeffsRequest tempCoeffB.
         * @member {number}tempCoeffB
         * @memberof SetHardwareCoeffsRequest
         * @instance
         */
        SetHardwareCoeffsRequest.prototype.tempCoeffB = 0;
    
        /**
         * SetHardwareCoeffsRequest tempCoeffC.
         * @member {number}tempCoeffC
         * @memberof SetHardwareCoeffsRequest
         * @instance
         */
        SetHardwareCoeffsRequest.prototype.tempCoeffC = 0;
    
        /**
         * Creates a new SetHardwareCoeffsRequest instance using the specified properties.
         * @function create
         * @memberof SetHardwareCoeffsRequest
         * @static
         * @param {ISetHardwareCoeffsRequest=} [properties] Properties to set
         * @returns {SetHardwareCoeffsRequest} SetHardwareCoeffsRequest instance
         */
        SetHardwareCoeffsRequest.create = function create(properties) {
            return new SetHardwareCoeffsRequest(properties);
        };
    
        /**
         * Encodes the specified SetHardwareCoeffsRequest message. Does not implicitly {@link SetHardwareCoeffsRequest.verify|verify} messages.
         * @function encode
         * @memberof SetHardwareCoeffsRequest
         * @static
         * @param {ISetHardwareCoeffsRequest} message SetHardwareCoeffsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetHardwareCoeffsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.tempAdcBias);
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.tempAdcScale);
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.tempRef);
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.tempCoeffA);
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.tempCoeffB);
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.tempCoeffC);
            return writer;
        };
    
        /**
         * Encodes the specified SetHardwareCoeffsRequest message, length delimited. Does not implicitly {@link SetHardwareCoeffsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SetHardwareCoeffsRequest
         * @static
         * @param {ISetHardwareCoeffsRequest} message SetHardwareCoeffsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetHardwareCoeffsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SetHardwareCoeffsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof SetHardwareCoeffsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SetHardwareCoeffsRequest} SetHardwareCoeffsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetHardwareCoeffsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetHardwareCoeffsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempAdcBias = reader.float();
                    break;
                case 2:
                    message.tempAdcScale = reader.float();
                    break;
                case 3:
                    message.tempRef = reader.float();
                    break;
                case 4:
                    message.tempCoeffA = reader.float();
                    break;
                case 5:
                    message.tempCoeffB = reader.float();
                    break;
                case 6:
                    message.tempCoeffC = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("tempAdcBias"))
                throw $util.ProtocolError("missing required 'tempAdcBias'", { instance: message });
            if (!message.hasOwnProperty("tempAdcScale"))
                throw $util.ProtocolError("missing required 'tempAdcScale'", { instance: message });
            if (!message.hasOwnProperty("tempRef"))
                throw $util.ProtocolError("missing required 'tempRef'", { instance: message });
            if (!message.hasOwnProperty("tempCoeffA"))
                throw $util.ProtocolError("missing required 'tempCoeffA'", { instance: message });
            if (!message.hasOwnProperty("tempCoeffB"))
                throw $util.ProtocolError("missing required 'tempCoeffB'", { instance: message });
            if (!message.hasOwnProperty("tempCoeffC"))
                throw $util.ProtocolError("missing required 'tempCoeffC'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SetHardwareCoeffsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SetHardwareCoeffsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SetHardwareCoeffsRequest} SetHardwareCoeffsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetHardwareCoeffsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SetHardwareCoeffsRequest message.
         * @function verify
         * @memberof SetHardwareCoeffsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetHardwareCoeffsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.tempAdcBias !== "number")
                return "tempAdcBias: number expected";
            if (typeof message.tempAdcScale !== "number")
                return "tempAdcScale: number expected";
            if (typeof message.tempRef !== "number")
                return "tempRef: number expected";
            if (typeof message.tempCoeffA !== "number")
                return "tempCoeffA: number expected";
            if (typeof message.tempCoeffB !== "number")
                return "tempCoeffB: number expected";
            if (typeof message.tempCoeffC !== "number")
                return "tempCoeffC: number expected";
            return null;
        };
    
        /**
         * Creates a SetHardwareCoeffsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SetHardwareCoeffsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SetHardwareCoeffsRequest} SetHardwareCoeffsRequest
         */
        SetHardwareCoeffsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.SetHardwareCoeffsRequest)
                return object;
            var message = new $root.SetHardwareCoeffsRequest();
            if (object.tempAdcBias != null)
                message.tempAdcBias = Number(object.tempAdcBias);
            if (object.tempAdcScale != null)
                message.tempAdcScale = Number(object.tempAdcScale);
            if (object.tempRef != null)
                message.tempRef = Number(object.tempRef);
            if (object.tempCoeffA != null)
                message.tempCoeffA = Number(object.tempCoeffA);
            if (object.tempCoeffB != null)
                message.tempCoeffB = Number(object.tempCoeffB);
            if (object.tempCoeffC != null)
                message.tempCoeffC = Number(object.tempCoeffC);
            return message;
        };
    
        /**
         * Creates a plain object from a SetHardwareCoeffsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SetHardwareCoeffsRequest
         * @static
         * @param {SetHardwareCoeffsRequest} message SetHardwareCoeffsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetHardwareCoeffsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempAdcBias = 0;
                object.tempAdcScale = 0;
                object.tempRef = 0;
                object.tempCoeffA = 0;
                object.tempCoeffB = 0;
                object.tempCoeffC = 0;
            }
            if (message.tempAdcBias != null && message.hasOwnProperty("tempAdcBias"))
                object.tempAdcBias = options.json && !isFinite(message.tempAdcBias) ? String(message.tempAdcBias) : message.tempAdcBias;
            if (message.tempAdcScale != null && message.hasOwnProperty("tempAdcScale"))
                object.tempAdcScale = options.json && !isFinite(message.tempAdcScale) ? String(message.tempAdcScale) : message.tempAdcScale;
            if (message.tempRef != null && message.hasOwnProperty("tempRef"))
                object.tempRef = options.json && !isFinite(message.tempRef) ? String(message.tempRef) : message.tempRef;
            if (message.tempCoeffA != null && message.hasOwnProperty("tempCoeffA"))
                object.tempCoeffA = options.json && !isFinite(message.tempCoeffA) ? String(message.tempCoeffA) : message.tempCoeffA;
            if (message.tempCoeffB != null && message.hasOwnProperty("tempCoeffB"))
                object.tempCoeffB = options.json && !isFinite(message.tempCoeffB) ? String(message.tempCoeffB) : message.tempCoeffB;
            if (message.tempCoeffC != null && message.hasOwnProperty("tempCoeffC"))
                object.tempCoeffC = options.json && !isFinite(message.tempCoeffC) ? String(message.tempCoeffC) : message.tempCoeffC;
            return object;
        };
    
        /**
         * Converts this SetHardwareCoeffsRequest to JSON.
         * @function toJSON
         * @memberof SetHardwareCoeffsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetHardwareCoeffsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SetHardwareCoeffsRequest;
    })();
    
    $root.SetHardwareCoeffsReply = (function() {
    
        /**
         * Properties of a SetHardwareCoeffsReply.
         * @exports ISetHardwareCoeffsReply
         * @interface ISetHardwareCoeffsReply
         * @property {Result} result SetHardwareCoeffsReply result
         */
    
        /**
         * Constructs a new SetHardwareCoeffsReply.
         * @exports SetHardwareCoeffsReply
         * @classdesc Represents a SetHardwareCoeffsReply.
         * @constructor
         * @param {ISetHardwareCoeffsReply=} [properties] Properties to set
         */
        function SetHardwareCoeffsReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * SetHardwareCoeffsReply result.
         * @member {Result}result
         * @memberof SetHardwareCoeffsReply
         * @instance
         */
        SetHardwareCoeffsReply.prototype.result = 0;
    
        /**
         * Creates a new SetHardwareCoeffsReply instance using the specified properties.
         * @function create
         * @memberof SetHardwareCoeffsReply
         * @static
         * @param {ISetHardwareCoeffsReply=} [properties] Properties to set
         * @returns {SetHardwareCoeffsReply} SetHardwareCoeffsReply instance
         */
        SetHardwareCoeffsReply.create = function create(properties) {
            return new SetHardwareCoeffsReply(properties);
        };
    
        /**
         * Encodes the specified SetHardwareCoeffsReply message. Does not implicitly {@link SetHardwareCoeffsReply.verify|verify} messages.
         * @function encode
         * @memberof SetHardwareCoeffsReply
         * @static
         * @param {ISetHardwareCoeffsReply} message SetHardwareCoeffsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetHardwareCoeffsReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified SetHardwareCoeffsReply message, length delimited. Does not implicitly {@link SetHardwareCoeffsReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SetHardwareCoeffsReply
         * @static
         * @param {ISetHardwareCoeffsReply} message SetHardwareCoeffsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetHardwareCoeffsReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SetHardwareCoeffsReply message from the specified reader or buffer.
         * @function decode
         * @memberof SetHardwareCoeffsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SetHardwareCoeffsReply} SetHardwareCoeffsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetHardwareCoeffsReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetHardwareCoeffsReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SetHardwareCoeffsReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SetHardwareCoeffsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SetHardwareCoeffsReply} SetHardwareCoeffsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetHardwareCoeffsReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SetHardwareCoeffsReply message.
         * @function verify
         * @memberof SetHardwareCoeffsReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetHardwareCoeffsReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.result) {
            default:
                return "result: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                break;
            }
            return null;
        };
    
        /**
         * Creates a SetHardwareCoeffsReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SetHardwareCoeffsReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SetHardwareCoeffsReply} SetHardwareCoeffsReply
         */
        SetHardwareCoeffsReply.fromObject = function fromObject(object) {
            if (object instanceof $root.SetHardwareCoeffsReply)
                return object;
            var message = new $root.SetHardwareCoeffsReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a SetHardwareCoeffsReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SetHardwareCoeffsReply
         * @static
         * @param {SetHardwareCoeffsReply} message SetHardwareCoeffsReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetHardwareCoeffsReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this SetHardwareCoeffsReply to JSON.
         * @function toJSON
         * @memberof SetHardwareCoeffsReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetHardwareCoeffsReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SetHardwareCoeffsReply;
    })();
    
    $root.GetHardwareCoeffsRequest = (function() {
    
        /**
         * Properties of a GetHardwareCoeffsRequest.
         * @exports IGetHardwareCoeffsRequest
         * @interface IGetHardwareCoeffsRequest
         */
    
        /**
         * Constructs a new GetHardwareCoeffsRequest.
         * @exports GetHardwareCoeffsRequest
         * @classdesc Represents a GetHardwareCoeffsRequest.
         * @constructor
         * @param {IGetHardwareCoeffsRequest=} [properties] Properties to set
         */
        function GetHardwareCoeffsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new GetHardwareCoeffsRequest instance using the specified properties.
         * @function create
         * @memberof GetHardwareCoeffsRequest
         * @static
         * @param {IGetHardwareCoeffsRequest=} [properties] Properties to set
         * @returns {GetHardwareCoeffsRequest} GetHardwareCoeffsRequest instance
         */
        GetHardwareCoeffsRequest.create = function create(properties) {
            return new GetHardwareCoeffsRequest(properties);
        };
    
        /**
         * Encodes the specified GetHardwareCoeffsRequest message. Does not implicitly {@link GetHardwareCoeffsRequest.verify|verify} messages.
         * @function encode
         * @memberof GetHardwareCoeffsRequest
         * @static
         * @param {IGetHardwareCoeffsRequest} message GetHardwareCoeffsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetHardwareCoeffsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified GetHardwareCoeffsRequest message, length delimited. Does not implicitly {@link GetHardwareCoeffsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetHardwareCoeffsRequest
         * @static
         * @param {IGetHardwareCoeffsRequest} message GetHardwareCoeffsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetHardwareCoeffsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a GetHardwareCoeffsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof GetHardwareCoeffsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetHardwareCoeffsRequest} GetHardwareCoeffsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetHardwareCoeffsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetHardwareCoeffsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a GetHardwareCoeffsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetHardwareCoeffsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetHardwareCoeffsRequest} GetHardwareCoeffsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetHardwareCoeffsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a GetHardwareCoeffsRequest message.
         * @function verify
         * @memberof GetHardwareCoeffsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetHardwareCoeffsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a GetHardwareCoeffsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetHardwareCoeffsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetHardwareCoeffsRequest} GetHardwareCoeffsRequest
         */
        GetHardwareCoeffsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.GetHardwareCoeffsRequest)
                return object;
            return new $root.GetHardwareCoeffsRequest();
        };
    
        /**
         * Creates a plain object from a GetHardwareCoeffsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetHardwareCoeffsRequest
         * @static
         * @param {GetHardwareCoeffsRequest} message GetHardwareCoeffsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetHardwareCoeffsRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this GetHardwareCoeffsRequest to JSON.
         * @function toJSON
         * @memberof GetHardwareCoeffsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetHardwareCoeffsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return GetHardwareCoeffsRequest;
    })();
    
    $root.GetHardwareCoeffsReply = (function() {
    
        /**
         * Properties of a GetHardwareCoeffsReply.
         * @exports IGetHardwareCoeffsReply
         * @interface IGetHardwareCoeffsReply
         * @property {number} tempAdcBias GetHardwareCoeffsReply tempAdcBias
         * @property {number} tempAdcScale GetHardwareCoeffsReply tempAdcScale
         * @property {number} tempRef GetHardwareCoeffsReply tempRef
         * @property {number} tempCoeffA GetHardwareCoeffsReply tempCoeffA
         * @property {number} tempCoeffB GetHardwareCoeffsReply tempCoeffB
         * @property {number} tempCoeffC GetHardwareCoeffsReply tempCoeffC
         * @property {Result} result GetHardwareCoeffsReply result
         */
    
        /**
         * Constructs a new GetHardwareCoeffsReply.
         * @exports GetHardwareCoeffsReply
         * @classdesc Represents a GetHardwareCoeffsReply.
         * @constructor
         * @param {IGetHardwareCoeffsReply=} [properties] Properties to set
         */
        function GetHardwareCoeffsReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * GetHardwareCoeffsReply tempAdcBias.
         * @member {number}tempAdcBias
         * @memberof GetHardwareCoeffsReply
         * @instance
         */
        GetHardwareCoeffsReply.prototype.tempAdcBias = 0;
    
        /**
         * GetHardwareCoeffsReply tempAdcScale.
         * @member {number}tempAdcScale
         * @memberof GetHardwareCoeffsReply
         * @instance
         */
        GetHardwareCoeffsReply.prototype.tempAdcScale = 0;
    
        /**
         * GetHardwareCoeffsReply tempRef.
         * @member {number}tempRef
         * @memberof GetHardwareCoeffsReply
         * @instance
         */
        GetHardwareCoeffsReply.prototype.tempRef = 0;
    
        /**
         * GetHardwareCoeffsReply tempCoeffA.
         * @member {number}tempCoeffA
         * @memberof GetHardwareCoeffsReply
         * @instance
         */
        GetHardwareCoeffsReply.prototype.tempCoeffA = 0;
    
        /**
         * GetHardwareCoeffsReply tempCoeffB.
         * @member {number}tempCoeffB
         * @memberof GetHardwareCoeffsReply
         * @instance
         */
        GetHardwareCoeffsReply.prototype.tempCoeffB = 0;
    
        /**
         * GetHardwareCoeffsReply tempCoeffC.
         * @member {number}tempCoeffC
         * @memberof GetHardwareCoeffsReply
         * @instance
         */
        GetHardwareCoeffsReply.prototype.tempCoeffC = 0;
    
        /**
         * GetHardwareCoeffsReply result.
         * @member {Result}result
         * @memberof GetHardwareCoeffsReply
         * @instance
         */
        GetHardwareCoeffsReply.prototype.result = 0;
    
        /**
         * Creates a new GetHardwareCoeffsReply instance using the specified properties.
         * @function create
         * @memberof GetHardwareCoeffsReply
         * @static
         * @param {IGetHardwareCoeffsReply=} [properties] Properties to set
         * @returns {GetHardwareCoeffsReply} GetHardwareCoeffsReply instance
         */
        GetHardwareCoeffsReply.create = function create(properties) {
            return new GetHardwareCoeffsReply(properties);
        };
    
        /**
         * Encodes the specified GetHardwareCoeffsReply message. Does not implicitly {@link GetHardwareCoeffsReply.verify|verify} messages.
         * @function encode
         * @memberof GetHardwareCoeffsReply
         * @static
         * @param {IGetHardwareCoeffsReply} message GetHardwareCoeffsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetHardwareCoeffsReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.tempAdcBias);
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.tempAdcScale);
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.tempRef);
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.tempCoeffA);
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.tempCoeffB);
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.tempCoeffC);
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified GetHardwareCoeffsReply message, length delimited. Does not implicitly {@link GetHardwareCoeffsReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetHardwareCoeffsReply
         * @static
         * @param {IGetHardwareCoeffsReply} message GetHardwareCoeffsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetHardwareCoeffsReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a GetHardwareCoeffsReply message from the specified reader or buffer.
         * @function decode
         * @memberof GetHardwareCoeffsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetHardwareCoeffsReply} GetHardwareCoeffsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetHardwareCoeffsReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetHardwareCoeffsReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tempAdcBias = reader.float();
                    break;
                case 2:
                    message.tempAdcScale = reader.float();
                    break;
                case 3:
                    message.tempRef = reader.float();
                    break;
                case 4:
                    message.tempCoeffA = reader.float();
                    break;
                case 5:
                    message.tempCoeffB = reader.float();
                    break;
                case 6:
                    message.tempCoeffC = reader.float();
                    break;
                case 7:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("tempAdcBias"))
                throw $util.ProtocolError("missing required 'tempAdcBias'", { instance: message });
            if (!message.hasOwnProperty("tempAdcScale"))
                throw $util.ProtocolError("missing required 'tempAdcScale'", { instance: message });
            if (!message.hasOwnProperty("tempRef"))
                throw $util.ProtocolError("missing required 'tempRef'", { instance: message });
            if (!message.hasOwnProperty("tempCoeffA"))
                throw $util.ProtocolError("missing required 'tempCoeffA'", { instance: message });
            if (!message.hasOwnProperty("tempCoeffB"))
                throw $util.ProtocolError("missing required 'tempCoeffB'", { instance: message });
            if (!message.hasOwnProperty("tempCoeffC"))
                throw $util.ProtocolError("missing required 'tempCoeffC'", { instance: message });
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a GetHardwareCoeffsReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetHardwareCoeffsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetHardwareCoeffsReply} GetHardwareCoeffsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetHardwareCoeffsReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a GetHardwareCoeffsReply message.
         * @function verify
         * @memberof GetHardwareCoeffsReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetHardwareCoeffsReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.tempAdcBias !== "number")
                return "tempAdcBias: number expected";
            if (typeof message.tempAdcScale !== "number")
                return "tempAdcScale: number expected";
            if (typeof message.tempRef !== "number")
                return "tempRef: number expected";
            if (typeof message.tempCoeffA !== "number")
                return "tempCoeffA: number expected";
            if (typeof message.tempCoeffB !== "number")
                return "tempCoeffB: number expected";
            if (typeof message.tempCoeffC !== "number")
                return "tempCoeffC: number expected";
            switch (message.result) {
            default:
                return "result: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                break;
            }
            return null;
        };
    
        /**
         * Creates a GetHardwareCoeffsReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetHardwareCoeffsReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetHardwareCoeffsReply} GetHardwareCoeffsReply
         */
        GetHardwareCoeffsReply.fromObject = function fromObject(object) {
            if (object instanceof $root.GetHardwareCoeffsReply)
                return object;
            var message = new $root.GetHardwareCoeffsReply();
            if (object.tempAdcBias != null)
                message.tempAdcBias = Number(object.tempAdcBias);
            if (object.tempAdcScale != null)
                message.tempAdcScale = Number(object.tempAdcScale);
            if (object.tempRef != null)
                message.tempRef = Number(object.tempRef);
            if (object.tempCoeffA != null)
                message.tempCoeffA = Number(object.tempCoeffA);
            if (object.tempCoeffB != null)
                message.tempCoeffB = Number(object.tempCoeffB);
            if (object.tempCoeffC != null)
                message.tempCoeffC = Number(object.tempCoeffC);
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a GetHardwareCoeffsReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetHardwareCoeffsReply
         * @static
         * @param {GetHardwareCoeffsReply} message GetHardwareCoeffsReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetHardwareCoeffsReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tempAdcBias = 0;
                object.tempAdcScale = 0;
                object.tempRef = 0;
                object.tempCoeffA = 0;
                object.tempCoeffB = 0;
                object.tempCoeffC = 0;
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            }
            if (message.tempAdcBias != null && message.hasOwnProperty("tempAdcBias"))
                object.tempAdcBias = options.json && !isFinite(message.tempAdcBias) ? String(message.tempAdcBias) : message.tempAdcBias;
            if (message.tempAdcScale != null && message.hasOwnProperty("tempAdcScale"))
                object.tempAdcScale = options.json && !isFinite(message.tempAdcScale) ? String(message.tempAdcScale) : message.tempAdcScale;
            if (message.tempRef != null && message.hasOwnProperty("tempRef"))
                object.tempRef = options.json && !isFinite(message.tempRef) ? String(message.tempRef) : message.tempRef;
            if (message.tempCoeffA != null && message.hasOwnProperty("tempCoeffA"))
                object.tempCoeffA = options.json && !isFinite(message.tempCoeffA) ? String(message.tempCoeffA) : message.tempCoeffA;
            if (message.tempCoeffB != null && message.hasOwnProperty("tempCoeffB"))
                object.tempCoeffB = options.json && !isFinite(message.tempCoeffB) ? String(message.tempCoeffB) : message.tempCoeffB;
            if (message.tempCoeffC != null && message.hasOwnProperty("tempCoeffC"))
                object.tempCoeffC = options.json && !isFinite(message.tempCoeffC) ? String(message.tempCoeffC) : message.tempCoeffC;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this GetHardwareCoeffsReply to JSON.
         * @function toJSON
         * @memberof GetHardwareCoeffsReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetHardwareCoeffsReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return GetHardwareCoeffsReply;
    })();
    
    /**
     * UsageMetric enum.
     * @exports UsageMetric
     * @enum {string}
     * @property {number} MOTOR_RUNNING_MINS_LT=0 MOTOR_RUNNING_MINS_LT value
     * @property {number} TOTAL_REVOLUTIONS=1 TOTAL_REVOLUTIONS value
     * @property {number} MOTOR_RUNNING_MINS_LT_30C=2 MOTOR_RUNNING_MINS_LT_30C value
     * @property {number} MOTOR_RUNNING_MINS_LT_35C=3 MOTOR_RUNNING_MINS_LT_35C value
     * @property {number} MOTOR_RUNNING_MINS_LT_40C=4 MOTOR_RUNNING_MINS_LT_40C value
     * @property {number} MOTOR_RUNNING_MINS_LT_45C=5 MOTOR_RUNNING_MINS_LT_45C value
     * @property {number} MOTOR_RUNNING_MINS_LT_50C=6 MOTOR_RUNNING_MINS_LT_50C value
     * @property {number} MOTOR_RUNNING_MINS_LT_55C=7 MOTOR_RUNNING_MINS_LT_55C value
     * @property {number} MOTOR_RUNNING_MINS_LT_60C=8 MOTOR_RUNNING_MINS_LT_60C value
     * @property {number} MOTOR_RUNNING_MINS_LT_65C=9 MOTOR_RUNNING_MINS_LT_65C value
     * @property {number} MOTOR_RUNNING_MINS_LT_70C=10 MOTOR_RUNNING_MINS_LT_70C value
     * @property {number} MOTOR_RUNNING_MINS_LT_75C=11 MOTOR_RUNNING_MINS_LT_75C value
     * @property {number} MOTOR_RUNNING_MINS_LT_80C=12 MOTOR_RUNNING_MINS_LT_80C value
     * @property {number} MOTOR_RUNNING_MINS_LT_85C=13 MOTOR_RUNNING_MINS_LT_85C value
     * @property {number} MOTOR_RUNNING_MINS_LT_90C=14 MOTOR_RUNNING_MINS_LT_90C value
     * @property {number} MOTOR_RUNNING_MINS_LT_95C=15 MOTOR_RUNNING_MINS_LT_95C value
     * @property {number} MOTOR_RUNNING_MINS_GT_95C=16 MOTOR_RUNNING_MINS_GT_95C value
     * @property {number} MOTOR_RPM_MEAN=17 MOTOR_RPM_MEAN value
     * @property {number} MOTOR_RPM_VARIANCE=18 MOTOR_RPM_VARIANCE value
     * @property {number} MOTOR_CURRENT_MEAN=19 MOTOR_CURRENT_MEAN value
     * @property {number} MOTOR_CURRENT_VARIANCE=20 MOTOR_CURRENT_VARIANCE value
     * @property {number} HEATER_MEAN=21 HEATER_MEAN value
     * @property {number} HEATER_VARIANCE=22 HEATER_VARIANCE value
     * @property {number} PRESSURE_MEAN=23 PRESSURE_MEAN value
     * @property {number} PRESSURE_VARIANCE=24 PRESSURE_VARIANCE value
     * @property {number} BATH_TEMP_MEAN=25 BATH_TEMP_MEAN value
     * @property {number} BATH_TEMP_VARIANCE=26 BATH_TEMP_VARIANCE value
     * @property {number} NUM_BUTTON_PRESSES=27 NUM_BUTTON_PRESSES value
     * @property {number} NUM_COOKS_INTERRUPTED=28 NUM_COOKS_INTERRUPTED value
     * @property {number} NUM_OOW_ERRORS=29 NUM_OOW_ERRORS value
     * @property {number} NUM_OVERTEMP_ERRORS=30 NUM_OVERTEMP_ERRORS value
     * @property {number} NUM_MOTOR_OVER_CURRENT_ERRORS=31 NUM_MOTOR_OVER_CURRENT_ERRORS value
     * @property {number} NUM_ACCELEROMETER_TRIPS=32 NUM_ACCELEROMETER_TRIPS value
     * @property {number} NUM_MOTOR_STALLS=33 NUM_MOTOR_STALLS value
     */
    $root.UsageMetric = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MOTOR_RUNNING_MINS_LT"] = 0;
        values[valuesById[1] = "TOTAL_REVOLUTIONS"] = 1;
        values[valuesById[2] = "MOTOR_RUNNING_MINS_LT_30C"] = 2;
        values[valuesById[3] = "MOTOR_RUNNING_MINS_LT_35C"] = 3;
        values[valuesById[4] = "MOTOR_RUNNING_MINS_LT_40C"] = 4;
        values[valuesById[5] = "MOTOR_RUNNING_MINS_LT_45C"] = 5;
        values[valuesById[6] = "MOTOR_RUNNING_MINS_LT_50C"] = 6;
        values[valuesById[7] = "MOTOR_RUNNING_MINS_LT_55C"] = 7;
        values[valuesById[8] = "MOTOR_RUNNING_MINS_LT_60C"] = 8;
        values[valuesById[9] = "MOTOR_RUNNING_MINS_LT_65C"] = 9;
        values[valuesById[10] = "MOTOR_RUNNING_MINS_LT_70C"] = 10;
        values[valuesById[11] = "MOTOR_RUNNING_MINS_LT_75C"] = 11;
        values[valuesById[12] = "MOTOR_RUNNING_MINS_LT_80C"] = 12;
        values[valuesById[13] = "MOTOR_RUNNING_MINS_LT_85C"] = 13;
        values[valuesById[14] = "MOTOR_RUNNING_MINS_LT_90C"] = 14;
        values[valuesById[15] = "MOTOR_RUNNING_MINS_LT_95C"] = 15;
        values[valuesById[16] = "MOTOR_RUNNING_MINS_GT_95C"] = 16;
        values[valuesById[17] = "MOTOR_RPM_MEAN"] = 17;
        values[valuesById[18] = "MOTOR_RPM_VARIANCE"] = 18;
        values[valuesById[19] = "MOTOR_CURRENT_MEAN"] = 19;
        values[valuesById[20] = "MOTOR_CURRENT_VARIANCE"] = 20;
        values[valuesById[21] = "HEATER_MEAN"] = 21;
        values[valuesById[22] = "HEATER_VARIANCE"] = 22;
        values[valuesById[23] = "PRESSURE_MEAN"] = 23;
        values[valuesById[24] = "PRESSURE_VARIANCE"] = 24;
        values[valuesById[25] = "BATH_TEMP_MEAN"] = 25;
        values[valuesById[26] = "BATH_TEMP_VARIANCE"] = 26;
        values[valuesById[27] = "NUM_BUTTON_PRESSES"] = 27;
        values[valuesById[28] = "NUM_COOKS_INTERRUPTED"] = 28;
        values[valuesById[29] = "NUM_OOW_ERRORS"] = 29;
        values[valuesById[30] = "NUM_OVERTEMP_ERRORS"] = 30;
        values[valuesById[31] = "NUM_MOTOR_OVER_CURRENT_ERRORS"] = 31;
        values[valuesById[32] = "NUM_ACCELEROMETER_TRIPS"] = 32;
        values[valuesById[33] = "NUM_MOTOR_STALLS"] = 33;
        return values;
    })();
    
    $root.UsageDataMetric = (function() {
    
        /**
         * Properties of a UsageDataMetric.
         * @exports IUsageDataMetric
         * @interface IUsageDataMetric
         * @property {UsageMetric} key UsageDataMetric key
         * @property {IMetricValue} value UsageDataMetric value
         */
    
        /**
         * Constructs a new UsageDataMetric.
         * @exports UsageDataMetric
         * @classdesc Represents a UsageDataMetric.
         * @constructor
         * @param {IUsageDataMetric=} [properties] Properties to set
         */
        function UsageDataMetric(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * UsageDataMetric key.
         * @member {UsageMetric}key
         * @memberof UsageDataMetric
         * @instance
         */
        UsageDataMetric.prototype.key = 0;
    
        /**
         * UsageDataMetric value.
         * @member {IMetricValue}value
         * @memberof UsageDataMetric
         * @instance
         */
        UsageDataMetric.prototype.value = null;
    
        /**
         * Creates a new UsageDataMetric instance using the specified properties.
         * @function create
         * @memberof UsageDataMetric
         * @static
         * @param {IUsageDataMetric=} [properties] Properties to set
         * @returns {UsageDataMetric} UsageDataMetric instance
         */
        UsageDataMetric.create = function create(properties) {
            return new UsageDataMetric(properties);
        };
    
        /**
         * Encodes the specified UsageDataMetric message. Does not implicitly {@link UsageDataMetric.verify|verify} messages.
         * @function encode
         * @memberof UsageDataMetric
         * @static
         * @param {IUsageDataMetric} message UsageDataMetric message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UsageDataMetric.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.key);
            $root.MetricValue.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified UsageDataMetric message, length delimited. Does not implicitly {@link UsageDataMetric.verify|verify} messages.
         * @function encodeDelimited
         * @memberof UsageDataMetric
         * @static
         * @param {IUsageDataMetric} message UsageDataMetric message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UsageDataMetric.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a UsageDataMetric message from the specified reader or buffer.
         * @function decode
         * @memberof UsageDataMetric
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {UsageDataMetric} UsageDataMetric
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UsageDataMetric.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UsageDataMetric();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.int32();
                    break;
                case 2:
                    message.value = $root.MetricValue.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("key"))
                throw $util.ProtocolError("missing required 'key'", { instance: message });
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a UsageDataMetric message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof UsageDataMetric
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {UsageDataMetric} UsageDataMetric
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UsageDataMetric.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a UsageDataMetric message.
         * @function verify
         * @memberof UsageDataMetric
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UsageDataMetric.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.key) {
            default:
                return "key: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
                break;
            }
            var error = $root.MetricValue.verify(message.value);
            if (error)
                return "value." + error;
            return null;
        };
    
        /**
         * Creates a UsageDataMetric message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof UsageDataMetric
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {UsageDataMetric} UsageDataMetric
         */
        UsageDataMetric.fromObject = function fromObject(object) {
            if (object instanceof $root.UsageDataMetric)
                return object;
            var message = new $root.UsageDataMetric();
            switch (object.key) {
            case "MOTOR_RUNNING_MINS_LT":
            case 0:
                message.key = 0;
                break;
            case "TOTAL_REVOLUTIONS":
            case 1:
                message.key = 1;
                break;
            case "MOTOR_RUNNING_MINS_LT_30C":
            case 2:
                message.key = 2;
                break;
            case "MOTOR_RUNNING_MINS_LT_35C":
            case 3:
                message.key = 3;
                break;
            case "MOTOR_RUNNING_MINS_LT_40C":
            case 4:
                message.key = 4;
                break;
            case "MOTOR_RUNNING_MINS_LT_45C":
            case 5:
                message.key = 5;
                break;
            case "MOTOR_RUNNING_MINS_LT_50C":
            case 6:
                message.key = 6;
                break;
            case "MOTOR_RUNNING_MINS_LT_55C":
            case 7:
                message.key = 7;
                break;
            case "MOTOR_RUNNING_MINS_LT_60C":
            case 8:
                message.key = 8;
                break;
            case "MOTOR_RUNNING_MINS_LT_65C":
            case 9:
                message.key = 9;
                break;
            case "MOTOR_RUNNING_MINS_LT_70C":
            case 10:
                message.key = 10;
                break;
            case "MOTOR_RUNNING_MINS_LT_75C":
            case 11:
                message.key = 11;
                break;
            case "MOTOR_RUNNING_MINS_LT_80C":
            case 12:
                message.key = 12;
                break;
            case "MOTOR_RUNNING_MINS_LT_85C":
            case 13:
                message.key = 13;
                break;
            case "MOTOR_RUNNING_MINS_LT_90C":
            case 14:
                message.key = 14;
                break;
            case "MOTOR_RUNNING_MINS_LT_95C":
            case 15:
                message.key = 15;
                break;
            case "MOTOR_RUNNING_MINS_GT_95C":
            case 16:
                message.key = 16;
                break;
            case "MOTOR_RPM_MEAN":
            case 17:
                message.key = 17;
                break;
            case "MOTOR_RPM_VARIANCE":
            case 18:
                message.key = 18;
                break;
            case "MOTOR_CURRENT_MEAN":
            case 19:
                message.key = 19;
                break;
            case "MOTOR_CURRENT_VARIANCE":
            case 20:
                message.key = 20;
                break;
            case "HEATER_MEAN":
            case 21:
                message.key = 21;
                break;
            case "HEATER_VARIANCE":
            case 22:
                message.key = 22;
                break;
            case "PRESSURE_MEAN":
            case 23:
                message.key = 23;
                break;
            case "PRESSURE_VARIANCE":
            case 24:
                message.key = 24;
                break;
            case "BATH_TEMP_MEAN":
            case 25:
                message.key = 25;
                break;
            case "BATH_TEMP_VARIANCE":
            case 26:
                message.key = 26;
                break;
            case "NUM_BUTTON_PRESSES":
            case 27:
                message.key = 27;
                break;
            case "NUM_COOKS_INTERRUPTED":
            case 28:
                message.key = 28;
                break;
            case "NUM_OOW_ERRORS":
            case 29:
                message.key = 29;
                break;
            case "NUM_OVERTEMP_ERRORS":
            case 30:
                message.key = 30;
                break;
            case "NUM_MOTOR_OVER_CURRENT_ERRORS":
            case 31:
                message.key = 31;
                break;
            case "NUM_ACCELEROMETER_TRIPS":
            case 32:
                message.key = 32;
                break;
            case "NUM_MOTOR_STALLS":
            case 33:
                message.key = 33;
                break;
            }
            if (object.value != null) {
                if (typeof object.value !== "object")
                    throw TypeError(".UsageDataMetric.value: object expected");
                message.value = $root.MetricValue.fromObject(object.value);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a UsageDataMetric message. Also converts values to other types if specified.
         * @function toObject
         * @memberof UsageDataMetric
         * @static
         * @param {UsageDataMetric} message UsageDataMetric
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UsageDataMetric.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = options.enums === String ? "MOTOR_RUNNING_MINS_LT" : 0;
                object.value = null;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.enums === String ? $root.UsageMetric[message.key] : message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = $root.MetricValue.toObject(message.value, options);
            return object;
        };
    
        /**
         * Converts this UsageDataMetric to JSON.
         * @function toJSON
         * @memberof UsageDataMetric
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UsageDataMetric.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return UsageDataMetric;
    })();
    
    $root.MetricValue = (function() {
    
        /**
         * Properties of a MetricValue.
         * @exports IMetricValue
         * @interface IMetricValue
         * @property {number} [intValue] MetricValue intValue
         * @property {number} [floatValue] MetricValue floatValue
         */
    
        /**
         * Constructs a new MetricValue.
         * @exports MetricValue
         * @classdesc Represents a MetricValue.
         * @constructor
         * @param {IMetricValue=} [properties] Properties to set
         */
        function MetricValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * MetricValue intValue.
         * @member {number}intValue
         * @memberof MetricValue
         * @instance
         */
        MetricValue.prototype.intValue = 0;
    
        /**
         * MetricValue floatValue.
         * @member {number}floatValue
         * @memberof MetricValue
         * @instance
         */
        MetricValue.prototype.floatValue = 0;
    
        /**
         * Creates a new MetricValue instance using the specified properties.
         * @function create
         * @memberof MetricValue
         * @static
         * @param {IMetricValue=} [properties] Properties to set
         * @returns {MetricValue} MetricValue instance
         */
        MetricValue.create = function create(properties) {
            return new MetricValue(properties);
        };
    
        /**
         * Encodes the specified MetricValue message. Does not implicitly {@link MetricValue.verify|verify} messages.
         * @function encode
         * @memberof MetricValue
         * @static
         * @param {IMetricValue} message MetricValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MetricValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.intValue != null && message.hasOwnProperty("intValue"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.intValue);
            if (message.floatValue != null && message.hasOwnProperty("floatValue"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.floatValue);
            return writer;
        };
    
        /**
         * Encodes the specified MetricValue message, length delimited. Does not implicitly {@link MetricValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof MetricValue
         * @static
         * @param {IMetricValue} message MetricValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MetricValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a MetricValue message from the specified reader or buffer.
         * @function decode
         * @memberof MetricValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {MetricValue} MetricValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MetricValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MetricValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.intValue = reader.uint32();
                    break;
                case 2:
                    message.floatValue = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a MetricValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof MetricValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {MetricValue} MetricValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MetricValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a MetricValue message.
         * @function verify
         * @memberof MetricValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MetricValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.intValue != null && message.hasOwnProperty("intValue"))
                if (!$util.isInteger(message.intValue))
                    return "intValue: integer expected";
            if (message.floatValue != null && message.hasOwnProperty("floatValue"))
                if (typeof message.floatValue !== "number")
                    return "floatValue: number expected";
            return null;
        };
    
        /**
         * Creates a MetricValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof MetricValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {MetricValue} MetricValue
         */
        MetricValue.fromObject = function fromObject(object) {
            if (object instanceof $root.MetricValue)
                return object;
            var message = new $root.MetricValue();
            if (object.intValue != null)
                message.intValue = object.intValue >>> 0;
            if (object.floatValue != null)
                message.floatValue = Number(object.floatValue);
            return message;
        };
    
        /**
         * Creates a plain object from a MetricValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof MetricValue
         * @static
         * @param {MetricValue} message MetricValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MetricValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.intValue = 0;
                object.floatValue = 0;
            }
            if (message.intValue != null && message.hasOwnProperty("intValue"))
                object.intValue = message.intValue;
            if (message.floatValue != null && message.hasOwnProperty("floatValue"))
                object.floatValue = options.json && !isFinite(message.floatValue) ? String(message.floatValue) : message.floatValue;
            return object;
        };
    
        /**
         * Converts this MetricValue to JSON.
         * @function toJSON
         * @memberof MetricValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MetricValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return MetricValue;
    })();
    
    $root.GetUsageDataRequest = (function() {
    
        /**
         * Properties of a GetUsageDataRequest.
         * @exports IGetUsageDataRequest
         * @interface IGetUsageDataRequest
         */
    
        /**
         * Constructs a new GetUsageDataRequest.
         * @exports GetUsageDataRequest
         * @classdesc Represents a GetUsageDataRequest.
         * @constructor
         * @param {IGetUsageDataRequest=} [properties] Properties to set
         */
        function GetUsageDataRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new GetUsageDataRequest instance using the specified properties.
         * @function create
         * @memberof GetUsageDataRequest
         * @static
         * @param {IGetUsageDataRequest=} [properties] Properties to set
         * @returns {GetUsageDataRequest} GetUsageDataRequest instance
         */
        GetUsageDataRequest.create = function create(properties) {
            return new GetUsageDataRequest(properties);
        };
    
        /**
         * Encodes the specified GetUsageDataRequest message. Does not implicitly {@link GetUsageDataRequest.verify|verify} messages.
         * @function encode
         * @memberof GetUsageDataRequest
         * @static
         * @param {IGetUsageDataRequest} message GetUsageDataRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetUsageDataRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified GetUsageDataRequest message, length delimited. Does not implicitly {@link GetUsageDataRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetUsageDataRequest
         * @static
         * @param {IGetUsageDataRequest} message GetUsageDataRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetUsageDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a GetUsageDataRequest message from the specified reader or buffer.
         * @function decode
         * @memberof GetUsageDataRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetUsageDataRequest} GetUsageDataRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetUsageDataRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetUsageDataRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a GetUsageDataRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetUsageDataRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetUsageDataRequest} GetUsageDataRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetUsageDataRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a GetUsageDataRequest message.
         * @function verify
         * @memberof GetUsageDataRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetUsageDataRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a GetUsageDataRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetUsageDataRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetUsageDataRequest} GetUsageDataRequest
         */
        GetUsageDataRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.GetUsageDataRequest)
                return object;
            return new $root.GetUsageDataRequest();
        };
    
        /**
         * Creates a plain object from a GetUsageDataRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetUsageDataRequest
         * @static
         * @param {GetUsageDataRequest} message GetUsageDataRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetUsageDataRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this GetUsageDataRequest to JSON.
         * @function toJSON
         * @memberof GetUsageDataRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetUsageDataRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return GetUsageDataRequest;
    })();
    
    $root.GetUsageDataReply = (function() {
    
        /**
         * Properties of a GetUsageDataReply.
         * @exports IGetUsageDataReply
         * @interface IGetUsageDataReply
         * @property {Result} result GetUsageDataReply result
         * @property {string} [serialNumber] GetUsageDataReply serialNumber
         * @property {IUsageDataMetric} metric GetUsageDataReply metric
         */
    
        /**
         * Constructs a new GetUsageDataReply.
         * @exports GetUsageDataReply
         * @classdesc Represents a GetUsageDataReply.
         * @constructor
         * @param {IGetUsageDataReply=} [properties] Properties to set
         */
        function GetUsageDataReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * GetUsageDataReply result.
         * @member {Result}result
         * @memberof GetUsageDataReply
         * @instance
         */
        GetUsageDataReply.prototype.result = 0;
    
        /**
         * GetUsageDataReply serialNumber.
         * @member {string}serialNumber
         * @memberof GetUsageDataReply
         * @instance
         */
        GetUsageDataReply.prototype.serialNumber = "";
    
        /**
         * GetUsageDataReply metric.
         * @member {IUsageDataMetric}metric
         * @memberof GetUsageDataReply
         * @instance
         */
        GetUsageDataReply.prototype.metric = null;
    
        /**
         * Creates a new GetUsageDataReply instance using the specified properties.
         * @function create
         * @memberof GetUsageDataReply
         * @static
         * @param {IGetUsageDataReply=} [properties] Properties to set
         * @returns {GetUsageDataReply} GetUsageDataReply instance
         */
        GetUsageDataReply.create = function create(properties) {
            return new GetUsageDataReply(properties);
        };
    
        /**
         * Encodes the specified GetUsageDataReply message. Does not implicitly {@link GetUsageDataReply.verify|verify} messages.
         * @function encode
         * @memberof GetUsageDataReply
         * @static
         * @param {IGetUsageDataReply} message GetUsageDataReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetUsageDataReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.serialNumber);
            $root.UsageDataMetric.encode(message.metric, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified GetUsageDataReply message, length delimited. Does not implicitly {@link GetUsageDataReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetUsageDataReply
         * @static
         * @param {IGetUsageDataReply} message GetUsageDataReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetUsageDataReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a GetUsageDataReply message from the specified reader or buffer.
         * @function decode
         * @memberof GetUsageDataReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetUsageDataReply} GetUsageDataReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetUsageDataReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetUsageDataReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.serialNumber = reader.string();
                    break;
                case 3:
                    message.metric = $root.UsageDataMetric.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            if (!message.hasOwnProperty("metric"))
                throw $util.ProtocolError("missing required 'metric'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a GetUsageDataReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetUsageDataReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetUsageDataReply} GetUsageDataReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetUsageDataReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a GetUsageDataReply message.
         * @function verify
         * @memberof GetUsageDataReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetUsageDataReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.result) {
            default:
                return "result: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                break;
            }
            if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
                if (!$util.isString(message.serialNumber))
                    return "serialNumber: string expected";
            var error = $root.UsageDataMetric.verify(message.metric);
            if (error)
                return "metric." + error;
            return null;
        };
    
        /**
         * Creates a GetUsageDataReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetUsageDataReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetUsageDataReply} GetUsageDataReply
         */
        GetUsageDataReply.fromObject = function fromObject(object) {
            if (object instanceof $root.GetUsageDataReply)
                return object;
            var message = new $root.GetUsageDataReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            if (object.serialNumber != null)
                message.serialNumber = String(object.serialNumber);
            if (object.metric != null) {
                if (typeof object.metric !== "object")
                    throw TypeError(".GetUsageDataReply.metric: object expected");
                message.metric = $root.UsageDataMetric.fromObject(object.metric);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a GetUsageDataReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetUsageDataReply
         * @static
         * @param {GetUsageDataReply} message GetUsageDataReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetUsageDataReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
                object.serialNumber = "";
                object.metric = null;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            if (message.serialNumber != null && message.hasOwnProperty("serialNumber"))
                object.serialNumber = message.serialNumber;
            if (message.metric != null && message.hasOwnProperty("metric"))
                object.metric = $root.UsageDataMetric.toObject(message.metric, options);
            return object;
        };
    
        /**
         * Converts this GetUsageDataReply to JSON.
         * @function toJSON
         * @memberof GetUsageDataReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetUsageDataReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return GetUsageDataReply;
    })();
    
    $root.ResetUsageDataRequest = (function() {
    
        /**
         * Properties of a ResetUsageDataRequest.
         * @exports IResetUsageDataRequest
         * @interface IResetUsageDataRequest
         */
    
        /**
         * Constructs a new ResetUsageDataRequest.
         * @exports ResetUsageDataRequest
         * @classdesc Represents a ResetUsageDataRequest.
         * @constructor
         * @param {IResetUsageDataRequest=} [properties] Properties to set
         */
        function ResetUsageDataRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new ResetUsageDataRequest instance using the specified properties.
         * @function create
         * @memberof ResetUsageDataRequest
         * @static
         * @param {IResetUsageDataRequest=} [properties] Properties to set
         * @returns {ResetUsageDataRequest} ResetUsageDataRequest instance
         */
        ResetUsageDataRequest.create = function create(properties) {
            return new ResetUsageDataRequest(properties);
        };
    
        /**
         * Encodes the specified ResetUsageDataRequest message. Does not implicitly {@link ResetUsageDataRequest.verify|verify} messages.
         * @function encode
         * @memberof ResetUsageDataRequest
         * @static
         * @param {IResetUsageDataRequest} message ResetUsageDataRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResetUsageDataRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified ResetUsageDataRequest message, length delimited. Does not implicitly {@link ResetUsageDataRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ResetUsageDataRequest
         * @static
         * @param {IResetUsageDataRequest} message ResetUsageDataRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResetUsageDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ResetUsageDataRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ResetUsageDataRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ResetUsageDataRequest} ResetUsageDataRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResetUsageDataRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResetUsageDataRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ResetUsageDataRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ResetUsageDataRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ResetUsageDataRequest} ResetUsageDataRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResetUsageDataRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ResetUsageDataRequest message.
         * @function verify
         * @memberof ResetUsageDataRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResetUsageDataRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a ResetUsageDataRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ResetUsageDataRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ResetUsageDataRequest} ResetUsageDataRequest
         */
        ResetUsageDataRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ResetUsageDataRequest)
                return object;
            return new $root.ResetUsageDataRequest();
        };
    
        /**
         * Creates a plain object from a ResetUsageDataRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ResetUsageDataRequest
         * @static
         * @param {ResetUsageDataRequest} message ResetUsageDataRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResetUsageDataRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this ResetUsageDataRequest to JSON.
         * @function toJSON
         * @memberof ResetUsageDataRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResetUsageDataRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ResetUsageDataRequest;
    })();
    
    $root.ResetUsageDataReply = (function() {
    
        /**
         * Properties of a ResetUsageDataReply.
         * @exports IResetUsageDataReply
         * @interface IResetUsageDataReply
         * @property {Result} result ResetUsageDataReply result
         */
    
        /**
         * Constructs a new ResetUsageDataReply.
         * @exports ResetUsageDataReply
         * @classdesc Represents a ResetUsageDataReply.
         * @constructor
         * @param {IResetUsageDataReply=} [properties] Properties to set
         */
        function ResetUsageDataReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ResetUsageDataReply result.
         * @member {Result}result
         * @memberof ResetUsageDataReply
         * @instance
         */
        ResetUsageDataReply.prototype.result = 0;
    
        /**
         * Creates a new ResetUsageDataReply instance using the specified properties.
         * @function create
         * @memberof ResetUsageDataReply
         * @static
         * @param {IResetUsageDataReply=} [properties] Properties to set
         * @returns {ResetUsageDataReply} ResetUsageDataReply instance
         */
        ResetUsageDataReply.create = function create(properties) {
            return new ResetUsageDataReply(properties);
        };
    
        /**
         * Encodes the specified ResetUsageDataReply message. Does not implicitly {@link ResetUsageDataReply.verify|verify} messages.
         * @function encode
         * @memberof ResetUsageDataReply
         * @static
         * @param {IResetUsageDataReply} message ResetUsageDataReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResetUsageDataReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified ResetUsageDataReply message, length delimited. Does not implicitly {@link ResetUsageDataReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ResetUsageDataReply
         * @static
         * @param {IResetUsageDataReply} message ResetUsageDataReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResetUsageDataReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ResetUsageDataReply message from the specified reader or buffer.
         * @function decode
         * @memberof ResetUsageDataReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ResetUsageDataReply} ResetUsageDataReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResetUsageDataReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResetUsageDataReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a ResetUsageDataReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ResetUsageDataReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ResetUsageDataReply} ResetUsageDataReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResetUsageDataReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ResetUsageDataReply message.
         * @function verify
         * @memberof ResetUsageDataReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResetUsageDataReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.result) {
            default:
                return "result: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                break;
            }
            return null;
        };
    
        /**
         * Creates a ResetUsageDataReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ResetUsageDataReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ResetUsageDataReply} ResetUsageDataReply
         */
        ResetUsageDataReply.fromObject = function fromObject(object) {
            if (object instanceof $root.ResetUsageDataReply)
                return object;
            var message = new $root.ResetUsageDataReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a ResetUsageDataReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ResetUsageDataReply
         * @static
         * @param {ResetUsageDataReply} message ResetUsageDataReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResetUsageDataReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            return object;
        };
    
        /**
         * Converts this ResetUsageDataReply to JSON.
         * @function toJSON
         * @memberof ResetUsageDataReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResetUsageDataReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ResetUsageDataReply;
    })();
    
    $root.GetLimitsRequest = (function() {
    
        /**
         * Properties of a GetLimitsRequest.
         * @exports IGetLimitsRequest
         * @interface IGetLimitsRequest
         */
    
        /**
         * Constructs a new GetLimitsRequest.
         * @exports GetLimitsRequest
         * @classdesc Represents a GetLimitsRequest.
         * @constructor
         * @param {IGetLimitsRequest=} [properties] Properties to set
         */
        function GetLimitsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new GetLimitsRequest instance using the specified properties.
         * @function create
         * @memberof GetLimitsRequest
         * @static
         * @param {IGetLimitsRequest=} [properties] Properties to set
         * @returns {GetLimitsRequest} GetLimitsRequest instance
         */
        GetLimitsRequest.create = function create(properties) {
            return new GetLimitsRequest(properties);
        };
    
        /**
         * Encodes the specified GetLimitsRequest message. Does not implicitly {@link GetLimitsRequest.verify|verify} messages.
         * @function encode
         * @memberof GetLimitsRequest
         * @static
         * @param {IGetLimitsRequest} message GetLimitsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLimitsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified GetLimitsRequest message, length delimited. Does not implicitly {@link GetLimitsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetLimitsRequest
         * @static
         * @param {IGetLimitsRequest} message GetLimitsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLimitsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a GetLimitsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof GetLimitsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetLimitsRequest} GetLimitsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLimitsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetLimitsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a GetLimitsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetLimitsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetLimitsRequest} GetLimitsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLimitsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a GetLimitsRequest message.
         * @function verify
         * @memberof GetLimitsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetLimitsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a GetLimitsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetLimitsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetLimitsRequest} GetLimitsRequest
         */
        GetLimitsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.GetLimitsRequest)
                return object;
            return new $root.GetLimitsRequest();
        };
    
        /**
         * Creates a plain object from a GetLimitsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetLimitsRequest
         * @static
         * @param {GetLimitsRequest} message GetLimitsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetLimitsRequest.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this GetLimitsRequest to JSON.
         * @function toJSON
         * @memberof GetLimitsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetLimitsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return GetLimitsRequest;
    })();
    
    $root.GetLimitsReply = (function() {
    
        /**
         * Properties of a GetLimitsReply.
         * @exports IGetLimitsReply
         * @interface IGetLimitsReply
         * @property {Result} result GetLimitsReply result
         * @property {number} maxTemp GetLimitsReply maxTemp
         */
    
        /**
         * Constructs a new GetLimitsReply.
         * @exports GetLimitsReply
         * @classdesc Represents a GetLimitsReply.
         * @constructor
         * @param {IGetLimitsReply=} [properties] Properties to set
         */
        function GetLimitsReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * GetLimitsReply result.
         * @member {Result}result
         * @memberof GetLimitsReply
         * @instance
         */
        GetLimitsReply.prototype.result = 0;
    
        /**
         * GetLimitsReply maxTemp.
         * @member {number}maxTemp
         * @memberof GetLimitsReply
         * @instance
         */
        GetLimitsReply.prototype.maxTemp = 0;
    
        /**
         * Creates a new GetLimitsReply instance using the specified properties.
         * @function create
         * @memberof GetLimitsReply
         * @static
         * @param {IGetLimitsReply=} [properties] Properties to set
         * @returns {GetLimitsReply} GetLimitsReply instance
         */
        GetLimitsReply.create = function create(properties) {
            return new GetLimitsReply(properties);
        };
    
        /**
         * Encodes the specified GetLimitsReply message. Does not implicitly {@link GetLimitsReply.verify|verify} messages.
         * @function encode
         * @memberof GetLimitsReply
         * @static
         * @param {IGetLimitsReply} message GetLimitsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLimitsReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.maxTemp);
            return writer;
        };
    
        /**
         * Encodes the specified GetLimitsReply message, length delimited. Does not implicitly {@link GetLimitsReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof GetLimitsReply
         * @static
         * @param {IGetLimitsReply} message GetLimitsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLimitsReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a GetLimitsReply message from the specified reader or buffer.
         * @function decode
         * @memberof GetLimitsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {GetLimitsReply} GetLimitsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLimitsReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetLimitsReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.maxTemp = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("result"))
                throw $util.ProtocolError("missing required 'result'", { instance: message });
            if (!message.hasOwnProperty("maxTemp"))
                throw $util.ProtocolError("missing required 'maxTemp'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a GetLimitsReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof GetLimitsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {GetLimitsReply} GetLimitsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLimitsReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a GetLimitsReply message.
         * @function verify
         * @memberof GetLimitsReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetLimitsReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            switch (message.result) {
            default:
                return "result: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                break;
            }
            if (typeof message.maxTemp !== "number")
                return "maxTemp: number expected";
            return null;
        };
    
        /**
         * Creates a GetLimitsReply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof GetLimitsReply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {GetLimitsReply} GetLimitsReply
         */
        GetLimitsReply.fromObject = function fromObject(object) {
            if (object instanceof $root.GetLimitsReply)
                return object;
            var message = new $root.GetLimitsReply();
            switch (object.result) {
            case "CS_SUCCESS":
            case 0:
                message.result = 0;
                break;
            case "CS_ERROR_SVC_HANDLER_MISSING":
            case 1:
                message.result = 1;
                break;
            case "CS_ERROR_SOFTDEVICE_NOT_ENABLED":
            case 2:
                message.result = 2;
                break;
            case "CS_ERROR_INTERNAL":
            case 3:
                message.result = 3;
                break;
            case "CS_ERROR_NO_MEM":
            case 4:
                message.result = 4;
                break;
            case "CS_ERROR_NOT_FOUND":
            case 5:
                message.result = 5;
                break;
            case "CS_ERROR_NOT_SUPPORTED":
            case 6:
                message.result = 6;
                break;
            case "CS_ERROR_INVALID_PARAM":
            case 7:
                message.result = 7;
                break;
            case "CS_ERROR_INVALID_STATE":
            case 8:
                message.result = 8;
                break;
            case "CS_ERROR_INVALID_LENGTH":
            case 9:
                message.result = 9;
                break;
            case "CS_ERROR_INVALID_FLAGS":
            case 10:
                message.result = 10;
                break;
            case "CS_ERROR_INVALID_DATA":
            case 11:
                message.result = 11;
                break;
            case "CS_ERROR_DATA_SIZE":
            case 12:
                message.result = 12;
                break;
            case "CS_ERROR_TIMEOUT":
            case 13:
                message.result = 13;
                break;
            case "CS_ERROR_NULL":
            case 14:
                message.result = 14;
                break;
            case "CS_ERROR_FORBIDDEN":
            case 15:
                message.result = 15;
                break;
            case "CS_ERROR_INVALID_ADDR":
            case 16:
                message.result = 16;
                break;
            case "CS_ERROR_BUSY":
            case 17:
                message.result = 17;
                break;
            case "CS_ERROR_IO_FAILED":
            case 18:
                message.result = 18;
                break;
            case "CS_ERROR_ALREADY_EXISTS":
            case 19:
                message.result = 19;
                break;
            case "CS_ERROR_END_OF_FILE":
            case 20:
                message.result = 20;
                break;
            case "CS_ERROR_NOT_CONNECTED":
            case 21:
                message.result = 21;
                break;
            case "CS_ERROR_UNKNOWN_RPC_MSG":
            case 22:
                message.result = 22;
                break;
            case "CS_ERROR_WIFI_DUPLICATE_SCAN_RESULT":
            case 23:
                message.result = 23;
                break;
            case "CS_ERROR_WIFI_KEY_ERROR":
            case 24:
                message.result = 24;
                break;
            case "CS_ERROR_WIFI_INVALID_ROLE":
            case 25:
                message.result = 25;
                break;
            case "CS_ERROR_WIFI_INVALID_SEC_TYPE":
            case 26:
                message.result = 26;
                break;
            case "CS_ERROR_WIFI_INVALID_WEP_IND":
            case 27:
                message.result = 27;
                break;
            case "CS_ERROR_WIFI_ALREADY_DISCONN":
            case 28:
                message.result = 28;
                break;
            case "CS_ERROR_WIFI_NOT_CONN":
            case 29:
                message.result = 29;
                break;
            case "CS_ERROR_WIFI_DISCONNECT":
            case 30:
                message.result = 30;
                break;
            case "CS_ERROR_WIFI_INVALID_PWD":
            case 31:
                message.result = 31;
                break;
            case "CS_ERROR_WIFI_RX_BUFF":
            case 32:
                message.result = 32;
                break;
            case "CS_ERROR_WIFI_AP_TERM_CONN":
            case 33:
                message.result = 33;
                break;
            case "CS_ERROR_INVALID_SOCKET":
            case 34:
                message.result = 34;
                break;
            case "CS_ERROR_IO_IN_PROGRESS":
            case 35:
                message.result = 35;
                break;
            case "CS_ERROR_GEN_SOCK_FAILURE":
            case 36:
                message.result = 36;
                break;
            }
            if (object.maxTemp != null)
                message.maxTemp = Number(object.maxTemp);
            return message;
        };
    
        /**
         * Creates a plain object from a GetLimitsReply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof GetLimitsReply
         * @static
         * @param {GetLimitsReply} message GetLimitsReply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetLimitsReply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = options.enums === String ? "CS_SUCCESS" : 0;
                object.maxTemp = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.Result[message.result] : message.result;
            if (message.maxTemp != null && message.hasOwnProperty("maxTemp"))
                object.maxTemp = options.json && !isFinite(message.maxTemp) ? String(message.maxTemp) : message.maxTemp;
            return object;
        };
    
        /**
         * Converts this GetLimitsReply to JSON.
         * @function toJSON
         * @memberof GetLimitsReply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetLimitsReply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return GetLimitsReply;
    })();

    return $root;
});
